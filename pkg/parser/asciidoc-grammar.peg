{
package parser 

import (
    "strconv"

    "github.com/bytesparadise/libasciidoc/pkg/types"

    log "github.com/sirupsen/logrus"
    errs "github.com/pkg/errors"
)

// *****************************************************************************************
// This file is generated after its sibling `asciidoc-grammar.peg` file. DO NOT MODIFY !
// *****************************************************************************************

// Parse parses the data from b using filename as information in the
// error messages.
func ParseDocument(filename string, r io.Reader, opts ...Option) (types.Document, error) {
	preparsedDoc, err := PreparseDocument(filename, r, opts...)
	if err != nil {
		return types.Document{}, err
	}
    result, err := Parse(filename, preparsedDoc, opts...)
	if err != nil {
		return types.Document{}, err
	}
	doc, ok := result.(types.Document)
	if !ok {
		return types.Document{}, errs.Errorf("invalid type of result: %T (expected a Document)", result)
	}
	return doc, nil
}

}

// ------------------------------------------
// Document - fully parsed document
// ------------------------------------------
Document <- frontMatter:(FrontMatter?) blocks:(DocumentBlocks) EOF {
    return types.NewDocument(frontMatter, blocks.([]interface{}))
}

DocumentBlocks <- block:(Section0WithMetadata?) blocks:(DocumentBlock*) {
    if block != nil {
        return append([]interface{}{block}, blocks.([]interface{})...), nil
    }
    return blocks.([]interface{}), nil
}

DocumentBlock <- attributes:(ElementAttribute)* block:(Section / DocumentElement) {
    return types.WithAttributes(block, attributes.([]interface{}))
}

// ------------------------------------------------------------------------------------
// PreparsedDocument: document where only preprocessing directives are parsed,
// while the rest is just retrieved as raw text
// ------------------------------------------------------------------------------------
PreparsedDocument <- blocks:(PreparsedDocumentBlocks) EOF {
    return types.NewPreparsedDocument(blocks.([]interface{}))
}

PreparsedDocumentBlocks <- (DocumentAttributeDeclaration / 
        RawSectionTitle /
        FileInclusion / 
        BlankLine / 
        RawText)* 

RawSectionTitle <- prefix:(RawSectionTitlePrefix) title:RawSectionTitleContent {
    return types.NewRawSectionTitle(prefix.(types.RawSectionTitlePrefix), title.(types.RawSectionTitleContent))
}

RawSectionTitlePrefix <- level:("="+ { return c.text, nil }) spaces:(WS+ { return c.text, nil }) {
    return types.NewRawSectionTitlePrefix(level.([]byte), spaces.([]byte))
}

RawSectionTitleContent <- content:((!EOL .)+ { return c.text, nil }) EOL {
    return types.NewRawSectionTitleContent(content.([]byte))
}

RawText <- content:((!EOL .)+ { return c.text, nil }) EOL {
    return types.NewRawText(content.([]byte))
}

// ------------------------------------------
// Front Matter
// ------------------------------------------
FrontMatter <- YamlFrontMatter 

FrontMatter <- YamlFrontMatterToken content:(YamlFrontMatterContent) YamlFrontMatterToken {
    return types.NewYamlFrontMatter(content.(string))
}

YamlFrontMatterToken  <- "---" EOL

YamlFrontMatterContent <- (Alphanums / Spaces / (!YamlFrontMatterToken  .){
    return string(c.text), nil
})* {
    return string(c.text), nil
}

// ------------------------------------------
// Document Metadata
// ------------------------------------------

DocumentAuthors <- DocumentAuthorsInlineForm / DocumentAuthorsAttributeForm

DocumentAuthorsInlineForm <- WS* !":" authors:(DocumentAuthor+) EOL {
    return types.NewDocumentAuthors(authors.([]interface{}))
}

DocumentAuthorsAttributeForm <- WS* ":author:" author:(DocumentAuthor) EOL {
    return []types.DocumentAuthor{author.(types.DocumentAuthor)}, nil
}

DocumentAuthor <- WS* fullname:(DocumentAuthorName) email:(DocumentAuthorEmail)? WS* ";"? WS* {
    return types.NewDocumentAuthor(fullname, email)
}

// "<" marks the beginning of the author email, and ";" is the authors separator
DocumentAuthorName <- (Alphanums / (!"<" !";" !NEWLINE .))+ {
    return string(c.text), nil
}

DocumentAuthorEmail <- "<" email:((Alphanums / (!">" !EOL  .))+ {
    return string(c.text), nil
}) ">" {
    return email, nil
}

// see http://asciidoctor.org/docs/user-manual/#revision-number-date-and-remark
// Eg: "v1.0, October 2, 2013: First incarnation"
DocumentRevision <- WS* !":" revision:(
        (revnumber:(DocumentRevisionNumber) ","? revdate:(DocumentRevisionDate)? ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(revnumber, revdate, revremark)
        }) / (revdate:(DocumentRevisionDate) ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(nil, revdate, revremark)
        })) EOL {
    return revision, nil
}

// DocumentRevisionNumber MUST start with a `v` or MAY start with a `v` but MUST end with a `,`
DocumentRevisionNumber <- "v"i DIGIT  (Alphanums / Spaces / (!EOL !"," !":"  .){
    return string(c.text), nil
})+ {
    return string(c.text), nil
} / "v"i? DIGIT  (Alphanums / Spaces / (!EOL !"," !":"  .))+ WS* &"," {
    return string(c.text), nil
}

DocumentRevisionDate <- (Alphanums / Spaces / (!EOL !":"  .){
    return string(c.text), nil
})+ {
    return string(c.text), nil
}

DocumentRevisionRemark <- (Alphanums / Spaces / (!EOL  .){
    return string(c.text), nil
})+ {
    return string(c.text), nil
}

// ------------------------------------------
// Document Attributes
// ------------------------------------------
DocumentAttributeDeclaration <- ":" name:(DocumentAttributeName) ":" WS* EOL {
    return types.NewDocumentAttributeDeclaration(name.(string), nil)
} / ":" name:(DocumentAttributeName) ":" WS+ value:(DocumentAttributeValue) EOL {
    return types.NewDocumentAttributeDeclaration(name.(string), value)
} 

DocumentAttributeReset <- ":!" name:(DocumentAttributeName) ":" WS* EOL {
    return types.NewDocumentAttributeReset(name.(string))
} / ":" name:(DocumentAttributeName) "!:" WS* EOL {
    return types.NewDocumentAttributeReset(name.(string))
}

DocumentAttributeSubstitution <- "{" name:(DocumentAttributeName) "}" {
    return types.NewDocumentAttributeSubstitution(name.(string))
}

// AttributeName must be at least one character long, 
// must begin with a word character (A-Z, a-z, 0-9 or _) and 
// must only contain word Word and hyphens ("-").
DocumentAttributeName <- ([A-Z] / [a-z] / [0-9] / "_") ([A-Z] / [a-z] / [0-9] / "-")* {
    return string(c.text), nil
}

DocumentAttributeValue <- (Alphanums / Spaces / (!NEWLINE  .){
    return string(c.text), nil
})* {
    return string(c.text), nil
}

// ------------------------------------------
// Document blocks
// ------------------------------------------
DocumentElement <- !EOF // when reaching EOF, do not try to parse a new document block again
    element:(BlankLine 
            / FileInclusion
            / VerseBlock
            / VerseParagraph
            / ImageBlock 
            / List 
            / FencedBlock
            / ListingBlock
            / ExampleBlock
            / CommentBlock
            / SingleLineComment
            / QuoteBlock 
            / SidebarBlock
            / Table 
            / LiteralBlock 
            / DocumentAttributeDeclaration 
            / DocumentAttributeReset 
            / TableOfContentsMacro
            / UserMacroBlock
            / Paragraph) {
    return element, nil
}

// ------------------------------------------
// Element Attributes
// ------------------------------------------
ElementAttribute <- &("[" / "." / "#") // skip if the content does not start with one of those characters
    attr:(ElementID / 
        ElementTitle / 
        ElementRole / 
        SourceAttributes / 
        QuoteAttributes / 
        VerseAttributes / 
        AdmonitionMarkerAttribute / 
        HorizontalLayout / 
        AttributeGroup) WS* EOL {
    return attr, nil // avoid returning something like `[]interface{}{attr, EOL}`
}

ElementAttributePrefixMatch <- "[" / "." / "#"

// identify all attributes that masquerade a block element into something else.
MasqueradeAttribute <- QuoteAttributes / VerseAttributes

ElementID <- "[[" id:(ID) "]]" {
    return types.NewElementID(id.(string))
} / "[#" id:(ID) "]" {
    return types.NewElementID(id.(string))
}

InlineElementID <- "[[" id:(ID) "]]" WS* {
    return types.NewInlineElementID(id.(string))
}

// a title attached to an element, such as a ImageBlock
// a title starts with a single "." followed by the value, without space in-between
ElementTitle <- "." !"." !WS title:((Alphanums / Spaces / (!NEWLINE  .){
    return string(c.text), nil
})+ {
    return string(c.text), nil
}) {
    return types.NewElementTitle(title.(string))
}

// a role attached to an element, such as a ImageBlock
// a role starts is wrapped in "[. ]" 
ElementRole <- "[." !WS role:((Alphanums / Spaces / (!NEWLINE !"]"  .){
    return string(c.text), nil
})+ {
    return string(c.text), nil
}) "]" {
    return types.NewElementRole(role.(string))
}

// expression for the whole admonition marker, but only retains the actual kind
AdmonitionMarkerAttribute <- "[" k:(AdmonitionKind) "]" {
    return types.NewAdmonitionAttribute(k.(types.AdmonitionKind))
}

// a paragraph or a delimited block may contain source code in a given language
SourceAttributes <- "[source]" {
    return types.NewSourceAttributes("")
} / "[source," language:((Alphanums / Spaces / (!NEWLINE !"]"  .){
        return string(c.text), nil
    })+ {
        return string(c.text), nil
    })"]" {
    return types.NewSourceAttributes(language.(string))
}

// one or more attributes. eg: [foo, key1=value1, key2 = value2 , ]
AttributeGroup <- "[" !WS attributes:(GenericAttribute)*  "]" {
    return types.NewAttributeGroup(attributes.([]interface{}))
}

GenericAttribute <-  GenericAttributeWithValue / GenericAttributeWithoutValue

GenericAttributeWithValue <- key:(AttributeKey) "=" value:(AttributeValue) ","? WS* { // value is set
    return types.NewGenericAttribute(key.(string), value)
}

GenericAttributeWithoutValue <- key:(AttributeKey) ","? WS* { // value is not set
    return types.NewGenericAttribute(key.(string), nil)
}

AttributeKey <- !QuoteKind !VerseKind !LiteralKind key:(Alphanums / Spaces / (!"=" !"," !"]"  .){
    return string(c.text), nil
})+  {
    return string(c.text), nil
}

AttributeValue <- value:(Alphanums / Spaces / (!"=" !"," !"]"  .){
    return string(c.text), nil
})* {
    return string(c.text), nil
}

HorizontalLayout <- "[horizontal]" {
    return types.ElementAttributes{"layout": "horizontal"}, nil
}

QuoteAttributes <- "[" kind:(QuoteKind) WS* "," author:(QuoteAuthor) "," title:(QuoteTitle) "]" {
    return types.NewQuoteAttributes(kind.(string), author.(string), title.(string))
} / 
// verse without specific title
"[" kind:(QuoteKind) WS* "," author:(QuoteAuthor) "]" {
    return types.NewQuoteAttributes(kind.(string), author.(string), "")
} /
// verse without specific author
"[" kind:(QuoteKind) WS* "]" {
    return types.NewQuoteAttributes(kind.(string), "", "")
}

QuoteKind <- "quote" {
    return string(c.text), nil
}

VerseAttributes <- attribute:("[" kind:(VerseKind) WS* "," author:(QuoteAuthor) "," title:(QuoteTitle) "]" {
        return types.NewQuoteAttributes(kind.(string), author.(string), title.(string))
    } / 
    // verse without specific title
    "[" kind:(VerseKind) WS* "," author:(QuoteAuthor) "]" {
        return types.NewQuoteAttributes(kind.(string), author.(string), "")
    } /
    // verse without specific author
    "[" kind:(VerseKind) WS* "]" {
        return types.NewQuoteAttributes(kind.(string), "", "")
    }
)
#{
    c.state["verse"] = true
    return nil
} {
    return attribute, nil
}

VerseKind <- "verse" {
    return string(c.text), nil
}

QuoteAuthor <- (Alphanums / Spaces / (!EOL !"," !"]"  .){
    return string(c.text), nil
})* {
    return string(c.text), nil
}

QuoteTitle <- (Alphanums / Spaces / (!EOL !"," !"]"  .))* {
    return string(c.text), nil
}

InlineAttributes <- "[" attrs:(GenericAttribute)* "]" {
    return types.NewInlineAttributes(attrs.([]interface{}))
} 


// ------------------------------------------
// Sections
// ------------------------------------------
Section <- &"=" // just skip if the content does not start with at least one '='
    section:(Section0 / Section1 / Section2 / Section3 / Section4 / Section5) {
        return section, nil
}

Section1_5 <- &"=" // just skip if the content does not start with at least one '='
    section:(Section1 / Section2 / Section3 / Section4 / Section5) {
        return section, nil
}

Section2_5 <- &"="  // just skip if the content does not start with at least one '='
    section:(Section2 / Section3 / Section4 / Section5) {
        return section, nil
}

Section3_5 <- &"=" // just skip if the content does not start with at least one '='
    section:(Section3 / Section4 / Section5) {
        return section, nil
}

Section4_5 <- &"=" // just skip if the content does not start with at least one '='
    section:(Section4 / Section5) {
        return section, nil
}

SectionTitlePrefix <- Section0TitlePrefix /
                        Section1TitlePrefix /
                        Section2TitlePrefix /
                        Section3TitlePrefix /
                        Section4TitlePrefix /
                        Section5TitlePrefix

Section0TitlePrefix <- "=" WS+ {
    return c.text, nil
}

Section0WithMetadata <- title:(Section0Title) 
        authors:(DocumentAuthors?) 
        revision:(DocumentRevision?) 
        BlankLine* 
        elements:(Section0Element*) {
    return types.NewSection0WithMetadata(title.(types.SectionTitle), authors, revision, elements.([]interface{}))
}

Section0 <- header:(Section0Title) 
        BlankLine*
        elements:(Section0Element*) {
    return types.NewSection(0, header.(types.SectionTitle), elements.([]interface{}))
}

Section0Title <- Section0TitlePrefix elements:(TitleElements) id:(InlineElementID*) EOL {
    return types.NewSectionTitle(elements.(types.InlineElements), id.([]interface{})) 
}


Section0Element <- !Section0TitlePrefix 
        attributes:(ElementAttribute)* 
        element:(Section1_5 / DocumentElement) {
    return types.WithAttributes(element, attributes.([]interface{}))
}

Section1 <- header:(Section1Title) 
        BlankLine*
        elements:(Section1Element*) {
    return types.NewSection(1, header.(types.SectionTitle), elements.([]interface{}))
}

Section1TitlePrefix <- "==" WS+ {
    return c.text, nil
}

Section1Title <- Section1TitlePrefix elements:(TitleElements) id:(InlineElementID*) EOL {
    return types.NewSectionTitle(elements.(types.InlineElements), id.([]interface{}))
}

Section1Element <- !Section1TitlePrefix 
        attributes:(ElementAttribute)* 
        element:(Section2_5 / DocumentElement) {
    return types.WithAttributes(element, attributes.([]interface{}))
}

Section2 <- header:(Section2Title) 
        BlankLine*
        elements:(Section2Element*) {
    return types.NewSection(2, header.(types.SectionTitle), elements.([]interface{}))
}

Section2TitlePrefix <- "===" WS+ {
    return c.text, nil
}

Section2Title <- Section2TitlePrefix elements:(TitleElements) id:(InlineElementID*) EOL {
    return types.NewSectionTitle(elements.(types.InlineElements), id.([]interface{})) 
}

Section2Element <- !Section1TitlePrefix !Section2TitlePrefix 
    attributes:(ElementAttribute)* 
    element:(Section3_5 / DocumentElement) {
        return types.WithAttributes(element, attributes.([]interface{}))
}

Section3 <- header:(Section3Title) 
        BlankLine*
        elements:(Section3Element*) {
    return types.NewSection(3, header.(types.SectionTitle), elements.([]interface{}))
}

Section3TitlePrefix <- "====" WS+ {
    return c.text, nil
}

Section3Title <- Section3TitlePrefix elements:(TitleElements) id:(InlineElementID*) EOL {
    return types.NewSectionTitle(elements.(types.InlineElements), id.([]interface{})) 
}

Section3Element <- !Section1TitlePrefix !Section2TitlePrefix !Section3TitlePrefix
    attributes:(ElementAttribute)* 
    element:(Section4_5 / DocumentElement) {
        return types.WithAttributes(element, attributes.([]interface{}))
}

Section4 <- header:(Section4Title) 
        BlankLine*
        elements:(Section4Element*) {
    return types.NewSection(4, header.(types.SectionTitle), elements.([]interface{}))
}

Section4TitlePrefix <- "=====" WS+ {
    return c.text, nil
}

Section4Title <- Section4TitlePrefix elements:(TitleElements) id:(InlineElementID*) EOL {
    return types.NewSectionTitle(elements.(types.InlineElements), id.([]interface{})) 
}

Section4Element <- !Section1TitlePrefix !Section2TitlePrefix !Section3TitlePrefix !Section4TitlePrefix
    attributes:(ElementAttribute)* 
    element:(Section5 / DocumentElement) {
        return types.WithAttributes(element, attributes.([]interface{}))
}

Section5 <- header:(Section5Title) 
        BlankLine*
        elements:(Section5Element*) {
    return types.NewSection(5, header.(types.SectionTitle), elements.([]interface{}))
}

Section5TitlePrefix <- "======" WS+ {
    return c.text, nil
}

Section5Title <- Section5TitlePrefix elements:(TitleElements) id:(InlineElementID*) EOL {
    return types.NewSectionTitle(elements.(types.InlineElements), id.([]interface{})) 
}

Section5Element <- 
    !Section1Title !Section2Title !Section3Title !Section4Title !Section5Title 
    attributes:(ElementAttribute)* 
    element:(DocumentElement) {
        return types.WithAttributes(element, attributes.([]interface{}))
}

TitleElements <- elements:(!NEWLINE !InlineElementID TitleElement)+ { // absorbs heading and trailing spaces
    return types.NewInlineElements(elements.([]interface{}))
} 

TitleElement <- element:(Spaces / Dot / CrossReference / Passthrough / InlineImage / Link / InlineFootnote / Alphanums / QuotedText / DocumentAttributeSubstitution / Parenthesis / LineBreak / Word) {
    return element, nil
}

// ------------------------------------------
// Table of Contents
// ------------------------------------------
TableOfContentsMacro <- "toc::[]" NEWLINE

// ------------------------------------------
// User Macro
// ------------------------------------------
UserMacroBlock <- name:(UserMacroName) "::" value:(UserMacroValue) attrs:(UserMacroAttributes) {
    return types.NewUserMacroBlock(name.(string), value.(string), attrs.(types.ElementAttributes), string(c.text))
}

InlineUserMacro <- name:(UserMacroName) ":" value:(UserMacroValue) attrs:(UserMacroAttributes) {
    return types.NewInlineUserMacro(name.(string), value.(string), attrs.(types.ElementAttributes), string(c.text))
}

UserMacroName <- (!URL_SCHEME !"." !":" !"[" !"]" !WS !EOL .)+ {
    return string(c.text), nil
}

UserMacroValue <- (!":" !"[" !"]" !EOL .)* {
    return string(c.text), nil
}

UserMacroAttributes <- "[" attrs:(GenericAttribute)* "]" {
    return types.NewInlineAttributes(attrs.([]interface{}))
}

// ------------------------------------------
// File inclusions
// ------------------------------------------
FileInclusion <- incl:("include::" path:(Location) inlineAttributes:(FileIncludeAttributes) { 
        return types.NewFileInclusion(path.(types.Location), inlineAttributes.(types.ElementAttributes), string(c.text))
    }) WS* EOL {
    return incl.(types.FileInclusion), nil
}

FileIncludeAttributes <- "[" attrs:(LineRangesAttribute / GenericAttribute)* "]" {
    return types.NewInlineAttributes(attrs.([]interface{}))
} 

LineRangesAttribute <- "lines=" lines:(LineRangesAttributeValue) ","? { 
    return types.NewLineRangesAttribute(lines)
} 

LineRangesAttributeValue <- value:(MultipleRanges 
                        / MultipleQuotedRanges 
                        / MultilineRange 
                        / MultilineQuotedRange 
                        / SinglelineQuotedRange
                        / SinglelineRange 
                        / UndefinedLineRange) WS* (&"," / &"]") {
    return value, nil
}

MultipleRanges <- first:(MultilineRange / SinglelineRange) 
    others:(";" other:(MultilineRange / SinglelineRange) {
        return other, nil
    })+ {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

MultipleQuotedRanges <- "\"" first:(MultilineRange / SinglelineRange) 
    others:("," other:(MultilineRange / SinglelineRange) {
        return other, nil
    })+ "\"" {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

MultilineRange <- start:(NUMBER) ".." end:(NUMBER) { // eg: lines=12..14
    return types.NewMultilineRange(start.(int), end.(int))
} 

MultilineQuotedRange <- "\"" start:(NUMBER) ".." end:(NUMBER) "\"" { // eg: lines=12..14
    return types.NewMultilineRange(start.(int), end.(int))
} 

SinglelineRange <- singleline:(NUMBER) { // eg: lines=12
    return types.NewSingleLineRange(singleline.(int))
}

SinglelineQuotedRange <- "\"" singleline:(NUMBER) "\"" { // eg: lines=12
    return types.NewSingleLineRange(singleline.(int))
}

UndefinedLineRange <- (!"]" !"," !WS .)* {
    return string(c.text), nil
}

// ------------------------------------------
// Lists
// ------------------------------------------
List <- 
    // list items can be followed by an optional, single blank line
    elements:ListItems {
    return types.NewList(elements.([]interface{}))
}

ListItems <- ListItem+

ListItem <- 
    // list items can be separated with one or more blank lines, 
    // but as soon as an element attribute is set after one or more blank lines, 
    // then the item begins a new list
    (!BlankLine &ElementAttribute? / !BlankLine &SingleLineComment? / BlankLine+ !ElementAttribute) 
    attributes:(ElementAttribute)* 
    item:(OrderedListItem / UnorderedListItem / LabeledListItem) {
        return types.WithAttributes(item, attributes.([]interface{}))
    }

ListParagraph <- comment:(SingleLineComment) {
        return comment, nil
    } / lines:(ListParagraphLine)+ {
        return types.NewParagraph(lines.([]interface{}))
    } 

ListParagraphLine <- 
    !BlankLine 
    !SingleLineComment
    !OrderedListItemPrefix
    !UnorderedListItemPrefix
    !(LabeledListItemTerm LabeledListItemSeparator) 
    !ListItemContinuation
    !ElementAttribute
    !BlockDelimiter
    line:(
        elements:(InlineElement)+ linebreak:(LineBreak)? { // absorbs heading and trailing spaces
            return types.NewInlineElements(append(elements.([]interface{}), linebreak))
        }) EOL { 
            return line, nil
        }

ListItemContinuation <- "+" WS* EOL 

ContinuedListElement <- blanklines:(BlankLine)* ListItemContinuation element:DocumentElement{
    return types.NewContinuedListElement(-len(blanklines.([]interface{})), element) // offset is negative
}



// ------------------------------------------
// Ordered List Items
// ------------------------------------------
OrderedListItem <- prefix:(OrderedListItemPrefix) content:(OrderedListItemContent) {
    return types.NewOrderedListItem(prefix.(types.OrderedListItemPrefix), content.([]interface{}))
}

OrderedListItemPrefix <- WS* prefix:(
    // implicit numbering: '.' to '.....'
    "....." { // numbering style: "....."
        return types.NewOrderedListItemPrefix(types.UpperRoman, 5)
    } / "...." { // numbering style: "...."
        return types.NewOrderedListItemPrefix(types.UpperAlpha, 4)
    } / "..." { // numbering style: "..."
        return types.NewOrderedListItemPrefix(types.LowerRoman, 3)
    } / ".." { // numbering style: ".."
        return types.NewOrderedListItemPrefix(types.LowerAlpha, 2)
    } / "." { // numbering style: "."
        return types.NewOrderedListItemPrefix(types.Arabic, 1)
    // explicit numbering
    } / ([0-9])+ "." {  // numbering style: "1."
        return types.NewOrderedListItemPrefix(types.Arabic, 1)
    } / ([a-z]) "." { // numbering style: "a."
        return types.NewOrderedListItemPrefix(types.LowerAlpha, 1)
    } / ([A-Z]) "." { // numbering style: "A."
        return types.NewOrderedListItemPrefix(types.UpperAlpha, 1)
    } / ([a-z])+ ")" { // numbering style: "i)"
        return types.NewOrderedListItemPrefix(types.LowerRoman, 1)
    } / ([A-Z])+ ")" { // numbering style: "I)"
        return types.NewOrderedListItemPrefix(types.UpperRoman, 1)
    }) WS+ {
        return prefix, nil
}

OrderedListItemContent <- elements:(ListParagraph+ ContinuedListElement*) { // Another list or a literal paragraph immediately following a list item will be implicitly included in the list item
    return types.NewListItemContent(elements.([]interface{}))
} 

// ------------------------------------------
// Unordered List Items
// ------------------------------------------
UnorderedListItem <- prefix:(UnorderedListItemPrefix) checkstyle:(UnorderedListItemCheckStyle)? content:(UnorderedListItemContent) {
    return types.NewUnorderedListItem(prefix.(types.UnorderedListItemPrefix), checkstyle, content.([]interface{}))
}

UnorderedListItemPrefix <- 
    WS* prefix:(
        "*****" { // ignore whitespaces, only return the relevant "*"/"-" marker
           return types.NewUnorderedListItemPrefix(types.FiveAsterisks, 5)
        } 
        / "****" { // ignore whitespaces, only return the relevant "*"/"-" marker
            return types.NewUnorderedListItemPrefix(types.FourAsterisks, 4)
        } 
        / "***" { // ignore whitespaces, only return the relevant "*"/"-" marker
            return types.NewUnorderedListItemPrefix(types.ThreeAsterisks, 3)
        } 
        / "**" { // ignore whitespaces, only return the relevant "*"/"-" marker
            return types.NewUnorderedListItemPrefix(types.TwoAsterisks, 2)
        } 
        / "*" { // ignore whitespaces, only return the relevant "*"/"-" marker
            return types.NewUnorderedListItemPrefix(types.OneAsterisk, 1)
        } 
        / "-" { // ignore whitespaces, only return the relevant "*"/"-" marker
            return types.NewUnorderedListItemPrefix(types.Dash, 1)
        }) WS+ {
            return prefix, nil
} 

UnorderedListItemCheckStyle <- &"[" style:(
      "[ ]" { return types.Unchecked, nil } 
    / "[*]" { return types.Checked, nil } 
    / "[x]" { return types.Checked, nil }
    ) WS+ {
        return style, nil
    }

UnorderedListItemContent <- elements:(ListParagraph+ ContinuedListElement*) { // Another list or a literal paragraph immediately following a list item will be implicitly included in the list item
    return types.NewListItemContent(elements.([]interface{}))
} 

// ------------------------------------------
// Labeled List Items
// ------------------------------------------
LabeledListItem <- term:(LabeledListItemTerm) separator:(LabeledListItemSeparator) description:(LabeledListItemDescription) {
    return types.NewLabeledListItem(len(separator.(string)) - 1, term.(string), description.([]interface{}))
}

LabeledListItemTerm <- (Alphanums / Spaces / (!NEWLINE !"::"  .){
    return string(c.text), nil
})*  {
    return string(c.text), nil
}

// term separator: ('::', ':::' or '::::') and at least one space or endline
LabeledListItemSeparator <- ("::::" / ":::" / "::")  {
    return string(c.text), nil
}

    
LabeledListItemDescription <- 
    (WS / NEWLINE)+ elements:(ListParagraph / ContinuedListElement)* { // TODO: replace with (ListParagraph+ ContinuedListElement*) and use a single rule for all item contents ?
        return types.NewListItemContent(elements.([]interface{}))
    } / WS* EOL { // here, WS is optional since there is no description afterwards
        return []interface{}{}, nil
}


// ------------------------------------------
// Admonitions
// ------------------------------------------
AdmonitionKind <- "TIP" {
        return types.Tip, nil
    } / "NOTE" {
        return types.Note, nil
    } / "IMPORTANT" {
        return types.Important, nil
    } / "WARNING" {
        return types.Warning, nil
    } / "CAUTION" {
        return types.Caution, nil
}

// ------------------------------------------
// Paragraphs
// ------------------------------------------
// a paragraph is a group of line ending with a blank line (or end of file)
// a paragraph cannot start with the `section` sequence (`= `, `== `, etc.)
Paragraph <- 
    // admonition paragraph 
    !("="+ WS+ !NEWLINE) t:(AdmonitionKind) ": " lines:(InlineElements)+ { 
        return types.NewAdmonitionParagraph(lines.([]interface{}), t.(types.AdmonitionKind))
    } / 
    // other kind of paragraph (verse, regular, etc.)
    !("="+ WS+ !NEWLINE) lines:(InlineElements)+ { 
        return types.NewParagraph(lines.([]interface{}))
} 

VerseParagraph <- 
    &{
        verse, ok := c.state["verse"].(bool); 
        return ok && verse, nil
    }
    verse:(
        // admonition paragraph 
        t:(AdmonitionKind) ": " lines:(InlineElements)+ { 
            return types.NewAdmonitionParagraph(lines.([]interface{}), t.(types.AdmonitionKind))
        } / 
        // other kind of paragraph (verse, regular, etc.)
        lines:(InlineElements)+ { 
            return types.NewParagraph(lines.([]interface{}))
        } 
    ) #{
        c.state["verse"] = false
        return nil
    } {
        return verse, nil
}

InlineElements <- !BlankLine
    elements:(comment:(SingleLineComment) {
        return types.NewInlineElements([]interface{}{comment})
    } / !BlockDelimiter elements:(InlineElement)+ linebreak:(LineBreak)? EOL { 
        return types.NewInlineElements(append(elements.([]interface{}), linebreak))
    }) {
        return elements, nil
    }

InlineElement <- !EOL !LineBreak 
    element:(Spaces 
        / Dot 
        / InlineImage 
        / Link 
        / Passthrough 
        / InlineFootnote 
        / InlineUserMacro 
        / Alphanums 
        / QuotedText 
        / CrossReference 
        / DocumentAttributeSubstitution 
        / InlineElementID 
        / Parenthesis 
        / Word) {
    return element, nil
}

// special case for re-parsing a group of elements after a document substitution:
// we should treat substitution that did not happen (eg: missing attribute) as regular
// strings - (used by the inline element renderer)
InlineElementsWithoutSubtitution <- !BlankLine !BlockDelimiter elements:(InlineElementWithoutSubtitution)* linebreak:(LineBreak)? EOL { 
    return types.NewInlineElements(append(elements.([]interface{}), linebreak))
} 

InlineElementWithoutSubtitution <- !EOL !LineBreak 
    element:(Spaces 
        / Dot 
        / InlineImage 
        / Link 
        / Passthrough 
        / Alphanums 
        / QuotedText 
        / CrossReference 
        / InlineElementID
        / Parenthesis 
        / Word) {
    return element, nil
}

// special case for parsing files to include in delimited blocks with 'verbatim' substitution
VerbatimBlock <- elements:(BlankLine / FileInclusion / VerbatimParagraph)* EOF {
    return elements, nil
}

VerbatimParagraph <- lines:(!EOF line:(VerbatimParagraphLine) {
    return line, nil
})+ {
    return types.NewParagraph(lines.([]interface{}))
}

VerbatimParagraphLine <- !BlockDelimiter !BlankLine elements:(VerbatimParagraphLineElement)* linebreak:(LineBreak)? EOL { 
    return types.NewInlineElements(append(elements.([]interface{}), linebreak))
} 

VerbatimParagraphLineElement <- (!EOL !LineBreak .)+ {
    return string(c.text), nil
}

// ----------------------------------------------------------------------------
// Explicit line breaks
// ----------------------------------------------------------------------------
LineBreak <- WS "+" WS* &EOL {
    return types.NewLineBreak()    
}

// ----------------------------------------------------------------------------
// Quoted Texts (bold, italic and monospace) including substitution prevention
// ----------------------------------------------------------------------------
QuotedText <- BoldText 
            / ItalicText 
            / MonospaceText 
            / SubscriptText 
            / SuperscriptText 
            / EscapedBoldText 
            / EscapedItalicText 
            / EscapedMonospaceText 
            / EscapedSubscriptText 
            / EscapedSuperscriptText
            / SubScriptOrSuperScriptPrefix // if a '^' or '~' is alone (ie, badly formatted superscript or subscript, then accept it as-is) 

QuotedTextPrefix <- "**" / "*" / "__" / "_" / "``" / "`" / "^" / "~"

SubScriptOrSuperScriptPrefix <- "^" / "~" { // rule used withn `words` to detect superscript or subscript portions, eg in math formulae.
    return string(c.text), nil
}

BoldText <- 
    !`\\` "**" content:(BoldTextElements) "**" { // double punctuation must be evaluated first
        return types.NewQuotedText(types.Bold, content.([]interface{}))
    } / !`\\` "**" content:(BoldTextElements) "*" { // unbalanced `**` vs `*` punctuation
        result := append([]interface{}{"*"}, content.([]interface{}))
        return types.NewQuotedText(types.Bold, result)
    } / !`\` "*" content:(BoldTextElements) "*" !Alphanum { // single punctuation cannot be followed by a character (needs '**' to emphazise a portion of a word)
        return types.NewQuotedText(types.Bold, content.([]interface{}))
} 

BoldTextElements <- BoldTextElement (WS* BoldTextElement)*

BoldTextElement <- QuotedText
        / InlineImage 
        / Link 
        / Passthrough 
        / NonBoldText // word with quote punctuation is only accepted if nothing matched before, so we have a chance to stop

NonBoldText <- (!NEWLINE !WS !"*"  !"^" !"~" .)+ { 
    return c.text, nil
}

EscapedBoldText <- 
    backslashes:(TwoOrMoreBackslashes) "**" content:(BoldTextElements) "**" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "**", content.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "**" content:(BoldTextElements) "*" { // unbalanced `**` vs `*` punctuation
        result := append([]interface{}{"*"}, content.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "*", result)
    } / backslashes:(OneOrMoreBackslashes) "*" content:(BoldTextElements) "*" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "*", content.([]interface{}))
} 

OneOrMoreBackslashes <- `\`+ {
    return string(c.text), nil
}

TwoOrMoreBackslashes <- `\\` `\`* {
    return string(c.text), nil
}

ItalicText <- 
    !`\\` "__" content:(ItalicTextElements) "__" {
        return types.NewQuotedText(types.Italic, content.([]interface{}))
    } / !`\\` "__" content:(ItalicTextElements) "_" { // unbalanced `__` vs `_` punctuation
        result := append([]interface{}{"_"}, content.([]interface{}))
        return types.NewQuotedText(types.Italic, result)
    } / !`\` "_" content:(ItalicTextElements) "_" !Alphanum { // single punctuation cannot be followed by a character (needs '__' to emphazise a portion of a word)
        return types.NewQuotedText(types.Italic, content.([]interface{}))
}

ItalicTextElements <- ItalicTextElement (WS* ItalicTextElement)*

ItalicTextElement <- QuotedText
        / InlineImage 
        / Link 
        / Passthrough 
        / NonItalicText // word with quote punctuation is only accepted if nothing matched before, so we have a chance to stop

NonItalicText <- (!NEWLINE !WS !"_"  !"^" !"~" .)+ { 
    return c.text, nil
}

EscapedItalicText <- 
    backslashes:(TwoOrMoreBackslashes) "__" content:(ItalicTextElements) "__" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "__", content.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "__" content:(ItalicTextElements) "_" { // unbalanced `__` vs `_` punctuation
        result := append([]interface{}{"_"}, content.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "_", result)
    } / backslashes:(OneOrMoreBackslashes) "_" content:(ItalicTextElements) "_" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "_", content.([]interface{}))
} 

MonospaceText <- 
    !`\\` "``" content:(MonospaceTextElements) "``" { // double punctuation must be evaluated first
        return types.NewQuotedText(types.Monospace, content.([]interface{}))
    } / !`\\` "``" content:(MonospaceTextElements) "`" { // unbalanced "``" vs "`" punctuation
        result := append([]interface{}{"`"}, content.([]interface{}))
        return types.NewQuotedText(types.Monospace, result)
    } / !`\` "`" content:(MonospaceTextElements) "`" !Alphanum { // single punctuation cannot be followed by a character (needs '``' to emphazise a portion of a word)
        return types.NewQuotedText(types.Monospace, content.([]interface{}))
}

MonospaceTextElements <- MonospaceTextElement ((WS / NEWLINE)* MonospaceTextElement)*

MonospaceTextElement <- QuotedText 
        / InlineImage 
        / Link 
        / Passthrough 
        / NonMonospaceText // word with quote punctuation is only accepted if nothing matched before, so we have a chance to stop

NonMonospaceText <- (!WS !NEWLINE !"`" !"^" !"~" .)+ { 
    return c.text, nil
}

EscapedMonospaceText <- 
    backslashes:(TwoOrMoreBackslashes) "``" content:(MonospaceTextElements) "``" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "``", content.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "``" content:(MonospaceTextElements) "`" { // unbalanced "``" vs "`" punctuation
        result := append([]interface{}{"`"}, content.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "`", result)
    } / backslashes:(OneOrMoreBackslashes) "`" content:(MonospaceTextElements) "`" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "`", content.([]interface{}))
} 

SubscriptText <- !`\` "~" content:(SubscriptTextElement) "~" { // wraps a single word
    return types.NewQuotedText(types.Subscript, content)
}

SubscriptTextElement <- QuotedText / NonSubscriptText 

NonSubscriptText <- (!NEWLINE !WS !"~" .)+ { 
    return c.text, nil
}

EscapedSubscriptText <- backslashes:(OneOrMoreBackslashes) "~" content:(SubscriptTextElement) "~" { // simple punctuation must be evaluated last
    return types.NewEscapedQuotedText(backslashes.(string), "~", content)
} 

SuperscriptText <- !`\` "^" content:(SuperscriptTextElement) "^" { // wraps a single word
    return types.NewQuotedText(types.Superscript, content)
}

SuperscriptTextElement <- QuotedText / NonSuperscriptText 

NonSuperscriptText <- (!NEWLINE !WS !"^" .)+ { 
    return c.text, nil
}

EscapedSuperscriptText <- backslashes:(OneOrMoreBackslashes) "^" content:(SuperscriptTextElement) "^" { // simple punctuation must be evaluated last
    return types.NewEscapedQuotedText(backslashes.(string), "^", content)
} 

// ------------------------------------------
// Passthrough
// ------------------------------------------
Passthrough <- TriplePlusPassthrough / SinglePlusPassthrough / PassthroughMacro

SinglePlusPassthroughPrefix <- "+"

SinglePlusPassthrough <- SinglePlusPassthroughPrefix content:(SinglePlusPassthroughContent) SinglePlusPassthroughPrefix !Alphanum {
    return types.NewPassthrough(types.SinglePlusPassthrough, []interface{}{content})
}

SinglePlusPassthroughContent <- ((!SinglePlusPassthroughPrefix !WS !NEWLINE .) (!(WS+ SinglePlusPassthroughPrefix) !SinglePlusPassthroughPrefix !NEWLINE .)* { // no space in the first or last position of the content, but allowed elsewhere
    return types.NewStringElement(string(c.text))
}) / ((!WS !NEWLINE !SinglePlusPassthroughPrefix .)  { // a single character
    return types.NewStringElement(string(c.text))
})

TriplePlusPassthroughPrefix <- "+++"

TriplePlusPassthrough <- TriplePlusPassthroughPrefix content:(TriplePlusPassthroughContent) TriplePlusPassthroughPrefix !Alphanum {
    return types.NewPassthrough(types.TriplePlusPassthrough, []interface{}{content})
}

TriplePlusPassthroughContent <- ((!TriplePlusPassthroughPrefix .)* { // spaces and newlines are also allowed in the first or last position of the content and elsewhere too
    return types.NewStringElement(string(c.text))
}) / ((!WS !NEWLINE !TriplePlusPassthroughPrefix .)?  { // a single character
    return types.NewStringElement(string(c.text))
})

PassthroughMacro <- "pass:[" content:(PassthroughMacroCharacter)* "]" {
    return types.NewPassthrough(types.PassthroughMacro, []interface{}{content})
} / "pass:q[" content:(QuotedText / PassthroughMacroCharacter)* "]" {
    return types.NewPassthrough(types.PassthroughMacro, content.([]interface{}))
}

PassthroughMacroCharacter <- (Alphanums / Spaces / (!"]" .){
    return types.NewStringElement(string(c.text))
})

// ------------------------------------------
// Cross References
// ------------------------------------------
CrossReference <- "<<" id:(ID) WS* "," label:(CrossReferenceLabel) ">>" {
    return types.NewCrossReference(id.(string), label.(string))
} / "<<" id:(ID) ">>" {
    return types.NewCrossReference(id.(string), nil)
}

CrossReferenceLabel <- (Alphanums / Spaces / (!">>"  .){
    return string(c.text), nil
})+ {
    return string(c.text), nil
}

// ------------------------------------------
// Links
// ------------------------------------------
Link <- link:(RelativeLink / ExternalLink) {
    return link, nil
}

ExternalLink <- url:(ExternalLinkURL) inlineAttributes:(LinkAttributes) {
    return types.NewInlineLink(url.(string), inlineAttributes.(types.ElementAttributes))
} / url:(ExternalLinkURL) {
    return types.NewInlineLink(url.(string), nil)
}

ExternalLinkURL <- URL_SCHEME URL {
    return string(c.text), nil
}

// url preceeding with `link:` MUST be followed by square brackets
RelativeLink <- "link:" url:(RelativeLinkURL) inlineAttributes:(LinkAttributes) {
    return types.NewInlineLink(url.(string), inlineAttributes.(types.ElementAttributes))
}

RelativeLinkURL <- URL_SCHEME? URL {
    return string(c.text), nil
}

LinkAttributes <- "[" text:(LinkTextAttribute) ","? WS* otherattrs:(GenericAttribute)* "]" {
    return types.NewInlineLinkAttributes(text, otherattrs.([]interface{}))
} / "[" otherattrs:(GenericAttribute)* "]" {
    return types.NewInlineLinkAttributes(nil, otherattrs.([]interface{}))
} 

LinkTextAttribute <- (Alphanums / Spaces / (!"=" !"," !"]"  .) {
    return string(c.text), nil
})* {
    return string(c.text), nil
}

// ------------------------------------------
// Images
// ------------------------------------------
ImageBlock <- "image::" path:(URL) inlineAttributes:(ImageAttributes) WS* EOL {
    return types.NewImageBlock(path.(string), inlineAttributes.(types.ElementAttributes))
}

InlineImage <- "image:" !":" path:(URL) inlineAttributes:(ImageAttributes) {
    return types.NewInlineImage(path.(string), inlineAttributes.(types.ElementAttributes))
}

// the 'ImageAttributes' rule could be simpler, but the grammar optimizer fails to produce a valid code :(
ImageAttributes <- "[" alt:(ImageAttribute) ","
    width:(ImageAttribute)  ","
    height:(ImageAttribute) ","?
    otherattrs:(GenericAttribute)* "]" {
        return types.NewImageAttributes(alt, width, height, otherattrs.([]interface{}))
} / "[" alt:(ImageAttribute) ","
    width:(ImageAttribute) ","?
    otherattrs:(GenericAttribute)* "]" {
        return types.NewImageAttributes(alt, width, nil, otherattrs.([]interface{}))
} / "[" alt:(ImageAttribute) ","?
    otherattrs:(GenericAttribute)* "]" {
        return types.NewImageAttributes(alt, nil, nil, otherattrs.([]interface{}))
} / "[" otherattrs:(GenericAttribute)* "]" {
        return types.NewImageAttributes(nil, nil, nil, otherattrs.([]interface{}))
} 


ImageAttribute <- (Alphanums / Spaces / (!"," !"=" !"]" .){
    return string(c.text), nil
})+ { // attribute is followed by "," or "]" (but do not consume the latter)
    return string(c.text), nil
}

// ------------------------------------------------------------------------------------
// Inline foot notes
// ------------------------------------------------------------------------------------
InlineFootnote <- "footnote:[" content:(FootnoteContent) "]" {
    return types.NewFootnote("", content.(types.InlineElements))
} / "footnoteref:[" ref:(FootnoteRef) "," content:(FootnoteContent) "]" {
    return types.NewFootnote(ref.(string), content.(types.InlineElements))
} / "footnoteref:[" ref:(FootnoteRef) "]" {
    return types.NewFootnote(ref.(string), types.InlineElements{}) // foot note referring to another note
}

FootnoteRef <- (Alphanums / Spaces / (!"," !"]" !EOL  .){
    return string(c.text), nil
})*  { // footnote ID not may span multiple lines
    return string(c.text), nil
}

FootnoteContent <- elements:(!"]" !EOL WS* !InlineElementID InlineElement WS*)+  { // footnote content may span multiple lines
        return types.NewInlineElements(elements.([]interface{}))
    }


// ------------------------------------------------------------------------------------
// Delimited Blocks 
// ------------------------------------------------------------------------------------
DelimitedBlock <- FencedBlock 
                / ListingBlock 
                / ExampleBlock 
                / CommentBlock 
                / VerseBlock 
                / QuoteBlock 
                / SidebarBlock

BlockDelimiter <- LiteralBlockDelimiter 
                / FencedBlockDelimiter 
                / ListingBlockDelimiter 
                / ExampleBlockDelimiter 
                / CommentBlockDelimiter 
                / QuoteBlockDelimiter
                / SidebarBlockDelimiter


// -------------------------------------------------------------------------------------
// Fenced Blocks
// -------------------------------------------------------------------------------------
FencedBlockDelimiter <- "```" WS* EOL

FencedBlock <- FencedBlockDelimiter content:(FencedBlockContent)* (FencedBlockDelimiter / EOF) {
    return types.NewDelimitedBlock(types.Fenced, content.([]interface{}), types.None)
}

FencedBlockContent <- BlankLine / FileInclusion / List / BlockParagraph

// -------------------------------------------------------------------------------------
// Listing blocks
// -------------------------------------------------------------------------------------
ListingBlockDelimiter <- "----" WS* EOL

// listing block: verbatim content
ListingBlock <- ListingBlockDelimiter content:(ListingBlockElement)* ((ListingBlockDelimiter) / EOF) {
    return types.NewDelimitedBlock(types.Listing, content.([]interface{}), types.None)
}

ListingBlockElement <- ListingFileInclude / ListingBlockParagraph

ListingFileInclude <- !ListingBlockDelimiter !EOF include:(FileInclusion) {
    return include, nil
}

ListingBlockParagraph <- lines:(ListingBlockLine)+ {
    return types.NewParagraph(lines.([]interface{}), nil)
}

ListingBlockLine <- !ListingBlockDelimiter !EOF line:(ListingBlockLineContent) EOL {
    return line, nil
}

ListingBlockLineContent <- (Alphanums / Spaces / (!ListingBlockDelimiter !EOL  .){
        return string(c.text), nil
    })* { // skip EOL in line content, and stop when quote block delimiter is encountered
        return types.NewInlineElements(string(c.text))
    }

// -------------------------------------------------------------------------------------
// Example blocks
// -------------------------------------------------------------------------------------
ExampleBlockDelimiter <- "====" WS* EOL

ExampleBlock <- ExampleBlockDelimiter content:(BlankLine / FileInclusion / List / BlockParagraph)*  (ExampleBlockDelimiter / EOF) {
    return types.NewDelimitedBlock(types.Example, content.([]interface{}), types.None)
}

// blocks content
BlockParagraph <-  lines:(BlockParagraphLine)+ {
    return types.NewParagraph(lines.([]interface{}), nil)
} 

BlockParagraphLine <- !(OrderedListItemPrefix) 
        !(UnorderedListItemPrefix) 
        !(LabeledListItemTerm LabeledListItemSeparator) 
        !(ListItemContinuation) 
        !(BlockDelimiter) 
        line:(InlineElements) {
    return line, nil
}

// -------------------------------------------------------------------------------------
// Quote blocks
// -------------------------------------------------------------------------------------
QuoteBlockDelimiter <- "____" WS* EOL // same for verse blocks

QuoteBlock <- QuoteBlockDelimiter content:(QuoteBlockElement)* (QuoteBlockDelimiter / EOF) {
    return types.NewDelimitedBlock(types.Quote, content.([]interface{}), types.None)
}

QuoteBlockElement <- 
    !QuoteBlockDelimiter !EOF element:(BlankLine 
            / FileInclusion
            / VerseBlock
            / VerseParagraph
            / ImageBlock 
            / List 
            / FencedBlock
            / ListingBlock
            / ExampleBlock
            / CommentBlock
            / SingleLineComment
            / QuoteBlock 
            / SidebarBlock
            / Table 
            / LiteralBlock 
            / DocumentAttributeDeclaration 
            / DocumentAttributeReset 
            / TableOfContentsMacro
            / QuoteBlockParagraph) {
        return element, nil
    } 

QuoteBlockParagraph <- lines:(InlineElements)+ { 
    return types.NewParagraph(lines.([]interface{}))
}

// -------------------------------------------------------------------------------------
// Verse blocks
// -------------------------------------------------------------------------------------
// VerseBlockDelimiter: see QuoteBlockDelimiter

VerseBlock <- &{
    verse, ok := c.state["verse"].(bool); 
    return ok && verse, nil
}
verse:(QuoteBlockDelimiter content:(VerseBlockElement)* (QuoteBlockDelimiter / EOF) {
    return types.NewDelimitedBlock(types.Verse, content.([]interface{}), types.None)
}) #{
    c.state["verse"] = false
    return nil
} {
    return verse, nil
}

VerseBlockElement <- VerseFileInclude / BlankLine / VerseBlockParagraph


VerseFileInclude <- !QuoteBlockDelimiter !EOF include:(FileInclusion) {
    return include, nil
}

VerseBlockParagraph <- lines:(VerseBlockLine)+ {
    return types.NewParagraph(lines.([]interface{}), nil)
}

VerseBlockLine <- !QuoteBlockDelimiter !BlankLine !EOF line:(VerseBlockLineContent) EOL {
    return line.(types.InlineElements), nil
}

VerseBlockLineContent <- elements:(!QuoteBlockDelimiter !EOL WS* InlineElement WS*)* { // skip EOL in line content, and stop when quote block delimiter is encountered
    return types.NewInlineElements(elements.([]interface{}))
}

// -------------------------------------------------------------------------------------
// Sidebars
// -------------------------------------------------------------------------------------
SidebarBlockDelimiter <- "****" WS* EOL

SidebarBlock <- SidebarBlockDelimiter content:(SidebarBlockContent)*  (SidebarBlockDelimiter / EOF) {
    return types.NewDelimitedBlock(types.Sidebar, content.([]interface{}), types.None)
}

SidebarBlockContent <- BlankLine / FileInclusion / List / NonSidebarBlock / BlockParagraph

NonSidebarBlock <- !SidebarBlock content:(DelimitedBlock) {
    return content, nil
}

// -------------------------------------------------------------------------------------
// Tables
// -------------------------------------------------------------------------------------
Table <- TableDelimiter
    header:(TableLineHeader)?
    lines:(TableLine)*
    (TableDelimiter / EOF) { // end delimiter or end of file
        return types.NewTable(header, lines.([]interface{}))
}

TableCellSeparator <- "|" WS*

TableDelimiter <- "|===" WS* EOL
        
// table line header is a line followed by a blankline
TableLineHeader <- !TableDelimiter cells:(TableCell)+ EOL BlankLine {
    return types.NewTableLine(cells.([]interface{}))
}

TableLine <- !TableDelimiter cells:(TableCell)+ EOL BlankLine* {
    return types.NewTableLine(cells.([]interface{}))
}

TableCell <- TableCellSeparator elements:(!TableCellSeparator !EOL WS* InlineElement WS*)+ {
    return types.NewInlineElements(elements)
}

// -------------------------------------------------------------------------------------
// Comments
// -------------------------------------------------------------------------------------
CommentBlockDelimiter <- "////"

CommentBlock <- CommentBlockDelimiter WS* NEWLINE content:(CommentBlockLine)*  ((CommentBlockDelimiter WS* EOL) / EOF) {
    return types.NewDelimitedBlock(types.Comment, content.([]interface{}), types.Verbatim)
}

CommentBlockLine <- (Alphanums / Spaces / (!CommentBlockDelimiter !EOL  .){
    return string(c.text), nil
})* EOL {
    return string(c.text), nil
}

SingleLineComment <- !CommentBlockDelimiter WS* "//" content:(SingleLineCommentContent) EOL {
    return types.NewSingleLineComment(content.(string))
}

SingleLineCommentContent <- (Alphanums / Spaces / (!EOL  .){
    return string(c.text), nil
})* {
    return string(c.text), nil
}


// -------------------------------------------------------------------------------------
// Literal Blocks (see http://asciidoctor.org/docs/user-manual/#literal-text-and-blocks)
// -------------------------------------------------------------------------------------
LiteralBlock <- ParagraphWithHeadingSpaces / ParagraphWithLiteralBlockDelimiter / ParagraphWithLiteralAttribute

LiteralBlockDelimiter <- "...."

// paragraph indented with one or more spaces on the first line
ParagraphWithHeadingSpaces <- lines:(ParagraphWithHeadingSpacesLines) {
    return types.NewLiteralBlock(types.LiteralBlockWithSpacesOnFirstLine, lines.([]interface{}))
}

// first line MUST start with one (or more) space. Stop when reaching a blank line
ParagraphWithHeadingSpacesLines <- 
    firstLine:(WS (Alphanums / Spaces / (!EOL  .){
        return string(c.text), nil
    })+ {
        return string(c.text), nil
    }) EOL // do not include the trailing 'EOL' on the first line
    otherLines:(
        !BlankLine 
        otherLine:((Alphanums / Spaces / (!EOL  .){
            return string(c.text), nil
        })+ {
            return string(c.text), nil
        }) EOL {
            return otherLine, nil // do not include the trailing 'EOL'
        })* { 
    return append([]interface{}{firstLine}, otherLines.([]interface{})...), nil
}

// paragraph with the literal block delimiter (`....`)
ParagraphWithLiteralBlockDelimiter <- LiteralBlockDelimiter WS* NEWLINE lines:(ParagraphWithLiteralBlockDelimiterLines) ((LiteralBlockDelimiter WS* EOL) / EOF) {
    return types.NewLiteralBlock(types.LiteralBlockWithDelimiter, lines.([]interface{}))
}

// include all lines until delimiter is reached
ParagraphWithLiteralBlockDelimiterLines <- lines:(ParagraphWithLiteralBlockDelimiterLine)* {
    return lines.([]interface{}), nil
}

ParagraphWithLiteralBlockDelimiterLine <-         
    line:((Alphanums / Spaces / (!LiteralBlockDelimiter !EOL .){
        return string(c.text), nil
    })* {
        return string(c.text), nil
    }) EOL { 
        return line, nil // do not include the trailing 'EOL'
}

// paragraph with the literal attribute (`[literal]`)
ParagraphWithLiteralAttribute <- attributes:(LiteralAttribute ElementAttribute*) lines:(ParagraphWithLiteralAttributeLines) {
    return types.NewLiteralBlock(types.LiteralBlockWithAttribute, lines.([]interface{}), attributes.([]interface{}))
}

LiteralKind <- "literal" {
    return string(c.text), nil
}

LiteralAttribute <- "[literal]" WS* NEWLINE {
    return types.NewLiteralAttribute()
}

// include all lines until blankline
ParagraphWithLiteralAttributeLines <- lines:(ParagraphWithLiteralAttributeLine)+ { 
    return lines.([]interface{}), nil
}

ParagraphWithLiteralAttributeLine <- line:(!(BlankLine) (Alphanums / Spaces / (!EOL  .){
    return string(c.text), nil
})+ {
    return string(c.text), nil
}) EOL {
    return line, nil // do not include the trailing 'EOL'
}

// ------------------------------------------
// BlankLine
// ------------------------------------------
BlankLine <- !EOF WS* EOL {
    return types.NewBlankLine()
}

// ------------------------------------------
// Base Types
// ------------------------------------------
Alphanum <- [a-zA-Z0-9]

Parenthesis <- "(" / ")" / "[" / "]"

Alphanums <- [a-zA-Z0-9]+ {
    return string(c.text), nil
}

Dot <- "." {
    return string(c.text), nil
}

Word <- (Alphanums / QuotedTextPrefix / ((!NEWLINE !WS !Parenthesis !"." !QuotedTextPrefix .){
    return types.NewStringElement(string(c.text))
})+ / "."+){ // word cannot contain parenthesis. Dots and ellipsis are treated as independent words (but will be combined afterwards)
    return types.NewStringElement(string(c.text))
}

Spaces <- WS+ {
    return string(c.text), nil
}

Location <- elements:(URL_SCHEME? (DocumentAttributeSubstitution / Word)+) {
    return types.NewLocation(elements.([]interface{}))
}

URL <- (Alphanums / (!NEWLINE !WS !"[" !"]"  .){
    return string(c.text), nil
})+ {
    return string(c.text), nil
}

ID <- (Alphanums / (!NEWLINE !WS !"[" !"]" !"<<" !">>" !","  .){
    return string(c.text), nil
})+ {
    return string(c.text), nil
}

URL_TEXT <- (Alphanums / (!NEWLINE !"[" !"]" .){
    return string(c.text), nil
})+ {
    return string(c.text), nil
}

URL_SCHEME <- "http://" / "https://" / "ftp://" / "irc://" / "mailto:"
DIGIT <- [0-9] {
    return string(c.text), nil
}

NUMBER <- "-"? DIGIT+ {
    return strconv.Atoi(string(c.text))
}

WS <- " " / "\t" {
    return string(c.text), nil
}

NEWLINE <- "\r\n" / "\r" / "\n"

EOF <- !.

EOL <- NEWLINE / EOF