{
package parser 

import (
    "github.com/bytesparadise/libasciidoc/pkg/types"
    log "github.com/sirupsen/logrus"
)

// *****************************************************************************************
// This file is generated after its sibling `asciidoc-grammar.peg` file. DO NOT MODIFY !
// *****************************************************************************************

}

// ------------------------------------------
// Document
// ------------------------------------------
Document <- frontMatter:(FrontMatter?) documentHeader:(DocumentHeader?) blocks:(Section / DocumentBlock)* EOF {
	return types.NewDocument(frontMatter, documentHeader, blocks.([]interface{}))
}

DocumentBlock <- !EOF // when reaching EOF, do not try to parse a new document block again
    block:(BlankLine / DocumentAttributeDeclaration / DocumentAttributeReset / TableOfContentsMacro / List / BlockImage / LiteralBlock / DelimitedBlock / Table / Paragraph) { // element attribute alone should be take recognized as such 
    return block, nil
}

// ------------------------------------------
// Front Matter
// ------------------------------------------
FrontMatter <- YamlFrontMatter 

FrontMatter <- YamlFrontMatterToken content:(YamlFrontMatterContent) YamlFrontMatterToken {
    return types.NewYamlFrontMatter(content.(string))
}

YamlFrontMatterToken  <- "---" EOL

YamlFrontMatterContent <- (!YamlFrontMatterToken .)* {
    return string(c.text), nil
}

// ------------------------------------------
// Document Header
// ------------------------------------------
// TODO: include main title | subtitle with support for custom separator
DocumentHeader <- header:(Section0Title) authors:(DocumentAuthors?) revision:(DocumentRevision?) otherAttributes:(DocumentAttributeDeclaration*){ 
    return types.NewDocumentHeader(header, authors, revision, otherAttributes.([]interface{}))
}

DocumentAuthors <- DocumentAuthorsInlineForm / DocumentAuthorsAttributeForm

DocumentAuthorsInlineForm <- WS* !":" authors:(DocumentAuthor+) EOL {
    return types.NewDocumentAuthors(authors.([]interface{}))
}

DocumentAuthorsAttributeForm <- WS* ":author:" author:(DocumentAuthor) {
    return []types.DocumentAuthor{author.(types.DocumentAuthor)}, nil
}

DocumentAuthor <- WS* namePart1:(DocumentAuthorNamePart) namePart2:(DocumentAuthorNamePart)? namePart3:(DocumentAuthorNamePart)? email:(DocumentAuthorEmail)? WS* ";"? WS*{
    return types.NewDocumentAuthor(namePart1, namePart2, namePart3, email)
} 

// "<" marks the beginning of the author email, and ";" is the authors separator
DocumentAuthorNamePart <- !"<" !";" (!NEWLINE !WS .)+ WS* {
    return string(c.text), nil
}

DocumentAuthorEmail <- "<" email:(!">" !EOL .)+ ">" {
    return string(c.text), nil
}

// see http://asciidoctor.org/docs/user-manual/#revision-number-date-and-remark
// Eg: "v1.0, October 2, 2013: First incarnation"
DocumentRevision <- WS* !":" revnumber:(DocumentRevisionNumber)? ","? revdate:(DocumentRevisionDate)? ":"? revremark:(DocumentRevisionRemark)? EOL {
    return types.NewDocumentRevision(revnumber, revdate, revremark)
}

// DocumentRevisionNumber MUST start with a `v` or MAY start with a `v` but MUST end with a `,`
DocumentRevisionNumber <- "v"i DIGIT  (!EOL !"," !":" .)* {
    return string(c.text), nil
} / "v"i? DIGIT  (!EOL !"," !":" .)* WS* &"," {
    return string(c.text), nil
}

DocumentRevisionDate <- (!EOL !":" .)* {
    return string(c.text), nil
}

DocumentRevisionRemark <- (!EOL .)* {
    return string(c.text), nil
}

// ------------------------------------------
// Document Attributes
// ------------------------------------------
DocumentAttributeDeclaration <- ":" name:(DocumentAttributeName) ":" WS* EOL {
    return types.NewDocumentAttributeDeclaration(name.(string), nil)
} / ":" name:(DocumentAttributeName) ":" WS+ value:(DocumentAttributeValue) EOL {
    return types.NewDocumentAttributeDeclaration(name.(string), value)
} 


DocumentAttributeReset <- DocumentAttributeResetWithSectionTitleBangSymbol / DocumentAttributeResetWithTrailingBangSymbol

DocumentAttributeResetWithSectionTitleBangSymbol <- ":!" name:(DocumentAttributeName) ":" WS* EOL {
    return types.NewDocumentAttributeReset(name.(string))
}

DocumentAttributeResetWithTrailingBangSymbol <- ":" name:(DocumentAttributeName) "!:" WS* EOL {
    return types.NewDocumentAttributeReset(name.(string))
}

DocumentAttributeSubstitution <- "{" name:(DocumentAttributeName) "}" {
    return types.NewDocumentAttributeSubstitution(name.(string))
}

// AttributeName must be at least one character long, 
// must begin with a word character (A-Z, a-z, 0-9 or _) and 
// must only contain word Word and hyphens ("-").
DocumentAttributeName <- ([A-Z] / [a-z] / [0-9] / "_") ([A-Z] / [a-z] / [0-9] / "-")* {
    return string(c.text), nil
}

DocumentAttributeValue <- (!NEWLINE .)* {
    return string(c.text), nil
}
// ------------------------------------------
// Table of Contents
// ------------------------------------------
TableOfContentsMacro <- "toc::[]" NEWLINE

// ------------------------------------------
// Element Attributes
// ------------------------------------------
ElementAttribute <- attr:(ElementID / ElementTitle / ElementRole / AdmonitionMarkerAttribute / HorizontalLayout / AttributeGroup) WS* EOL {
    return attr, nil // avoid returning something like `[]interface{}{attr, EOL}`
}

// identify all attributes that masquerade a block element into something else.
MasqueradeAttribute <- attr:(QuoteAttributes / VerseAttributes) WS* EOL {
    return attr, nil // avoid returning something like `[]interface{}{attr, EOL}`
}

ElementID <- id:(InlineElementID) {
    return id, nil
} / "[#" id:(ID) "]" {
    return types.NewElementID(id.(string))
}

InlineElementID <- "[[" id:(ID) "]]" {
    return types.NewElementID(id.(string))
}

// a title attached to an element, such as a BlockImage
// a title starts with a single "." followed by the value, without space in-between
ElementTitle <- "." !"." !WS title:(ElementTitleContent) {
    return types.NewElementTitle(title.(string))
}

ElementTitleContent <- (!NEWLINE .)+ {
    return string(c.text), nil
}

// a role attached to an element, such as a BlockImage
// a role starts is wrapped in "[. ]" 
ElementRole <- "[." !WS role:(ElementRoleContent) "]" {
    return types.NewElementRole(role.(string))
}

ElementRoleContent <- (!NEWLINE !"]" .)+ {
    return string(c.text), nil
}

// expression for the whole admonition marker, but only retains the actual kind
AdmonitionMarkerAttribute <- "[" k:(AdmonitionKind) "]" {
    return types.NewAdmonitionAttribute(k.(types.AdmonitionKind))
}

// one or more attributes. eg: [foo, key1=value1, key2 = value2 , ]
AttributeGroup <- "[" !WS attributes:(GenericAttribute)*  "]" {
    return types.NewAttributeGroup(attributes.([]interface{}))
}

GenericAttribute <- key:(AttributeKey) "=" value:(AttributeValue) ","? WS* { // value is set
    return types.NewGenericAttribute(key.(string), value)
} / key:(AttributeKey) ","? WS* { // value is not set
    return types.NewGenericAttribute(key.(string), nil)
}

AttributeKey <- !VerseKind key:(!"=" !"," !"]" .)+  {
    return string(c.text), nil
}

AttributeValue <- value:(!"=" !"," !"]" .)* {
    return string(c.text), nil
}

HorizontalLayout <- "[horizontal]" {
    return types.ElementAttributes{"layout": "horizontal"}, nil
}

QuoteAttributes <- "[" kind:(QuoteKind) WS* "," author:(QuoteAuthor) "," title:(QuoteTitle) "]" {
        return types.NewQuoteAttributes(kind.(string), author.(string), title.(string))
    } / 
    // verse without specific title
    "[" kind:(QuoteKind) WS* "," author:(QuoteAuthor) "]" {
        return types.NewQuoteAttributes(kind.(string), author.(string), "")
    } /
    // verse without specific author
    "[" kind:(QuoteKind) WS* "]" {
        return types.NewQuoteAttributes(kind.(string), "","")
    }

QuoteKind <- !VerseKind (!EOL !WS !"," !"]" !"#" !"=" !AdmonitionKind .)* { // make sure quote attribute does not collide with other generic or specific attributes (ID, Admonition, etc)
    return string(c.text), nil
}

VerseAttributes <- "[" kind:(VerseKind) WS* "," author:(QuoteAuthor) "," title:(QuoteTitle) "]" {
        return types.NewQuoteAttributes(kind.(string), author.(string), title.(string))
    } / 
    // verse without specific title
    "[" kind:(VerseKind) WS* "," author:(QuoteAuthor) "]" {
        return types.NewQuoteAttributes(kind.(string), author.(string), "")
    } /
    // verse without specific author
    "[" kind:(VerseKind) WS* "]" {
        return types.NewQuoteAttributes(kind.(string), "","")
    }

VerseKind <- "verse" {
    return string(c.text), nil
}

QuoteAuthor <- (!EOL !"," !"]" .)* {
    return string(c.text), nil
}

QuoteTitle <- (!EOL !"," !"]" .)* {
    return string(c.text), nil
}

// ------------------------------------------
// Sections
// ------------------------------------------
Section <- !EOF // when reaching EOF, do not try to parse a new section again
    section:(Section0 / Section1 / Section2 / Section3 / Section4 / Section5) {
        return section, nil
    }

SectionTitlePrefix <- ("=")+ WS*

Section0 <- !EOF // when reaching EOF, do not try to parse a new section again
    section:(header:(Section0Title) elements:(Section0Block*) {
        return types.NewSection(0, header.(types.SectionTitle), elements.([]interface{}))
    }) {
        return section, nil
    }

Section0TitlePrefix <- "=" WS+

Section0Title <- attributes:(ElementAttribute)* Section0TitlePrefix content:(TitleElements) WS* id:(InlineElementID)? WS* EOL { 
    return types.NewSectionTitle(content.(types.InlineElements), append(attributes.([]interface{}), id))
}

Section0Block <- !Section0 content:(Section1 / Section2 / Section3 / Section4 / Section5 / DocumentBlock) {
    return content, nil
}

Section1 <- !EOF // when reaching EOF, do not try to parse a new section again
    section:(header:(Section1Title) elements:(Section1Block*) {
        return types.NewSection(1, header.(types.SectionTitle), elements.([]interface{}))
    }) {
    return section, nil
}

Section1TitlePrefix <- "==" WS+

Section1Title <- attributes:(ElementAttribute)* Section1TitlePrefix content:(TitleElements) WS* id:(InlineElementID)? WS* EOL { 
    return types.NewSectionTitle(content.(types.InlineElements), append(attributes.([]interface{}), id))
}

Section1Block <- !Section1Title content:(Section2 / Section3 / Section4 / Section5 / DocumentBlock) {
    return content, nil
}

Section2 <- !EOF // when reaching EOF, do not try to parse a new section again
    section:(header:(Section2Title) elements:(Section2Block?) {
        return types.NewSection(2, header.(types.SectionTitle), elements.([]interface{}))
    }) {
        return section, nil
    }

Section2TitlePrefix <- "===" WS+ 

Section2Title <- attributes:(ElementAttribute)* Section2TitlePrefix content:(TitleElements) WS* id:(InlineElementID)? WS* EOL {
    return types.NewSectionTitle(content.(types.InlineElements), append(attributes.([]interface{}), id))
}

Section2Block <- !Section1Title !Section2Title content:(Section3 / Section4 / Section5 / DocumentBlock)* {
    return content, nil
}

Section3 <- !EOF // when reaching EOF, do not try to parse a new section again
    section:(header:(Section3Title) elements:(Section3Block?) {
        return types.NewSection(3, header.(types.SectionTitle), elements.([]interface{}))
    }) {
        return section, nil
    }

Section3TitlePrefix <- "====" WS+ 

Section3Title <- attributes:(ElementAttribute)* Section3TitlePrefix content:(TitleElements) WS* id:(InlineElementID)? EOL {
    return types.NewSectionTitle(content.(types.InlineElements), append(attributes.([]interface{}), id))
}

Section3Block <- !Section1Title !Section2Title !Section3Title  content:(Section4 / Section5 / DocumentBlock)* {
    return content, nil
}

Section4 <- !EOF // when reaching EOF, do not try to parse a new section again
    section:(header:(Section4Title) elements:(Section4Block?) {
        return types.NewSection(4, header.(types.SectionTitle), elements.([]interface{}))
    }) {
        return section, nil
    }

Section4TitlePrefix <- "=====" WS+ 

Section4Title <- attributes:(ElementAttribute)* Section4TitlePrefix content:(TitleElements) WS* id:(InlineElementID)? EOL {
    return types.NewSectionTitle(content.(types.InlineElements), append(attributes.([]interface{}), id))
}

Section4Block <- !Section1Title !Section2Title !Section3Title !Section4Title  content:(Section5 / DocumentBlock)* {
    return content, nil
}

Section5 <- !EOF // when reaching EOF, do not try to parse a new section again
    section:(header:(Section5Title) elements:(Section5Block?) {
        return types.NewSection(5, header.(types.SectionTitle), elements.([]interface{}))
    }) {
        return section, nil
    }

Section5TitlePrefix <- "======" WS+ 

Section5Title <- attributes:(ElementAttribute)* Section5TitlePrefix content:(TitleElements) WS* id:(InlineElementID)? EOL {
    return types.NewSectionTitle(content.(types.InlineElements), append(attributes.([]interface{}), id))
}

Section5Block <- !Section1Title !Section2Title !Section3Title !Section4Title !Section5Title content:(DocumentBlock)* {
    return content, nil
}

TitleElements <- elements:(!NEWLINE WS* !InlineElementID TitleElement WS*)+ { // absorbs heading and trailing spaces
    return types.NewInlineElements(elements.([]interface{}))
} 

TitleElement <- element:(CrossReference / Passthrough / InlineImage / QuotedText / Link / DocumentAttributeSubstitution / Word / Parenthesis) {
    return element, nil
}


// ------------------------------------------
// Lists
// ------------------------------------------
List <- attributes:(ElementAttribute)* 
    // list items can be followed by an optional, single blank line
    elements:ListItems {
    return types.NewList(elements.([]interface{}), attributes.([]interface{}))
}

ListItems <- (OrderedListItem / UnorderedListItem / LabeledListItem)+

ListParagraph <- lines:(ListParagraphLine)+ {
    return types.NewParagraph(lines.([]interface{}), nil)
} 

ListParagraphLine <- 
    !(OrderedListItemPrefix) 
    !(UnorderedListItemPrefix) 
    !(LabeledListItemTerm LabeledListItemSeparator) 
    !(ListItemContinuation) 
    !(ElementAttribute)
    !(BlockDelimiter)
    line:(InlineElements) {
        return line, nil
}

ListItemContinuation <- "+" WS* EOL {
    return types.NewListItemContinuation()
}

ContinuedDocumentBlock <- ListItemContinuation element:DocumentBlock {
    return element, nil
}

// ------------------------------------------
// Ordered List Items
// ------------------------------------------
OrderedListItem <- attributes:(ElementAttribute)* prefix:(OrderedListItemPrefix) content:(OrderedListItemContent) BlankLine* {
    return types.NewOrderedListItem(prefix.(types.OrderedListItemPrefix), content.([]interface{}), attributes.([]interface{}))
}

OrderedListItemPrefix <- WS* prefix:(
    // implicit numbering: '.' to '.....'
    "....." { // numbering style: "....."
        return types.NewOrderedListItemPrefix(types.UpperRoman, 5)
    } / "...." { // numbering style: "...."
        return types.NewOrderedListItemPrefix(types.UpperAlpha, 4)
    } / "..." { // numbering style: "..."
        return types.NewOrderedListItemPrefix(types.LowerRoman, 3)
    } / ".." { // numbering style: ".."
        return types.NewOrderedListItemPrefix(types.LowerAlpha, 2)
    } / "." { // numbering style: "."
        return types.NewOrderedListItemPrefix(types.Arabic, 1)
    // explicit numbering
    } / ([0-9])+ "." {  // numbering style: "1."
        return types.NewOrderedListItemPrefix(types.Arabic, 1)
    } / ([a-z])+ "." { // numbering style: "a."
        return types.NewOrderedListItemPrefix(types.LowerAlpha, 1)
    } / ([A-Z])+ "." { // numbering style: "A."
        return types.NewOrderedListItemPrefix(types.UpperAlpha, 1)
    } / ([a-z])+ ")" { // numbering style: "i)"
        return types.NewOrderedListItemPrefix(types.LowerRoman, 1)
    } / ([A-Z])+ ")" { // numbering style: "I)"
        return types.NewOrderedListItemPrefix(types.UpperRoman, 1)
    }) WS+ {
        return prefix, nil
    }

OrderedListItemContent <- elements:(ListParagraph+ ContinuedDocumentBlock*) { // Another list or a literal paragraph immediately following a list item will be implicitly included in the list item
    return types.NewListItemContent(elements.([]interface{}))
} 

// ------------------------------------------
// Unordered List Items
// ------------------------------------------
UnorderedListItem <- prefix:(UnorderedListItemPrefix) content:(UnorderedListItemContent) BlankLine* {
    return types.NewUnorderedListItem(prefix.(types.UnorderedListItemPrefix), content.([]interface{}))
}

UnorderedListItemPrefix <- 
    WS* prefix:(
        "*****" { // ignore whitespaces, only return the relevant "*"/"-" marker
           return types.NewUnorderedListItemPrefix(types.FiveAsterisks, 5)
        } 
        / "****" { // ignore whitespaces, only return the relevant "*"/"-" marker
            return types.NewUnorderedListItemPrefix(types.FourAsterisks, 4)
        } 
        / "***" { // ignore whitespaces, only return the relevant "*"/"-" marker
            return types.NewUnorderedListItemPrefix(types.ThreeAsterisks, 3)
        } 
        / "**" { // ignore whitespaces, only return the relevant "*"/"-" marker
            return types.NewUnorderedListItemPrefix(types.TwoAsterisks, 2)
        } 
        / "*" { // ignore whitespaces, only return the relevant "*"/"-" marker
            return types.NewUnorderedListItemPrefix(types.OneAsterisk, 1)
        } 
        / "-" { // ignore whitespaces, only return the relevant "*"/"-" marker
            return types.NewUnorderedListItemPrefix(types.Dash, 1)
        }) WS+ {
            return prefix, nil
        } 

UnorderedListItemContent <- elements:(ListParagraph+ ContinuedDocumentBlock*) { // Another list or a literal paragraph immediately following a list item will be implicitly included in the list item
    return types.NewListItemContent(elements.([]interface{}))
} 

// ------------------------------------------
// Labeled List Items
// ------------------------------------------
LabeledListItem <- 
    term:(LabeledListItemTerm) LabeledListItemSeparator description:(LabeledListItemDescription) {
        return types.NewLabeledListItem(term.(string), description.([]interface{}))
    } /  term:(LabeledListItemTerm) "::" WS* EOL { // here, WS is optional since there is no description afterwards
        return types.NewLabeledListItem(term.(string), nil)
    }

LabeledListItemTerm <- (!NEWLINE !"::" .)*  {
    return string(c.text), nil
}

// term separator: ('::') and at least one space or endline
LabeledListItemSeparator <-  "::" (WS / NEWLINE)+

LabeledListItemDescription <- elements:(ListParagraph / ContinuedDocumentBlock)* { // TODO: replace with (ListParagraph+ ContinuedDocumentBlock*) and use a single rule for all item contents ?
    return types.NewListItemContent(elements.([]interface{}))
}

// ------------------------------------------
// Admonitions
// ------------------------------------------
AdmonitionKind <- "TIP" {
    return types.Tip, nil
} / "NOTE" {
    return types.Note, nil
} / "IMPORTANT" {
    return types.Important, nil
} / "WARNING" {
    return types.Warning, nil
} / "CAUTION" {
    return types.Caution, nil
}

// ------------------------------------------
// Paragraphs
// ------------------------------------------
// a paragraph is a group of line ending with a blank line (or end of file)
// a paragraph cannot start with the `section` sequence (`= `, `== `, etc.)
Paragraph <- 
    // admonition paragraph 
    attributes:(ParagraphAttribute)* !("="+ WS+ !NEWLINE) t:(AdmonitionKind) ": " lines:(InlineElements)+ { 
        return types.NewAdmonitionParagraph(lines.([]interface{}), t.(types.AdmonitionKind), attributes.([]interface{}))
    } / 
    // other kind of paragraph (verse, regular, etc.)
    attributes:(ParagraphAttribute)* !("="+ WS+ !NEWLINE) lines:(InlineElements)+ { 
        return types.NewParagraph(lines.([]interface{}), attributes.([]interface{}))
    } 

ParagraphAttribute <- MasqueradeAttribute / ElementAttribute // support masquerade attributes 

InlineElements <- 
    comment:(SingleLineComment) {
        return types.NewInlineElements([]interface{}{comment})
    } / !EOF !BlockDelimiter elements:(!EOL WS* !InlineElementID InlineElement WS*)+ EOL { // absorbs heading and trailing spaces
        return types.NewInlineElements(elements.([]interface{}))
    } 

InlineElement <- element:(QuotedText / CrossReference / Passthrough / InlineImage / Link / DocumentAttributeSubstitution / Word / Parenthesis) {
    return element, nil
}

// special case for re-parsing a group of elements after a document substitution:
// we should treat substitution that did not happen (eg: missing attribute) as regulart
// strings
InlineElementsWithoutSubtitution <- !EOF !BlockDelimiter elements:(!EOL WS* !InlineElementID InlineElementWithoutSubtitution WS*)+ EOL { // absorbs heading and trailing spaces
    return types.NewInlineElements(elements.([]interface{}))
} 

InlineElementWithoutSubtitution <- element:(QuotedText / CrossReference / Passthrough / InlineImage / Link / Word / Parenthesis) {
    return element, nil
}

// ----------------------------------------------------------------------------
// Quoted Texts (bold, italic and monospace) including substitution prevention
// ----------------------------------------------------------------------------
QuotedText <- BoldText / ItalicText / MonospaceText /
            EscapedBoldText / EscapedItalicText / EscapedMonospaceText

BoldText <- 
    !`\\` "**" content:(QuotedTextContent) "**" { // double punctuation must be evaluated first
        return types.NewQuotedText(types.Bold, content.([]interface{}))
    } / !`\\` "**" content:(QuotedTextContent) "*" { // unbalanced `**` vs `*` punctuation
        result := append([]interface{}{"*"}, content.([]interface{}))
        return types.NewQuotedText(types.Bold, result)
    } / !`\` "*" content:(QuotedTextContent) "*" !Alphanum { // single punctuation cannot be followed by a character (needs '**' to emphazise a portion of a word)
        return types.NewQuotedText(types.Bold, content.([]interface{}))
    } 

EscapedBoldText <- 
    backslashes:(TwoOrMoreBackslashes) "**" content:(QuotedTextContent) "**" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "**", content.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "**" content:(QuotedTextContent) "*" { // unbalanced `**` vs `*` punctuation
        result := append([]interface{}{"*"}, content.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "*", result)
    } / backslashes:(OneOrMoreBackslashes) "*" content:(QuotedTextContent) "*" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "*", content.([]interface{}))
    } 

OneOrMoreBackslashes <- `\` `\`* {
    return string(c.text), nil
}

TwoOrMoreBackslashes <- `\\` `\`* {
    return string(c.text), nil
}

ItalicText <- 
    !`\\` "__" content:(QuotedTextContent) "__" {
        return types.NewQuotedText(types.Italic, content.([]interface{}))
    } / !`\\` "__" content:(QuotedTextContent) "_" { // unbalanced `__` vs `_` punctuation
        result := append([]interface{}{"_"}, content.([]interface{}))
        return types.NewQuotedText(types.Italic, result)
    } / !`\` "_" content:(QuotedTextContent) "_" !Alphanum { // single punctuation cannot be followed by a character (needs '**' to emphazise a portion of a word)
        return types.NewQuotedText(types.Italic, content.([]interface{}))
    }

EscapedItalicText <- 
    backslashes:(TwoOrMoreBackslashes) "__" content:(QuotedTextContent) "__" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "__", content.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "__" content:(QuotedTextContent) "_" { // unbalanced `__` vs `_` punctuation
        result := append([]interface{}{"_"}, content.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "_", result)
    } / backslashes:(OneOrMoreBackslashes) "_" content:(QuotedTextContent) "_" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "_", content.([]interface{}))
    } 

MonospaceText <- 
    !`\\` "``" content:(QuotedTextContent) "``" { // double punctuation must be evaluated first
        return types.NewQuotedText(types.Monospace, content.([]interface{}))
    } / !`\\` "``" content:(QuotedTextContent) "`" { // unbalanced "``" vs "`" punctuation
        result := append([]interface{}{"`"}, content.([]interface{}))
        return types.NewQuotedText(types.Monospace, result)
    } / !`\` "`" content:(QuotedTextContent) "`" !Alphanum { // single punctuation cannot be followed by a character (needs '**' to emphazise a portion of a word)
        return types.NewQuotedText(types.Monospace, content.([]interface{}))
    }

EscapedMonospaceText <- 
    backslashes:(TwoOrMoreBackslashes) "``" content:(QuotedTextContent) "``" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "``", content.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "``" content:(QuotedTextContent) "`" { // unbalanced "``" vs "`" punctuation
        result := append([]interface{}{"`"}, content.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "`", result)
    } / backslashes:(OneOrMoreBackslashes) "`" content:(QuotedTextContent) "`" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "`", content.([]interface{}))
    } 

QuotedTextContent <- QuotedTextContentElement (WS+ QuotedTextContentElement)*

QuotedTextContentElement <- QuotedText / QuotedTextWord / WordWithQuotePunctuation // word with quote punctuation is only accepted if nothing matched before, so we have a chance to stop

QuotedTextWord <- (!NEWLINE !WS !"*" !"_" !"`" .)+ // cannot have "*", "_" or "`" within

WordWithQuotePunctuation <- (!NEWLINE !WS  .)+ { // can have "*", "_" or "`" within, maybe because the user inserted another quote, or made an error (extra or missing space, for example)
    return c.text, nil
}

// make sure unbalanced punctuation for quoted text is treated accordingly
UnbalancedQuotePunctuation <- "*" / "_" / "`"

// ------------------------------------------
// Passthrough
// ------------------------------------------
Passthrough <- TriplePlusPassthrough / SinglePlusPassthrough / PassthroughMacro

SinglePlusPassthrough <- "+" content:(!NEWLINE !"+" .)* "+" {
    return types.NewPassthrough(types.SinglePlusPassthrough, content.([]interface{}))
}

TriplePlusPassthrough <- "+++" content:(!"+++" .)* "+++" {
    return types.NewPassthrough(types.TriplePlusPassthrough, content.([]interface{}))
}

PassthroughMacro <- "pass:[" content:(PassthroughMacroCharacter)* "]" {
    return types.NewPassthrough(types.PassthroughMacro, content.([]interface{}))
} / "pass:q[" content:(QuotedText / PassthroughMacroCharacter)* "]" {
    return types.NewPassthrough(types.PassthroughMacro, content.([]interface{}))
}

PassthroughMacroCharacter <- (!"]" .)

// ------------------------------------------
// Cross References
// ------------------------------------------
CrossReference <- "<<" id:(ID) WS* "," label:(CrossReferenceLabel) ">>" {
    return types.NewCrossReference(id.(string), label.(string))
} / "<<" id:(ID) ">>" {
    return types.NewCrossReference(id.(string), nil)
}

CrossReferenceLabel <- (!">>" .)+ {
    return string(c.text), nil
}

// ------------------------------------------
// Links
// ------------------------------------------
Link <- link:(RelativeLink / ExternalLink) {
    return link, nil
}

ExternalLink <- url:(ExternalLinkURL) attributes:(LinkAttributes) {
    return types.NewLink(url.(string), attributes.(types.ElementAttributes))
} / url:(ExternalLinkURL) {
    return types.NewLink(url.(string), nil)
}

ExternalLinkURL <- URL_SCHEME URL {
    return string(c.text), nil
}

// url preceeding with `link:` MUST be followed by square brackets
RelativeLink <- "link:" url:(RelativeLinkURL) attributes:(LinkAttributes) {
    return types.NewLink(url.(string), attributes.(types.ElementAttributes))
}

RelativeLinkURL <- URL_SCHEME? URL {
    return string(c.text), nil
}

LinkAttributes <- "[" text:(LinkTextAttribute)
        otherAttrs:(GenericAttribute)* "]" {
    return types.NewLinkAttributes(text, otherAttrs.([]interface{}))
} / "[" otherAttrs:(GenericAttribute)* "]" {
    return types.NewLinkAttributes(nil, otherAttrs.([]interface{}))
}

LinkTextAttribute <- (!"," !"]" .)+ {
    return string(c.text), nil
}

// ------------------------------------------
// Images
// ------------------------------------------
BlockImage <- attributes:(ElementAttribute)* "image::" path:(URL) inlineAttributes:(ImageAttributes) WS* EOL {
    return types.NewBlockImage(path.(string), attributes.([]interface{}), inlineAttributes.(types.ElementAttributes))
}

InlineImage <- "image:" !":" path:(URL) attributes:(ImageAttributes) {
    return types.NewInlineImage(path.(string), attributes.(types.ElementAttributes))
}

// the 'ImageAttributes' rule could be simpler, but the grammar optimizer fails to produce a valid code :(
ImageAttributes <- "[" alt:(ImageAttribute) ","
        width:(ImageAttribute)  ","
        height:(ImageAttribute) ","?
        otherAttrs:(GenericAttribute)* "]" {
            return types.NewImageAttributes(alt, width, height, otherAttrs.([]interface{}))
    } / "[" alt:(ImageAttribute) ","
        width:(ImageAttribute) ","?
        otherAttrs:(GenericAttribute)* "]" {
            return types.NewImageAttributes(alt, width, nil, otherAttrs.([]interface{}))
    } / "[" alt:(ImageAttribute) ","?
        otherAttrs:(GenericAttribute)* "]" {
            return types.NewImageAttributes(alt, nil, nil, otherAttrs.([]interface{}))
    } / "[" otherAttrs:(GenericAttribute)* "]" {
            return types.NewImageAttributes(nil, nil, nil, otherAttrs.([]interface{}))
    } 


ImageAttribute <- (!"," !"=" !"]" .)+ { // attribute is followed by "," or "]" (but do not consume the latter)
    return string(c.text), nil
}

// ------------------------------------------------------------------------------------
// Delimited Blocks (http://asciidoctor.org/docs/user-manual/#built-in-blocks-summary)
// ------------------------------------------------------------------------------------
DelimitedBlock <- FencedBlock / ListingBlock / ExampleBlock 
                / CommentBlock / VerseBlock / QuoteBlock 
                / SidebarBlock

BlockDelimiter <- LiteralBlockDelimiter / FencedBlockDelimiter / ListingBlockDelimiter 
                / ExampleBlockDelimiter / CommentBlockDelimiter / QuoteBlockDelimiter
                / SidebarBlockDelimiter


// -------------------------------------------------------------------------------------
// Fenced Blocks
// -------------------------------------------------------------------------------------
FencedBlockDelimiter <- "```"

FencedBlock <- attributes:(ElementAttribute)* FencedBlockDelimiter WS* NEWLINE content:(FencedBlockContent)* ((FencedBlockDelimiter WS* EOL) / EOF) {
    return types.NewDelimitedBlock(types.Fenced, content.([]interface{}), attributes.([]interface{}), types.None)
}

FencedBlockContent <- List / BlockParagraph / BlankLine

// -------------------------------------------------------------------------------------
// Listing blocks
// -------------------------------------------------------------------------------------
ListingBlockDelimiter <- "----"

// listing block: verbatim content
ListingBlock <- attributes:(ElementAttribute)* ListingBlockDelimiter WS* NEWLINE content:(ListingBlockContent)* ((ListingBlockDelimiter WS* EOL) / EOF) {
    return types.NewDelimitedBlock(types.Listing, content.([]interface{}), attributes.([]interface{}), types.None)
}

ListingBlockContent <- lines:(ListingBlockLine)+ {
    return types.NewParagraph(lines.([]interface{}), nil)
}

ListingBlockLine <- !ListingBlockDelimiter !EOF line:(ListingBlockLineContent) EOL {
    return line.(types.InlineElements), nil
}

ListingBlockLineContent <- (!ListingBlockDelimiter !EOL .)* { // skip EOL in line content, and stop when quote block delimiter is encountered
    return types.NewInlineElements(string(c.text))
}

// -------------------------------------------------------------------------------------
// Example blocks
// -------------------------------------------------------------------------------------
ExampleBlockDelimiter <- "===="

ExampleBlock <- attributes:(ElementAttribute)* ExampleBlockDelimiter WS* NEWLINE content:(List / BlockParagraph / BlankLine)*  ((ExampleBlockDelimiter WS* EOL) / EOF) {
    return types.NewDelimitedBlock(types.Example, content.([]interface{}), attributes.([]interface{}), types.None)
}

// blocks content
BlockParagraph <-  lines:(BlockParagraphLine)+ {
    return types.NewParagraph(lines.([]interface{}), nil)
} 

BlockParagraphLine <- !(OrderedListItemPrefix) 
        !(UnorderedListItemPrefix) 
        !(LabeledListItemTerm LabeledListItemSeparator) 
        !(ListItemContinuation) 
        !(BlockDelimiter) 
        line:(InlineElements) {
    return line, nil
}

// -------------------------------------------------------------------------------------
// Quote blocks
// -------------------------------------------------------------------------------------
QuoteBlockDelimiter <- "____" // same for verse blocks

QuoteBlock <- attributes:(QuoteBlockAttributes)+ QuoteBlockDelimiter WS* NEWLINE content:(QuoteBlockContent)*  ((QuoteBlockDelimiter WS* EOL) / EOF) {
    return types.NewDelimitedBlock(types.Quote, 
        content.([]interface{}), 
        attributes.([]interface{}), 
        types.None)
}

QuoteBlockAttributes <- 
    attribute:(QuoteAttributes) WS* EOL {
        return attribute, nil 
    } 
    // / attribute:(ElementAttribute) {
    //     return attribute, nil 
    // }

QuoteBlockContent <- 
    !QuoteBlockDelimiter !EOF element:(DocumentBlock) {
        return element, nil
    } 

// -------------------------------------------------------------------------------------
// Verse blocks
// -------------------------------------------------------------------------------------
// VerseBlockDelimiter: see QuoteBlockDelimiter

VerseBlock <- attributes:(VerseBlockAttributes)+ QuoteBlockDelimiter WS* NEWLINE content:(VerseBlockContent)* ((QuoteBlockDelimiter WS* EOL) / EOF) {
    return types.NewDelimitedBlock(types.Verse, 
        content.([]interface{}), 
        attributes.([]interface{}), 
        types.None)
}

VerseBlockAttributes <- 
    attribute:(VerseAttributes) WS* EOL {
        return attribute, nil 
    } 

VerseBlockContent <- lines:(VerseBlockLine)+ {
    return types.NewParagraph(lines.([]interface{}), nil)
}

VerseBlockLine <- !QuoteBlockDelimiter !EOF line:(VerseBlockLineContent) EOL {
    return line.(types.InlineElements), nil
}

VerseBlockLineContent <- elements:(!QuoteBlockDelimiter !EOL WS* InlineElement WS*)* { // skip EOL in line content, and stop when quote block delimiter is encountered
    return types.NewInlineElements(elements.([]interface{}))
}

// -------------------------------------------------------------------------------------
// Sidebars
// -------------------------------------------------------------------------------------
SidebarBlockDelimiter <- "****"

SidebarBlock <- attributes:(ElementAttribute)* SidebarBlockDelimiter WS* NEWLINE content:(SidebarBlockContent)*  ((SidebarBlockDelimiter WS* EOL) / EOF) {
    return types.NewDelimitedBlock(types.Sidebar, content.([]interface{}), attributes.([]interface{}), types.None)
}

SidebarBlockContent <- List / BlockParagraph / BlankLine / NonSidebarBlock

NonSidebarBlock <- !SidebarBlock content:(DelimitedBlock) {
    return content, nil
}

// -------------------------------------------------------------------------------------
// Tables
// -------------------------------------------------------------------------------------
Table <- attributes:(ElementAttribute)* 
        TableDelimiter WS* NEWLINE
        header:(TableLineHeader)?
        lines:(TableLine)*
        ((TableDelimiter WS* EOL) / EOF) { // end delimiter or end of file
            return types.NewTable(header, lines.([]interface{}), attributes.([]interface{}))
        }

TableCellSeparator <- "|" WS*

TableDelimiter <- "|==="
        
// table line header is a line followed by a blankline
TableLineHeader <- !TableDelimiter cells:(TableCell)+ EOL BlankLine {
    return types.NewTableLine(cells.([]interface{}))
}

TableLine <- !TableDelimiter cells:(TableCell)+ EOL BlankLine* {
    return types.NewTableLine(cells.([]interface{}))
}

TableCell <- TableCellSeparator elements:(!TableCellSeparator !EOL WS* InlineElement WS*)+ {
    return types.NewInlineElements(elements)
}


// -------------------------------------------------------------------------------------
// Comments
// -------------------------------------------------------------------------------------
CommentBlockDelimiter <- "////"

CommentBlock <- attributes:(ElementAttribute)* CommentBlockDelimiter WS* NEWLINE content:(CommentBlockLine)*  ((CommentBlockDelimiter WS* EOL) / EOF) {
    return types.NewDelimitedBlock(types.Comment, content.([]interface{}), attributes.([]interface{}), types.Verbatim)
}

CommentBlockLine <- (!CommentBlockDelimiter !EOL .)* EOL {
    return string(c.text), nil
}

SingleLineComment <- !CommentBlockDelimiter "//" content:(SingleLineCommentContent) EOL {
    return types.NewSingleLineComment(content.(string))
}

SingleLineCommentContent <- (!EOL .)* {
    return string(c.text), nil
}


// -------------------------------------------------------------------------------------
// Literal Blocks (see http://asciidoctor.org/docs/user-manual/#literal-text-and-blocks)
// -------------------------------------------------------------------------------------
LiteralBlock <- ParagraphWithSpaces / ParagraphWithLiteralBlockDelimiter / ParagraphWithLiteralAttribute

// paragraph indented with one or more spaces on the first line
ParagraphWithSpaces <- content:(ParagraphWithSpacesContent) EOL {
    return types.NewLiteralBlock(content.(string))
}

// no NEWLINE allowed between the first spaces and the content of the block
ParagraphWithSpacesContent <- WS+ !NEWLINE (!(NEWLINE BlankLine) .)+ { 
    return string(c.text), nil
}

// paragraph with the literal block delimiter (`....`)
ParagraphWithLiteralBlockDelimiter <- LiteralBlockDelimiter WS* NEWLINE content:(ParagraphWithLiteralBlockContent) ((LiteralBlockDelimiter WS* EOL) / EOF) {
    return types.NewLiteralBlock(content.(string))
}

ParagraphWithLiteralBlockContent <- (!LiteralBlockDelimiter .)* {
    return string(c.text), nil
}

LiteralBlockDelimiter <- "...."

// paragraph with the literal attribute (`[literal]`)
ParagraphWithLiteralAttribute <- "[literal]" WS* NEWLINE content:(ParagraphWithLiteralAttributeContent) EOL {
    return types.NewLiteralBlock(content.(string))
}

// no NEWLINE allowed between the first spaces and the content of the block
ParagraphWithLiteralAttributeContent <- (!(NEWLINE BlankLine) .)+ { 
    return string(c.text), nil
}

// ------------------------------------------
// BlankLine
// ------------------------------------------
BlankLine <- !EOF WS* EOL {
    return types.NewBlankLine()
}

// ------------------------------------------
// Base Types
// ------------------------------------------
Alphanum <- [a-zA-Z0-9]

Parenthesis <- "(" / ")" / "[" / "]"

Word <- (!NEWLINE !WS !Parenthesis .)+ {
    return string(c.text), nil
}

URL <- (!NEWLINE !WS !"[" !"]" .)+ {
    return string(c.text), nil
}

ID <- (!NEWLINE !WS !"[" !"]" !"<<" !">>" !"," .)+ {
    return string(c.text), nil
}

URL_TEXT <- (!NEWLINE !"[" !"]" .)+ {
    return string(c.text), nil
}

URL_SCHEME <- "http://" / "https://" / "ftp://" / "irc://" / "mailto:"

DIGIT <- [0-9] {
    return string(c.text), nil
}

WS <- " " / "\t" {
        return string(c.text), nil
}

NEWLINE <- "\r\n" / "\r" / "\n"

EOF <- !.

EOL <- NEWLINE / EOF