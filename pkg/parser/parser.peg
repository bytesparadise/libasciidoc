{
package parser 

import (
    "io"
    "fmt"
    "strconv"
    "strings"
    "unicode"
    "github.com/bytesparadise/libasciidoc/pkg/types"

    log "github.com/sirupsen/logrus"
    "github.com/davecgh/go-spew/spew"
)

}

// -------------------------------------------------------------------------------------
//
//
// Document Preprocessing
//
//
// -------------------------------------------------------------------------------------
DocumentRawLine <- 
    // TODO: include blanklines?
    element:(
        AttributeDeclaration
        / AttributeReset
        / FileInclusion
        / ConditionalInclusion
        / BlockDelimiter
        / RawSection
    ) EOF {
        // in case of parse error, we'll keep the rawline content as-is
        return element, nil
    }

// ----------------------------------------------------------
// Raw Sections
// ----------------------------------------------------------
RawSection <- 
    &{
        // should only be enabled when reading files to include, not the main (root) file
        return c.isSectionEnabled(), nil
    }
    &{  
        return !c.isWithinDelimitedBlock(), nil
    }
    level:(("=")+ {   
        // `=` is level 0, `==` is level 1, etc.
        return (len(c.text)-1), nil 
    })
    &{  
        // use a predicate to make sure that only `=` (level 0) to `======` (level 5) are allowed
        return level.(int) <= 5, nil 
    } 
    Spaces [^\r\n]+ EOF {
        return types.NewRawSection(level.(int), string(c.text)) // just retain the raw content
    }

// ----------------------------------------------------------
// Conditional inclusions
// ----------------------------------------------------------
ConditionalInclusion <- 
    Ifdef
    / Ifndef
    / Ifeval
    / EndIf 

Ifdef <- "ifdef::" name:(ConditionalVariableName) "[" attr:(ConditionalInclusionAttribute)? "]" Space* EOF {
        return types.NewIfdefCondition(name.(string), attr)
    }

Ifndef <- "ifndef::" name:(ConditionalVariableName) "[" attr:(ConditionalInclusionAttribute)? "]" Space* EOF {
        return types.NewIfndefCondition(name.(string), attr)
    }

ConditionalInclusionAttribute <- [^\r\n\]]+ {
        return string(c.text), nil
    }

Ifeval <- "ifeval::" 
    "[" 
    left:(IfevalExpressionMember) Space* 
    operand:(IfevalExpressionOperand) Space* 
    right:(IfevalExpressionMember) "]" 
    Space* EOF {
        return types.NewIfevalCondition(left, right, operand.(types.IfevalOperand))
    }



IfevalExpressionMember <- 
    ("\"" s:AttributeValueSubstitution "\"" { return s, nil })
    / ("'" s:AttributeValueSubstitution "'" { return s, nil })
    / (s:AttributeValueSubstitution { return s, nil })
    / ("\"" w:([\pL0-9,?!;_-]+ { return string(c.text), nil}) "\"" { return w, nil })
    / ("'" w:([\pL0-9,?!;_-]+ { return string(c.text), nil}) "'" { return w, nil })
    / Integer

IfevalExpressionOperand <-
    ("==" {
        return types.NewEqualOperand()
    })
    / ("!=" {
        return types.NewNotEqualOperand()
    })
    / ("<" {
        return types.NewLessThanOperand()
    })
    / ("<=" {
        return types.NewLessOrEqualOperand()
    })
    / (">" {
        return types.NewGreaterThanOperand()
    })
    / (">=" {
        return types.NewGreaterOrEqualOperand()
    })
    


IfevalExpressionValue <- 
    Number
    / InlineWord


EndIf <- "endif::" name:(ConditionalVariableName)? "[" attr:(ConditionalInclusionAttribute)? "]" Space* EOF {
         return types.NewEndOfCondition() // name and attributes are parsed but ignored
    }

ConditionalVariableName <- [^\r\n []+ { 
        return string(c.text), nil 
    }

// ----------------------------------------------------------
// File inclusions
// ----------------------------------------------------------
FileInclusion <- 
    incl:(
        "include::" 
        path:(FileLocation) 
        attributes:(InlineAttributes) { 
            return types.NewFileInclusion(path.(*types.Location), attributes.(types.Attributes), string(c.text))
        }
    ) 
    Space* EOL {
        return incl.(*types.FileInclusion), nil
    }

FileIncludeAttributes <- LongHandAttributes

// extra entrypoint
LineRanges <- value:(MultipleLineRanges 
    / MultiLineRange 
    / SingleLineRange 
    ) EOF { // must make sure that the whole content is parsed
        return value, nil
    }

MultipleLineRanges <- first:(MultiLineRange / SingleLineRange) 
    others:(
        ("," / ";") // at this point, we already got rid of the surrounding quotes, so we can accept both `,` and `;`
        other:(MultiLineRange / SingleLineRange) {
            return other, nil
    })+ {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

MultiLineRange <- start:(Integer) ".." end:(Integer) { // eg: lines=12..14
        return types.NewLineRange(start.(int), end.(int))
    } 

SingleLineRange <- singleline:(Integer) { // eg: lines=12
        return types.NewLineRange(singleline.(int), singleline.(int))
    }

// extra entrypoint
TagRanges <- value:(MultipleTagRanges) EOF { // must make sure that the whole content is parsed
        return value, nil
    }

MultipleTagRanges <- first:(TagRange)
    others:(
        ("," / ";") // at this point, we already got rid of the surrounding quotes, so we can accept both `,` and `;`
        other:(TagRange) {
            return other, nil
    })* {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

TagRange <- tag:(Alphanums / TagWildcard) {
        return types.NewTagRange(tag.(string), true)
    } / "!" tag:(Alphanums / TagWildcard) {
        return types.NewTagRange(tag.(string), false)
    }

TagWildcard <- stars:(("*")+ {
        return string(c.text), nil
    })
    &{  
        // use a predicate to make sure that only `*` and `**` are allowed
        return len(stars.(string)) <= 2, nil 
    } {
        return stars, nil
    }

IncludedFileLine <- content:(IncludedFileStartTag / IncludedFileEndTag / . {return string(c.text), nil})* EOL {
        return types.NewIncludedFileLine(content.([]interface{}))
    }

IncludedFileStartTag <- "tag::" tag:(Alphanums {return string(c.text), nil}) "[]" {
        return types.NewIncludedFileStartTag(tag.(string))
    }

IncludedFileEndTag <- "end::" tag:(Alphanums {return string(c.text), nil}) "[]" {
        return types.NewIncludedFileEndTag(tag.(string))
    }


// -------------------------------------------------------------------------------------
//
//
// Document Processing
//
//
// -------------------------------------------------------------------------------------

// -------------------------------------------------------------------------------------
// Document Fragments
// -------------------------------------------------------------------------------------
DocumentFragment <-
    !EOF
    attributes:(BlockAttributes)?
    element:(
        ImageBlock // must appear before ShortcutParagraph
        / UserMacroBlock // must appear before ShortcutParagraph
        / ShortcutParagraph
        / AttributeDeclaration
        / AttributeReset
        / DocumentHeader // must appear before Section
        / BlankLine // must appear after DocumentHeader // TODO: refactor `isDocumentHeaderAllowed` so this rule can be moved at first position
        / Section 
        / DelimitedBlock
        / ThematicBreak // must appear before ListElement :/
        / ListElements
        / Table
        / SingleLineComment
        / AdmonitionParagraph
        / LiteralParagraph
        / FrontMatter
        / Paragraph // must be the last one... 
    )? // allow attribute on empty/no element
    &{
        if attributes != nil && element == nil {
            // do not return an error, but do not accept such a kind of content (standalone attributes)
            return false, fmt.Errorf("standalone attribute")
        }
        return true, nil
    }
    {
        c.disableFrontMatterRule() // not allowed as soon as a single element is found
        c.disableDocumentHeaderRule(element) // not allowed anymore, based on element that was found
    
        if element, ok := element.(types.BlockWithAttributes); ok && attributes != nil {
            element.AddAttributes(attributes.(types.Attributes))
        }
        return element, nil
    }

RawLine <- 
    !EOF
    content:([^\r\n]* {
        return string(c.text), nil
    })
    EOL {
        return types.NewRawLine(content.(string))
    }


// reads all elements at once (for example, within a delimited block)
DelimitedBlockElements <- 
    elements:(
        ElementPlaceHolder // if there was a fileinclusion 
        / DocumentFragment
    )* 
    EOF {
        return elements, nil
    }
    
// -------------------------------------------------------------------------------------
// Document Raw Line (main rule)
// Identify the delimiters for raw blocks
// -------------------------------------------------------------------------------------

FrontMatterFragmentElement <-
    FrontMatterDelimiter
    / BlankLine
    // if no match, parser will return an error and content will be store in a RawLine

// -------------------------------------------------------------------------------------
// Admonitions
// -------------------------------------------------------------------------------------
AdmonitionKind <- "TIP" {
    return types.Tip, nil
} / "NOTE" {
    return types.Note, nil
} / "IMPORTANT" {
    return types.Important, nil
} / "WARNING" {
    return types.Warning, nil
} / "CAUTION" {
    return types.Caution, nil
}

// -------------------------------------------------------------------------------------
// Attribute Declarations and Resets
// -------------------------------------------------------------------------------------
AttributeDeclaration <- 
    ":" name:(AttributeName) ":" 
    value:(
        Spaces // value is optional, but there must be a space between `:` and value itself
        value:(AttributeDeclarationValue) {
            return value, nil
        }
    )? 
    EOL
    {
        return types.NewAttributeDeclaration(name.(string), types.Reduce(value, strings.TrimSpace), string(c.text))
    }

// AttributeName must be at least one character long, 
// must begin with a word character (A-Z, a-z, 0-9 or _) and 
// must only contain word Word and hyphens ("-").
AttributeName <- [\pL0-9_] ([\pL0-9-])* {
        return string(c.text), nil
    }

AttributeDeclarationValue <- 
    elements:(AttributeDeclarationValueElements) 
    otherElements:(
        "\\" Newline 
        Space*
        elements:(AttributeDeclarationValue) {
           return elements, nil
        }
    )*
    {
        if otherElements, ok := otherElements.([]interface{}); ok {
            return types.Reduce(append(elements.([]interface{}), otherElements...), strings.TrimSpace), nil
        }
        return types.Reduce(elements.([]interface{}), strings.TrimSpace), nil
    }

AttributeDeclarationValueElements <- 
    elements:(AttributeDeclarationValueElement)* {
        return elements.([]interface{}), nil
    }

AttributeDeclarationValueElement <- 
    !("\\"? Space* EOL)
    element:(
        ([^\r\n{ ]+ {
                return types.NewStringElement(string(c.text))
        })
        / Space
        / AttributeSubstitution
        / ("{" { // standalone '{'
            return types.NewStringElement(string(c.text))
        })
    ) { 
        return element, nil
    }

AttributeReset <- ":!" name:(AttributeName) ":" Space* EOL {
    return types.NewAttributeReset(name.(string), string(c.text))
} / ":" name:(AttributeName) "!:" Space* EOL {
    return types.NewAttributeReset(name.(string), string(c.text))
}

// -------------------------------------------------------------------------------------
// Block and Inline Attributes
// -------------------------------------------------------------------------------------
BlockAttributes <-
    attributes:(
        // shorthand syntax for anchors. Eg: `[[an_id]]`
        (anchor:(ShortHandAnchor) Space* EOL {
            return anchor, nil
        })
        // shorthand syntax for titles. Eg: `.a title`
        / (title:(ShortHandTitle) Space* EOL {
            return title, nil
        })
        // default syntax
        / (attributes:(LongHandAttributes) Space* EOL {
            return attributes, nil
        })
    )+ {
        // c.unsetCurrentSubstitution()
        return types.MergeAttributes(attributes.([]interface{})...)
    }  

InlineAttributes <-
    "["
    attributes:(
        (
            !"]" // quick escape
            attribute:(PositionalAttribute / NamedAttribute)
        ) {
            return attribute, nil
        }
    )*
    "]" {
        return types.NewAttributes(attributes.([]interface{})...)
    }

// shorthand syntax for anchors. Eg: `[[An ID]]`
ShortHandAnchor <-
   "[[" 
    id:(
        elements:(
            ([^=\r\n\uFFFD{\]]+ { // spaces, commas and dots are allowed in this syntax
                return types.NewStringElement(string(c.text))
            })
            / ElementPlaceHolder
            / AttributeSubstitution
            / ("{" { 
                return types.NewStringElement(string(c.text))
            }))+ {
                return types.Reduce(elements, strings.TrimSpace), nil
            }
        )
    "]]" {
        return types.NewIDAttribute(id)
    }

// shorthand syntax for titles. Eg: `.a title`
ShortHandTitle <- `.` title:(
    ![. ] // may not start with a dot or a space, to avoid confusion with list items or literal block delimiters
    elements:(
        ([^\r\n\uFFFD{]+ {
            return types.NewStringElement(string(c.text))
        })
        / ElementPlaceHolder
        / AttributeSubstitution
        / ("{" { 
            return types.NewStringElement(string(c.text))
        }))+ {
            return types.Reduce(elements, strings.TrimSpace), nil
        }
    ) {
        return types.NewTitleAttribute(title)
    }

// LongHandAttributes. Eg: `[positional1,positional2,...,named1,named2,...]
// positional attributes are optional, and `positional1` can be combined with options and roles ("extras")
LongHandAttributes <-
    "[" !"[" // prevent processing nested attributes at this point (parser will need to move forward by 1 char first)
    //!Space // no space allowed on the first character
    firstPositionalAttributes:(FirstPositionalAttributes)?
    otherAttributes:(PositionalAttribute / NamedAttribute)*
    "]" {
        attributes:=[]interface{}{}
        if firstPositionalAttributes != nil {
            attributes=append(attributes, firstPositionalAttributes.([]interface{})...)
        }
        if len(otherAttributes.([]interface{})) > 0 {
            attributes=append(attributes, otherAttributes.([]interface{})...)
        }
        return types.NewAttributes(attributes...)
    }

// First positional attributes may be an ID or a style, with extra roles and options.
// Or sometimes, it's just 1 or more roles or options...
FirstPositionalAttributes <- 
    main:(
        ShortHandAttribute
    )?
    extras:( 
        !"," !"]"
        extra:(
            ShortHandIDAttribute 
            / ShortHandOptionAttribute
            / ShortHandDotRoleAttribute) {
            return extra, nil
        }
    )* ("," Space*)? 
    &{
        // make sure there was a match
        return main != nil || len(extras.([]interface{})) > 0, nil
    }
    {
        attrs:=[]interface{}{}
        if main != nil {
            attrs = append(attrs, main)
        }
        if len(extras.([]interface{})) > 0 {
            attrs = append(attrs, extras.([]interface{})...)
        }
        return attrs, nil
    }

// an `id` must be prefixed with a `#` 
ShortHandIDAttribute <- "#" id:(ShortHandAttributeValue) {
        return types.NewIDAttribute(id)
    }

ShortHandAttribute <- value:(ShortHandAttributeValue) {
        return types.NewPositionalAttribute(value)
    }

// a `role` must be prefixed with a `.` 
ShortHandDotRoleAttribute <- "." role:(ShortHandAttributeValue) {
        return types.NewRoleAttribute(role)
    }

// an `option` must be prefixed with a `%` 
ShortHandOptionAttribute <- "%" option:(ShortHandAttributeValue) {
        return types.NewOptionAttribute(option)
    }

// Shorthand Attribute Value. 
ShortHandAttributeValue <- 
    SingleQuotedAttributeRawValue 
    / DoubleQuotedAttributeRawValue 
    / elements:(
        // unquoted shorthand value may include placeholders and substitutions but NOT comma, space, equal sign and dots
        // also, cannot be followed by an `=` sign
        ([^,=.%# \r\n\uFFFD{\]]+ {
            return types.NewStringElement(string(c.text))
        }) 
        / ElementPlaceHolder
        / AttributeSubstitution
        / ("{" { 
            return types.NewStringElement(string(c.text))
        })
    )+ &(!(Space* "=")) {
        return types.Reduce(elements, strings.TrimSpace), nil
    }

PositionalAttribute <- (
    value:(AttributeRawValue) (("," Space*)? / &"]") { // TODO: see if we can just use `((",")? / &"]")` instead (ie, no need to check for Space*)
    	return types.NewPositionalAttribute(value)
    }) 
    / 
    // empty/edge-case values. Eg: `[ ]`, `[, a, b]`, `[a, ,b]`, etc.
    (value:(Space* (("," Space*) / &"]"))
    &{
        // here we can't rely on `c.text` if the content is empty 
        // (in such a case, `c.text` contains the char sequence of the previous 
        // rule that matched)
        return !types.AllNilEntries(value.([]interface{})), nil
    }
    { 
        return types.NewPositionalAttribute(nil)
    })

NamedAttribute <- key:(NamedAttributeKey) "=" Space* value:(AttributeRawValue) ("," Space*)? { // TODO: include `,` or expect `]`
        return types.NewNamedAttribute(key.(string), value)
    }

// The spec says attributes have be alphanumeric but does not consider foreign letters.  We are more generous.
NamedAttributeKey <- !Space [^\r\n=,\]]+ Space* {
        return strings.TrimSpace(string(c.text)), nil
    }

AttributeRawValue <- 
    value:(
        SingleQuotedAttributeRawValue 
        / DoubleQuotedAttributeRawValue 
        / UnquotedAttributeRawValue
    ) 
    &(!(Space* "=")) {
        return value, nil
    }

SingleQuotedAttributeRawValue <- 
    "'" !"`" // prevent entering when the value is a quoted string (eg: '`cookie`')
    content:(SingleQuotedAttributeRawValueContent)
    "'" {
        return content, nil
    }

SingleQuotedAttributeRawValueContent <- 
    elements:(
        Alphanums
        / Space
        / AttributeSubstitution
        / (`\'` { 
            return types.NewStringElement(`'`) // escaped single quote
        })
        / ( "'`" / "`'" / `\` { // quoted string delimiters or standalone backslash
            return types.NewStringElement(string(c.text)) // keep as-is for now
        })
        / ([^\r\n\\'' ]+ { // = and , signs are allowed within '' quoted values
            return types.NewStringElement(string(c.text))
        })
    )+ {
        return types.Reduce(elements), nil
    }

DoubleQuotedAttributeRawValue <- 
    "\"" !"`" // prevent entering when the value is a quoted string (eg: "`cookie`")
    content:(DoubleQuotedAttributeRawValueContent)
    "\"" &(!(Space* "=")) {
        return content, nil
    }
DoubleQuotedAttributeRawValueContent <- 
    elements:(
        Alphanums
        / Space
        / AttributeSubstitution
        / (`\"` { 
            return types.NewStringElement(`"`) // escaped double quote
        })
        / ( "\"`" / "`\"" / `\` / "`" { // quoted string delimiters or standalone backslash or standalone backtick
            return types.NewStringElement(string(c.text)) // keep as-is for now
        })
        / ([^\r\n\\"` ]+ { // = and , signs are allowed within " quoted values
            return types.NewStringElement(string(c.text))
        })
    )+ {
        return types.Reduce(elements), nil
    }

// Unquoted Attribute Value, may include spaces but not on the first position
UnquotedAttributeRawValue <-
    // need to support value like `[.myrole1]_a_` in `a link to https://example.com[[.myrole1]_a_]`
    // so we need to count the `[` and `]` to balance
    !Space // can't start with a space (eg: can't have `[ cookie ]`)
    elements:(
        ("[" UnquotedAttributeRawValue "]") // recursively within brackets (see comment above)
        / ElementPlaceHolder
        / AttributeSubstitution
        / ([^=,\uFFFD\] ]+ { // not within brackets and stop on space
            return string(c.text), nil
        }) 
        / Space
    )+ {
        return types.Reduce(elements, strings.TrimSpace), nil
    }

// -------------------------------------------------------------------------------------
// Attribute Substitution
// -------------------------------------------------------------------------------------
AttributeSubstitution <-
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Attributes)
    }
    element:(CounterSubstitution / AttributeValueSubstitution) {
        return element, nil
    }

AttributeValueSubstitution <- "{" name:AttributeName "}" { 
    return types.NewAttributeSubstitution(name.(string), string(c.text))
}

// TODO: simplify the 'start' optional attribute
CounterSubstitution <- CounterSubstitution1 / CounterSubstitution2

CounterSubstitution1 <- "{counter:" name:AttributeName start:(CounterStart)? "}" {
    return types.NewCounterSubstitution(name.(string), false, start, string(c.text))
}

CounterSubstitution2 <- "{counter2:" name:AttributeName start:(CounterStart)? "}" {
    return types.NewCounterSubstitution(name.(string), true, nil, string(c.text))
}

CounterStart <- ":" start:([A-Za-z] {
        return string(c.text), nil
    } / [0-9]+ { 
        return strconv.Atoi(string(c.text)) 
    }) {
        return start, nil
    }

// -------------------------------------------------------------------------------------
// BlankLine
// -------------------------------------------------------------------------------------
BlankLine <- !EOF Space* EOL {
        return types.NewBlankLine()
    }

// -------------------------------------------------------------------------------------
// Cross References
// -------------------------------------------------------------------------------------
CrossReference <- InternalCrossReference / ExternalCrossReference 

InternalCrossReference <- "<<" id:(Id) Space* "," label:(CrossReferenceLabel) ">>" {
        return types.NewInternalCrossReference(id, label)
    } / "<<" id:(Id) ">>" {
        return types.NewInternalCrossReference(id, nil)
    } 

ExternalCrossReference <- "xref:" url:(FileLocation) attributes:(InlineAttributes) {
        return types.NewExternalCrossReference(url.(*types.Location), attributes.(types.Attributes))
    }

CrossReferenceLabel <- (
    ([\pL0-9][^\r\n{<>]+ { // `{`, `>` and `>` characters are not allowed as they are used for attribute substitutions and cross-references 
        return types.NewStringElement(string(c.text))
    })
    / AttributeSubstitution
    / ("{" { 
        return types.NewStringElement(string(c.text))
    })
    )+


// -------------------------------------------------------------------------------------
// Delimited Blocks
// -------------------------------------------------------------------------------------
DelimitedBlock <-
    CommentBlock
    / ExampleBlock
    / FencedBlock
    / ListingBlock
    / LiteralBlock
    / MarkdownQuoteBlock
    / PassthroughBlock
    / QuoteBlock
    / SidebarBlock

BlockDelimiter <-
    !Alphanum // quick escape
    delimiter:(
        CommentBlockDelimiter
        / ExampleBlockDelimiter
        / FencedBlockDelimiter
        / ListingBlockDelimiter
        / LiteralBlockDelimiter
        / PassthroughBlockDelimiter
        / QuoteBlockDelimiter
        / SidebarBlockDelimiter) {
            return delimiter, nil
        }


CommentBlockDelimiter <- "////" Space* EOL {
    return types.NewBlockDelimiter(types.Comment, string(c.text))
}

ExampleBlockDelimiter <- "====" Space* EOL {
    return types.NewBlockDelimiter(types.Example, string(c.text))
}

FencedBlockDelimiter <- "```" Space* EOL {
    return types.NewBlockDelimiter(types.Fenced, string(c.text))
}

ListingBlockDelimiter <- "----" Space* EOL {
    return types.NewBlockDelimiter(types.Listing, string(c.text))
}

LiteralBlockDelimiter <- "...." Space* EOL {
    return types.NewBlockDelimiter(types.Literal, string(c.text))
}

PassthroughBlockDelimiter <- "++++" Space* EOL {
    return types.NewBlockDelimiter(types.Passthrough, string(c.text))
}

QuoteBlockDelimiter <- "____" Space* EOL {
    return types.NewBlockDelimiter(types.Quote, string(c.text))
}

SidebarBlockDelimiter <- "****" Space* EOL {
    return types.NewBlockDelimiter(types.Sidebar, string(c.text))
}

DelimitedBlockRawLine <- 
    !EOF // in case the block is unclosed and at the end of the document
    content:([^\r\n]* { // content is NOT mandatory
        return string(c.text), nil
    }) EOL { 
        return types.NewRawLine(content.(string))
    }

// ----------------
// Comment Blocks
// ----------------
CommentBlock <-
    CommentBlockStartDelimiter
    content:(CommentBlockContent)
    CommentBlockEndDelimiter? {
        c.unsetWithinDelimitedBlock()
        return types.NewDelimitedBlock(types.Comment, content.([]interface{}))
    }

CommentBlockStartDelimiter <- CommentBlockDelimiter

CommentBlockEndDelimiter <- CommentBlockDelimiter / EOF

CommentBlockContent <- 
    (!CommentBlockEndDelimiter
    line:DelimitedBlockRawLine {
        return line, nil
    })*

// ----------------------
// Example Blocks
// ----------------------
ExampleBlock <-
    ExampleBlockStartDelimiter
    content:(ExampleBlockContent)
    ExampleBlockEndDelimiter? {
        c.unsetWithinDelimitedBlock()
        return types.NewDelimitedBlock(types.Example, content.([]interface{}))
    }

ExampleBlockStartDelimiter <- ExampleBlockDelimiter

ExampleBlockEndDelimiter <- ExampleBlockDelimiter / EOF

ExampleBlockContent <- 
   (!ExampleBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Fenced Blocks
// ----------------------
FencedBlock <-
    FencedBlockStartDelimiter
    content:(FencedBlockContent)
    FencedBlockEndDelimiter? {
        c.unsetWithinDelimitedBlock()
        return types.NewDelimitedBlock(types.Fenced, content.([]interface{}))
    }

FencedBlockStartDelimiter <- FencedBlockDelimiter 
    
FencedBlockEndDelimiter <- FencedBlockDelimiter / EOF

FencedBlockContent <- 
    (!FencedBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Listing Blocks
// ----------------------
ListingBlock <-
    ListingBlockStartDelimiter
    content:(ListingBlockContent)
    ListingBlockEndDelimiter? {
        c.unsetWithinDelimitedBlock()
        return types.NewDelimitedBlock(types.Listing, content.([]interface{}))
    }

ListingBlockStartDelimiter <- ListingBlockDelimiter 
    
ListingBlockEndDelimiter <- ListingBlockDelimiter / EOF

ListingBlockContent <- 
    (!ListingBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Literal Blocks
// ----------------------
LiteralBlock <-
    LiteralBlockStartDelimiter
    content:(LiteralBlockContent)
    LiteralBlockEndDelimiter? {
        c.unsetWithinDelimitedBlock()
        return types.NewDelimitedBlock(types.Literal, content.([]interface{}))
    }

LiteralBlockStartDelimiter <- LiteralBlockDelimiter

LiteralBlockEndDelimiter <- LiteralBlockDelimiter / EOF

LiteralBlockContent <- 
    (!LiteralBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Markdown Quote Blocks
// ----------------------
MarkdownQuoteBlock <- 
    firstLine:(MarkdownQuoteRawLine)
    otherLines:(MarkdownQuoteRawLine / ParagraphRawLine)* 
    {
        return types.NewDelimitedBlock(types.MarkdownQuote, append([]interface{}{firstLine}, otherLines.([]interface{})...))
    }

MarkdownQuoteRawLine <- 
    !BlankLine
    "> " 
    content:(([^\r\n]+) { 
        return string(c.text), nil
    }) EOL {
        return types.NewRawLine(content.(string))
    }

MarkdownQuoteAttribution <- 
    "-- " author:(([^\r\n]+) {
        return string(c.text), nil
    }) EOL {
        return author, nil
    }

// ----------------------
// Passthrough Blocks
// ----------------------
PassthroughBlock <-
    PassthroughBlockStartDelimiter
    content:(PassthroughBlockContent)
    PassthroughBlockEndDelimiter? {
        c.unsetWithinDelimitedBlock()
        return types.NewDelimitedBlock(types.Passthrough, content.([]interface{}))
    }

PassthroughBlockStartDelimiter <- PassthroughBlockDelimiter

PassthroughBlockEndDelimiter <- PassthroughBlockDelimiter / EOF

PassthroughBlockContent <- 
    (!PassthroughBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Quote Blocks
// ----------------------
QuoteBlock <-
    QuoteBlockStartDelimiter
    content:(QuoteBlockContent)
    QuoteBlockEndDelimiter? {
        c.unsetWithinDelimitedBlock()
        return types.NewDelimitedBlock(types.Quote, content.([]interface{}))
    }

QuoteBlockStartDelimiter <- QuoteBlockDelimiter

QuoteBlockEndDelimiter <- QuoteBlockDelimiter / EOF

QuoteBlockContent <- 
   (!QuoteBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Sidebar Blocks
// ----------------------
SidebarBlock <-
    SidebarBlockStartDelimiter
    content:(SidebarBlockContent)
    SidebarBlockEndDelimiter? {
        c.unsetWithinDelimitedBlock()
        return types.NewDelimitedBlock(types.Sidebar, content.([]interface{}))
    }

SidebarBlockStartDelimiter <- SidebarBlockDelimiter 

SidebarBlockEndDelimiter <- SidebarBlockDelimiter / EOF 

SidebarBlockContent <- 
   (!SidebarBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// -------------------------------------------------------------------------------------
// Document Header and Metadata
// -------------------------------------------------------------------------------------
DocumentHeader <- 
    &{
        return c.isDocumentHeaderAllowed(), nil
    }
    BlankLine* // ignored in the returned element
    title:DocumentTitle
    info:DocumentInformation?
    extraAttrs:(AttributeDeclaration / AttributeReset)* // we need to collect extra attrs to process substitution on the title
    {
        return types.NewDocumentHeader(title.([]interface{}), info, extraAttrs.([]interface{}))
    }

DocumentTitle <- 
    "=" Spaces title:(SectionTitle) EOL {
        return title, nil
    }
       
DocumentInformation <-
    !BlankLine
    (SingleLineComment / CommentBlock)* // ignored in the returned element
    authors:(DocumentAuthors) 
    (SingleLineComment / CommentBlock)* // ignored in the returned element
    revision:(DocumentRevision)? {
        return types.NewDocumentInformation(authors.(types.DocumentAuthors), revision)
    }

DocumentAuthors <- Space* authors:(DocumentAuthorsInlineForm / DocumentAuthorsAttributeForm) EOL {
    return authors, nil
}

DocumentAuthorsInlineForm <- !":" authors:(DocumentAuthor+) {
    return types.NewDocumentAuthors(authors.([]interface{})...)
}

DocumentAuthorsAttributeForm <- ":author:" Space* author:(DocumentAuthor) {
    return types.NewDocumentAuthors(author)
}

DocumentAuthor <- 
    fullName:(DocumentAuthorFullName)? email:(DocumentAuthorEmail)? Space* ";"? Space* 
    &{
        // at least 1 of [fullName, email] must be defined
        return fullName != nil || email != nil, nil
    }
    {
        return types.NewDocumentAuthor(fullName, email)
    }

// "<" marks the beginning of the author email, and ";" is the authors separator
DocumentAuthorFullName <- 
    part1:([^<;\r\n ]+ { // no space allowed
        return string(c.text), nil
    })
    Space*
    part2:([^<;\r\n ]+ { // no space allowed
        return string(c.text), nil
    })?
    Space*
    part3:([^<;\r\n]+ { // spaces allowed
        return string(c.text), nil
    })? 
    Space* {
        return types.NewDocumentAuthorFullName(part1.(string), part2, part3)
    }


DocumentAuthorEmail <- 
    !EOF 
    "<" 
    email:(([^>\r\n]+) {
        return string(c.text), nil
    }) 
    ">" {
        return email, nil
    }

// see http://asciidoctor.org/docs/user-manual/#revision-number-date-and-remark
// Eg: "v1.0, October 2, 2013: First incarnation"
DocumentRevision <- Space* !":" revision:(
        (revnumber:(DocumentRevisionNumber) ","? revdate:(DocumentRevisionDate)? ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(revnumber, revdate, revremark)
        }) / (revdate:(DocumentRevisionDate) ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(nil, revdate, revremark)
        })) EOL {
    return revision, nil
}

// DocumentRevisionNumber MUST start with a `v` or MAY start with a `v` but MUST end with a `,`
DocumentRevisionNumber <- "v"i [0-9] [^:,\r\n]+ {
    return string(c.text), nil
} / "v"i? [0-9] [^:,\r\n]+ Space* &"," {
    return string(c.text), nil
}

DocumentRevisionDate <- [^:\r\n]+ {
    return string(c.text), nil
}

DocumentRevisionRemark <- [^\r\r\n]+ {
    return string(c.text), nil
}

// -------------------------------------------------------------------------------------
// ElementPlaceHolder
// -------------------------------------------------------------------------------------
ElementPlaceHolderDelimiter <- "\uFFFD"

ElementPlaceHolder <- ElementPlaceHolderDelimiter ref:([0-9]+ { return string(c.text), nil }) ElementPlaceHolderDelimiter {
    return types.NewElementPlaceHolder(ref.(string))
}

// -----------------------------------------------------------------------------------------------------------------------
// Explicit line breaks
// -----------------------------------------------------------------------------------------------------------------------
LineBreak <- 
    &{ 
        return c.isPreceededBySpace(), nil
    }
    "+" Space* &(EOL) {
        return types.NewLineBreak()    
    }

// -------------------------------------------------------------------------------------
// Front Matter
// -------------------------------------------------------------------------------------
FrontMatter <- 
    &{
        return c.isFrontMatterAllowed(), nil
    }
    frontmatter:(YamlFrontMatter) 
    {
        return frontmatter, nil
    }

YamlFrontMatter <- YamlFrontMatterDelimiter content:(YamlFrontMatterContent)? YamlFrontMatterDelimiter {
    return types.NewYamlFrontMatter(content.(string))
}

YamlFrontMatterDelimiter  <- "---" Space* EOL

YamlFrontMatterContent <- ((!YamlFrontMatterDelimiter .)+)* {
        return string(c.text), nil
}

FrontMatterFragment <- FrontMatterDelimiter / BlankLine / FrontMatterLine

FrontMatterDelimiter  <- "---" Space* EOF

FrontMatterLine <- (.)* {
    return types.NewRawLine(string(c.text))
}

// -------------------------------------------------------------------------------------
// Inline Elements
// -------------------------------------------------------------------------------------
InlineElements <- 
    elements:(comment:(SingleLineComment) {
        return types.NewInlineElements([]interface{}{comment})
    } / elements:(InlineElement)+ EOL { 
        return types.NewInlineElements(elements.([]interface{}))
    }) {
        c.resetSpaceSuffixTracking()
        return elements, nil
    }


// TODO: group as below and enable based on substitution context.
// Also, add Callouts

// "specialcharacters",
// "quotes",
// "attributes",
// "replacements",
// "macros",
// "post_replacements",
InlineElement <-  
    element:(
        InlineWord // more permissive than the 'Word' rule
        / Spaces 
        / LineBreak
        / !EOL (
            SpecialCharacter
            / Quote
            / AttributeSubstitution 
            / InlineMacro
            / Symbol
            / ElementPlaceHolder // TODO: needed?
            // if anything above did not match...
            / AnyChar)) {
    c.trackSpaceSuffix(element)
    return element, nil
}

// -------------------------------------------------------------------------------------
// InlineElement ID
// -------------------------------------------------------------------------------------
InlineElementID <- "[[" id:(Id) "]]" Space* { // no EOL here since there can be multiple InlineElementID on the same line
    return types.NewInlineIDAttribute(id.(string))
}

// -------------------------------------------------------------------------------------
// Index Terms
// -------------------------------------------------------------------------------------
IndexTerm <- "((" term:(IndexTermContent) "))" {
       return types.NewIndexTerm(term.([]interface{}))
    }

IndexTermContent <- elements:(Word / QuotedString / QuotedText / Space / SpecialCharacter / ElementPlaceHolder / (!"))" .) {
    return string(c.text), nil
})+ {
    return types.NewInlineElements(elements.([]interface{}))
}

ConcealedIndexTerm <- "(((" term1:(ConcealedIndexTermContent) 
    term2:(Space* "," Space* content:(ConcealedIndexTermContent) { return content, nil })? 
    term3:(Space* "," Space* content:(ConcealedIndexTermContent) { return content, nil })? 
    ")))" {
        return types.NewConcealedIndexTerm(term1, term2, term3)
    }

ConcealedIndexTermContent <- (Alphanum / Space)+ {
    return string(c.text), nil
}

// -------------------------------------------------------------------------------------
// Images
// -------------------------------------------------------------------------------------
ImageBlock <- 
    "image::" path:(Location) attributes:(InlineAttributes) Space* EOL {
        // 'imagesdir' attribute is added after applying the attribute substitutions on the image location
        return types.NewImageBlock(path.(*types.Location), attributes.(types.Attributes))
    }

InlineImage <- "image:" !":" path:(Location) attributes:(InlineAttributes) {
        return types.NewInlineImage(path.(*types.Location), attributes.(types.Attributes), c.globalStore["imagesdir"])
    }

// -------------------------------------------------------------------------------------------------------------------------------
// Inline Icons
// -------------------------------------------------------------------------------------------------------------------------------
InlineIcon <- "icon:" icon:([\pL0-9_-]+ { return string(c.text), nil }) attributes:(InlineAttributes) {
        return types.NewIcon(icon.(string), attributes)
    }

// -------------------------------------------------------------------------------------------------------------------------------
// Inline Foot Notes
// -------------------------------------------------------------------------------------------------------------------------------
InlineFootnote <- "footnote:[" content:(FootnoteContent) "]" {
        return types.NewFootnote("", content)
    } / "footnote:" ref:(FootnoteRef) "[" content:(FootnoteContent)? "]" { // TODO: use only this rule with `ref:(FootnoteRef)?`
        return types.NewFootnote(ref.(string), content)
    }

FootnoteRef <- Alphanums

FootnoteContent <- elements:(!"]" InlineElement)+  { // footnote content may span multiple lines
        return types.NewInlineElements(elements.([]interface{}))
    }

// -------------------------------------------------------------------------------------
// Passthrough
// -------------------------------------------------------------------------------------

SinglePlusPassthroughPrefix <- "+"

SinglePlusPassthrough <- SinglePlusPassthroughPrefix content:(SinglePlusPassthroughContent) SinglePlusPassthroughPrefix !Alphanum {
        return types.NewInlinePassthrough(types.SinglePlusPassthrough, []interface{}{content})
    }

SinglePlusPassthroughContent <- ((!SinglePlusPassthroughPrefix !Space !Newline .) (!(Spaces SinglePlusPassthroughPrefix) !SinglePlusPassthroughPrefix !Newline .)* { // no space in the first or last position of the content, but allowed elsewhere
        return types.NewStringElement(string(c.text))
    }) / ((!Space !Newline !SinglePlusPassthroughPrefix .)  { // a single character
        return types.NewStringElement(string(c.text))
    })

TriplePlusPassthroughPrefix <- "+++"

TriplePlusPassthrough <- TriplePlusPassthroughPrefix content:(TriplePlusPassthroughContent) TriplePlusPassthroughPrefix !Alphanum {
        return types.NewInlinePassthrough(types.TriplePlusPassthrough, []interface{}{content})
    }

TriplePlusPassthroughContent <- ((!TriplePlusPassthroughPrefix .)* { // spaces and newlines are also allowed in the first or last position of the content and elsewhere too
        return types.NewStringElement(string(c.text))
    }) / ((!Space !Newline !TriplePlusPassthroughPrefix .)?  { // a single character
        return types.NewStringElement(string(c.text))
    })

PassthroughMacro <- "pass:[" content:(PassthroughMacroCharacter)* "]" {
        return types.NewInlinePassthrough(types.PassthroughMacro, []interface{}{content})
    } / "pass:q[" content:(QuotedText / PassthroughMacroCharacter)* "]" {
        return types.NewInlinePassthrough(types.PassthroughMacro, content.([]interface{}))
    }

PassthroughMacroCharacter <- [^\]] {
        return types.NewStringElement(string(c.text))
    }

// -------------------------------------------------------------------------------------
// Links
// -------------------------------------------------------------------------------------
Link <- RelativeLink / ExternalLink

// url preceeding with `link:` MUST be followed by square brackets
RelativeLink <- "link:" url:(Location) attributes:(InlineAttributes) {
        return types.NewInlineLink(url.(*types.Location), attributes.(types.Attributes))
    }

ExternalLink <- url:(LocationWithScheme) attributes:(InlineAttributes)? {
        return types.NewInlineLink(url.(*types.Location), attributes)
    }


// -----------------------------------------------------------------------------------------------------------------------
// List 
// -----------------------------------------------------------------------------------------------------------------------
ListElements <- 
    firstElement:(ListElement)
    extraElements:(ExtraListElements) {
        return types.NewListElements(append([]interface{}{firstElement}, extraElements.([]interface{})...))
    }

ListElement <- 
    OrderedListElement 
    / UnorderedListElement
    / CalloutListElement
    / LabeledListElement 

ExtraListElements <- elements:(ExtraListElement)* {
    return types.Flatten(elements.([]interface{})), nil
}

ExtraListElement <- // other elements can be separated by blankline WITHOUT attributes, or can have attributes but NO blankline before
    !EOF 
    element:(
        (   BlankLine* 
            element:OrderedListElement {
                return element, nil
            })
        / ( attributes:(BlockAttributes)+ 
            element:OrderedListElement {
                return append(attributes.([]interface{}), element), nil
            })
        / ( BlankLine* 
            element:UnorderedListElement {
                return element, nil
            })
        / ( attributes:(BlockAttributes)+ 
            element:UnorderedListElement {
                return append(attributes.([]interface{}), element), nil
            })
        / ( BlankLine* 
            element:CalloutListElement {
                return element, nil
            })
        / ( attributes:(BlockAttributes)+ 
            element:CalloutListElement {
                return append(attributes.([]interface{}), element), nil
            })
        / ListElementContinuation
        / ( BlankLine* 
            element:LabeledListElement {
                return element, nil
            })
        / ( attributes:(BlockAttributes)+ 
            element:LabeledListElement {
                return append(attributes.([]interface{}), element), nil
            })
        / SingleLineComment
        / ( element:ListElementParagraphLine {
                return element, nil
            }) // must follow directly a list element
    ) {
        return element, nil
    }

ListElementParagraphLine <- 
    !BlankLine
    !ListElementContinuationMarker
    !OrderedListElementPrefix
    !UnorderedListElementPrefix
    !CalloutListElementPrefix
    !(LabeledListElementTerm LabeledListElementSeparator)
    !BlockDelimiter
    content:([^\r\n]+ {
        return strings.TrimSpace(string(c.text)), nil
    })
    EOL { // do not retain the EOL chars
        return types.NewRawLine(content.(string))
    }

ListElementContent <- 
    rawline:([^\r\n]+ {
        return types.NewRawLine(string(c.text))
    })
    EOL {
        return types.NewParagraph(rawline)
    }

// ---------------------------
// List Element Continuations
// ---------------------------
ListElementContinuation <- 
    offset:(Space* Newline)* 
    ListElementContinuationMarker
    element:ListElementContinuationElement?
    {
        return types.NewListElementContinuation(len(offset.([]interface{})), element)    
    }

ListElementContinuationMarker <- "+" Space* Newline

ListElementContinuationElement <- // TODO: same as DelimitedBlockElement?
    !EOF // quick escapes
    !ListElement
    attributes:(BlockAttributes)?
    element:(
        BlankLine
        / AttributeDeclaration
        / AttributeReset
        / DelimitedBlock
        / ThematicBreak // must appear before ListElement :/
        / ImageBlock
        / Table
        / SingleLineComment
        / AdmonitionParagraph
        / LiteralParagraph
        / ListContinuationParagraph // must be the last one... 
    ) {
        if element,ok := element.(types.BlockWithAttributes); ok && attributes != nil {
            element.AddAttributes(attributes.(types.Attributes))
        }
        // if log.IsLevelEnabled(log.DebugLevel) {
        //     log.Debugf("returning element '%s'\n", spew.Sdump(element))
        // }
        return element, nil
    }

// new paragraph with single line (other lines will be appended afterwards)
ListContinuationParagraph <- 
    content:([^\r\n]+ {
        return string(c.text), nil
    })
    EOL { // do not retain the EOL chars
        return types.NewParagraph(types.RawLine(content.(string)))
    }

// ------------------------
// Ordered List Elements
// ------------------------
OrderedListElement <- 
    prefix:(OrderedListElementPrefix) 
    content:(ListElementContent) 
    {
        return types.NewOrderedListElement(prefix.(types.OrderedListElementPrefix), content)
    }

OrderedListElementPrefix <- 
    Space* prefix:(
        // implicit numbering: "." to "....."
        depth:((".")+ {   
            // `.` is 1, etc.
            return (len(c.text)), nil 
        }) 
        &{  
            // use a predicate to make sure that only `.` to `.....` are allowed
            return depth.(int) <= 5, nil 
        } 
        {
            switch depth.(int){
            case 1:
                return types.NewOrderedListElementPrefix(types.Arabic)
            case 2:
                return types.NewOrderedListElementPrefix(types.LowerAlpha)
            case 3:
                return types.NewOrderedListElementPrefix(types.LowerRoman)
            case 4:
                return types.NewOrderedListElementPrefix(types.UpperAlpha)
            default:
                return types.NewOrderedListElementPrefix(types.UpperRoman)
            }
        }
        // explicit numbering
        / ([0-9])+ "." {  // numbering style: "1.", etc.
            return types.NewOrderedListElementPrefix(types.Arabic)
        } / ([a-z]) "." { // numbering style: "a.", etc.
            return types.NewOrderedListElementPrefix(types.LowerAlpha)
        } / ([A-Z]) "." { // numbering style: "A.", etc.
            return types.NewOrderedListElementPrefix(types.UpperAlpha)
        } / ([ivxdlcm])+ ")" { // numbering style: "i)", etc.
            return types.NewOrderedListElementPrefix(types.LowerRoman)
        } / ([IVXDLCM])+ ")" { // numbering style: "I)", etc.
            return types.NewOrderedListElementPrefix(types.UpperRoman)
        }) Spaces {
    return prefix, nil
}

// ------------------------
// Unordered list Elements
// ------------------------
UnorderedListElement <- 
    prefix:(UnorderedListElementPrefix) 
    checkstyle:(UnorderedListElementCheckStyle)? 
    content:(ListElementContent) {
        return types.NewUnorderedListElement(prefix.(types.UnorderedListElementPrefix), checkstyle, content)
    }

UnorderedListElementPrefix <- 
    Space* prefix:((
        // implicit numbering: "*" to "*****" 
        depth:(("*")+ {   
            // `*` is 1, etc.
            return (len(c.text)), nil 
        }) 
        &{  
            // use a predicate to make sure that only `*` to `*****` are allowed
            return depth.(int) <= 5, nil 
        } 
        {
            switch depth.(int){
            case 1:
                return types.NewUnorderedListElementPrefix(types.OneAsterisk)
            case 2:
                return types.NewUnorderedListElementPrefix(types.TwoAsterisks)
            case 3:
                return types.NewUnorderedListElementPrefix(types.ThreeAsterisks)
            case 4:
                return types.NewUnorderedListElementPrefix(types.FourAsterisks)
            default:
                return types.NewUnorderedListElementPrefix(types.FiveAsterisks)
            }
        }) / depth:(("-") {
            return types.NewUnorderedListElementPrefix(types.Dash)
        })) Spaces {
    return prefix, nil
} 

UnorderedListElementCheckStyle <- 
    &"[" style:(
      "[ ]" { return types.Unchecked, nil } 
    / "[*]" { return types.Checked, nil } 
    / "[x]" { return types.Checked, nil }
    ) Spaces {
        return style, nil
    }

// ------------------------
// Labelled list elements
// ------------------------
LabeledListElement <- 
    term:(LabeledListElementTerm) 
    separator:(LabeledListElementSeparator) 
    description:(LabeledListElementDescription)
    {
        return types.NewLabeledListElement(len(separator.(string)) - 1, term, description)
    }

LabeledListElementTerm <- 
    (!LabeledListElementSeparator !EOL .)+ {
        return types.NewRawLine(string(c.text))
    }

LabeledListElementSeparator <- 
    separator:((":")+ {   
        return string(c.text), nil
    })
    &{  
        // use a predicate to make sure that separator is `::`, `:::` or `::::`
        return len(separator.(string)) >= 2 && len(separator.(string)) <= 4, nil 
    } {
        return separator, nil
    }

LabeledListElementDescription <- 
    (
        // no description on the same line as the term
        Space* EOL 
        BlankLine* 
        content:(ListElementParagraphLine)? {
            if content == nil {
                return nil, nil
            }
            return types.NewParagraph(content)
        }
    ) / (
        // description on the same line as the term
        Spaces // trim spaces right after delimiter
        content:([^\r\n]+ {
            return types.NewRawLine(string(c.text))
        })
        EOL {
            return types.NewParagraph(content)
        }
    )

// ------------------------
// Callout list elements
// ------------------------
Callout <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Callouts)
    }
    "<" ref:([0-9]+ { return strconv.Atoi(string(c.text)) }) ">" Space* &(EOL / Callout) {
        return types.NewCallout(ref.(int))
    }

CalloutListElement <- 
    ref:(CalloutListElementPrefix) 
    description:(CalloutListElementContent) {
        return types.NewCalloutListElement(ref.(int), description.(types.RawLine))
    }

CalloutListElementPrefix <- 
    "<" ref:([0-9]+ { return strconv.Atoi(string(c.text)) }) ">" Spaces {
        return ref, nil
    }

CalloutListElementContent <- // TODO: remove in favor of `ListElementContent`
    rawline:([^\r\n]+ {
        return string(c.text), nil
    })
    EOL {
        return types.NewRawLine(rawline.(string))
    }

// -----------------------------------------------------------------------------------------------------------------------
// Paragraphs
// -----------------------------------------------------------------------------------------------------------------------
ShortcutParagraph <- 
    &(Alphanum) // make sure that the line starts with an alphanum and it's not an ordered list element prefix
    &(!OrderedListElementPrefix)
    &(!UnorderedListElementPrefix)
    &(!AdmonitionKind)
    firstLine:(ParagraphRawLine) 
    &{
        // also, make sure that there is no LabeledListElement delimiter (`::` - `::::`) 
        //   in the middle of the line (with space afterwards)
        //   or at the end of the line 
        return !strings.Contains(string(firstLine.(types.RawLine)), ":: ") && 
            !strings.HasSuffix(string(firstLine.(types.RawLine)), "::"), nil
    }
    otherLines:(
        !EOF 
        !BlankLine
        !BlockAttributes
        !ListElementContinuationMarker
        line:(SingleLineComment / ParagraphRawLine) {
            return line, nil
        })* 
    {
        return types.NewParagraph(append([]interface{}{firstLine}, otherLines.([]interface{})...)...)
    }

Paragraph <- 
    firstLine:(ParagraphRawLine) 
    otherLines:(
        !EOF
        !BlankLine
        !BlockAttributes
        !ListElementContinuationMarker
        line:(SingleLineComment / ParagraphRawLine) {
            return line, nil
        })* 
    {
        return types.NewParagraph(append([]interface{}{firstLine}, otherLines.([]interface{})...)...)
    }

// TODO: reuse `Paragraph` rule
AdmonitionParagraph <- 
    kind:(AdmonitionKind) ": " 
    firstLine:(ParagraphRawLine) 
    otherLines:(
        !ListElementContinuationMarker
        line:(SingleLineComment / ParagraphRawLine) {
            return line, nil
        })*
    { 
        return types.NewAdmonitionParagraph(kind.(string), append([]interface{}{firstLine}, otherLines.([]interface{})...))
    }

ParagraphRawLine <- 
    content:([^\r\n]+ {
        return string(c.text), nil
    })
    &{
        return len(strings.TrimSpace(string(c.text))) > 0, nil
    }
    EOL {
        return types.NewRawLine(content.(string))
    }

LiteralParagraph <- 
    firstLine:(LiteralParagraphRawLine) 
    otherLines:(SingleLineComment / ParagraphRawLine)*
    { 
        return types.NewLiteralParagraph(types.LiteralBlockWithSpacesOnFirstLine, append([]interface{}{firstLine}, otherLines.([]interface{})...))
    }

LiteralParagraphRawLine <- 
    content:(Spaces [^\r\n]+ {
        return string(c.text), nil
    })
    &{
        return len(strings.TrimSpace(string(c.text))) > 0, nil
    }
    EOL {
        return types.NewRawLine(content.(string))
    }

// -----------------------------------------------------------------------------------------------------------------------
// Quoted Texts (bold, italic, monospace, marked, superscript and subscript)
// -----------------------------------------------------------------------------------------------------------------------
QuotedText <- 
    (
        attributes:(LongHandAttributes)? // TODO: do not check for attributes on quoted text if we're already parsing an attribute value?
        text:(UnconstrainedQuotedText / ConstrainedQuotedText) {
            return text.(*types.QuotedText).WithAttributes(attributes)
        }
    ) 
    / EscapedQuotedText

ConstrainedQuotedTextMarker <- "*" !"*" / "_" !"_" / "#" !"#" / "`" !"`"

UnconstrainedQuotedTextPrefix <- "**" / "__" / "``" / DoubleQuoteMarkedTextDelimiter / "^" / "~"

ConstrainedQuotedText <- 
    SingleQuoteBoldText 
    / SingleQuoteItalicText
    / SingleQuoteMarkedText
    / SingleQuoteMonospaceText 
    / SubscriptText 
    / SuperscriptText 

UnconstrainedQuotedText <- 
    DoubleQuoteBoldText
    / DoubleQuoteItalicText
    / DoubleQuoteMarkedText
    / DoubleQuoteMonospaceText

EscapedQuotedText <- // TODO: use something like `&('\')` to quickly escape?
    &(`\`)
    element:(
        EscapedBoldText 
        / EscapedItalicText
        / EscapedMarkedText
        / EscapedMonospaceText 
        / EscapedSubscriptText 
        / EscapedSuperscriptText
    ) {
        return element, nil
    }

SubscriptOrSuperscriptPrefix <- "^" / "~" { // rule used within `words` to detect superscript or subscript portions, eg in math formulae.
        return string(c.text), nil
    }

OneOrMoreBackslashes <- `\`+ {
        return string(c.text), nil
    }

TwoOrMoreBackslashes <- `\\` `\`* {
        return string(c.text), nil
    }

// ---------------------------------------------------
// Quoted Bold Text
// ---------------------------------------------------
BoldText <- DoubleQuoteBoldText / SingleQuoteBoldText // double punctuation must be evaluated first

BoldTextDelimiter <- "*"

BoldTextWord <- 
    [\pL0-9,?!;]+ &(Space / BoldTextDelimiter) {
        return types.NewStringElement(string(c.text))
    }

// -------------------------------
// Bold text within double quotes
// -------------------------------
DoubleQuoteBoldTextDelimiter <- "**"

DoubleQuoteBoldText <- 
    DoubleQuoteBoldTextDelimiter 
    elements:(DoubleQuoteBoldTextElements) 
    DoubleQuoteBoldTextDelimiter {
        return types.NewQuotedText(types.DoubleQuoteBold, elements.([]interface{}))
    } 

DoubleQuoteBoldTextElements <- DoubleQuoteBoldTextElement+  

DoubleQuoteBoldTextElement <- 
    !DoubleQuoteBoldTextDelimiter
    element:(
        BoldTextWord
        / Spaces // may start and end with spaces
        / Newline !Newline // 2 newlines split the paragraph
        / AttributeSubstitution
        / SpecialCharacter
        / Symbol
        / InlineMacro
        / QuotedString
        / QuotedTextInDoubleQuoteBoldText
        / ElementPlaceHolder
        / DoubleQuoteBoldTextFallbackCharacter) {
            return element, nil
        }

QuotedTextInDoubleQuoteBoldText <- 
    attributes:(LongHandAttributes)? 
    text:(
        SingleQuoteBoldText
        / ItalicText
        / MarkedText
        / MonospaceText
        / SubscriptText
        / SuperscriptText) {
            return text.(*types.QuotedText).WithAttributes(attributes)
        }

DoubleQuoteBoldTextFallbackCharacter <-
    [^\r\n*] // anything except EOL and bold delimiter (fallback in case nothing else matched)
    / DoubleQuoteBoldTextDelimiter Alphanums {  // or a bold delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

// -------------------------------
// Bold text within single quotes
// -------------------------------
SingleQuoteBoldTextStartDelimiter <- "*"

SingleQuoteBoldTextEndDelimiter <- "*" 

SingleQuoteBoldText <- 
    SingleQuoteBoldTextStartDelimiter
    elements:(SingleQuoteBoldTextElements) 
    SingleQuoteBoldTextEndDelimiter {
        return types.NewQuotedText(types.SingleQuoteBold, elements.([]interface{}))
    } 

SingleQuoteBoldTextElements <-  
    !EOF !Space // cannot start with spaces
    elements:(SingleQuoteBoldTextElement)+ 
    &{
        return validateSingleQuoteElements(elements.([]interface{})) // cannot end with spaces
    }{
        return elements, nil
    }

SingleQuoteBoldTextElement <- 
    BoldTextWord
    / Spaces
    / Newline !Newline // 2 newlines split the paragraph
    / AttributeSubstitution
    / SpecialCharacter
    / Symbol
    / InlineMacro
    / QuotedString
    / QuotedTextInSingleQuoteBoldText
    / ElementPlaceHolder
    / SingleQuoteBoldTextFallbackCharacter

QuotedTextInSingleQuoteBoldText <- 
    attributes:(LongHandAttributes)? 
    text:(
        DoubleQuoteBoldText
        / ItalicText
        / MonospaceText
        / MarkedText
        / SubscriptText
        / SuperscriptText) {
            return text.(*types.QuotedText).WithAttributes(attributes)
        }
SingleQuoteBoldTextFallbackCharacter <-
    [^\r\n *] // anything except EOL, space and bold delimiter (fallback in case nothing else matched)
    / "*" Alphanums {  // or a bold delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

EscapedBoldText <- 
    backslashes:(TwoOrMoreBackslashes) "**" elements:(DoubleQuoteBoldTextElements) "**" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "**", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "**" elements:(SingleQuoteBoldTextElements) "*" { // unbalanced `**` vs `*` punctuation
        result := append([]interface{}{"*"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "*", result)
    } / backslashes:(OneOrMoreBackslashes) "*" elements:(SingleQuoteBoldTextElements) "*" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "*", elements.([]interface{}))
    }

// ---------------------------------------------------------
// Quoted Italic Text
// ---------------------------------------------------------

ItalicText <- DoubleQuoteItalicText / SingleQuoteItalicText

ItalicTextDelimiter <- "_"

ItalicTextWord <- 
    [\pL0-9]+ &(Space / ItalicTextDelimiter) {
        return types.NewStringElement(string(c.text))
    }

// ---------------------------------
// Italic text within double quotes
// ---------------------------------
DoubleQuoteItalicTextDelimiter <- "__"

DoubleQuoteItalicText <- 
    DoubleQuoteItalicTextDelimiter 
    elements:(DoubleQuoteItalicTextElements) 
    DoubleQuoteItalicTextDelimiter { // double punctuation must be evaluated first
        return types.NewQuotedText(types.DoubleQuoteItalic, elements.([]interface{}))
    }

DoubleQuoteItalicTextElements <- DoubleQuoteItalicTextElement+ 

DoubleQuoteItalicTextElement <- 
    !DoubleQuoteItalicTextDelimiter
    element:(
        ItalicTextWord
        / Spaces // may start and end with spaces
        / Newline !Newline // 2 newlines split the paragraph
        / AttributeSubstitution
        / SpecialCharacter
        / Symbol
        / InlineMacro
        / QuotedString
        / QuotedTextInDoubleQuoteItalicText
        / ElementPlaceHolder
        / DoubleQuoteItalicTextFallbackCharacter) {
            return element, nil
        }

QuotedTextInDoubleQuoteItalicText <- 
    attributes:(LongHandAttributes)? 
    text:(SingleQuoteItalicText
        / BoldText
        / MarkedText
        / MonospaceText
        / SubscriptText
        / SuperscriptText) {
            return text.(*types.QuotedText).WithAttributes(attributes)
        }

DoubleQuoteItalicTextFallbackCharacter <-
    [^\r\n_] // anything except EOL and italic delimiter (fallback in case nothing else matched)
    / "__" Alphanums {  // or a italic delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

// ---------------------------------
// Italic text within single quotes
// ---------------------------------
SingleQuoteItalicTextStartDelimiter <- "_" 

SingleQuoteItalicTextEndDelimiter <- "_" 

SingleQuoteItalicText <- 
    SingleQuoteItalicTextStartDelimiter
    elements:(SingleQuoteItalicTextElements) 
    SingleQuoteItalicTextEndDelimiter { 
        return types.NewQuotedText(types.SingleQuoteItalic, elements.([]interface{}))
    } 

SingleQuoteItalicTextElements <- 
    !EOF !Space // cannot start with spaces
    elements:(SingleQuoteItalicTextElement)+
    &{
        return validateSingleQuoteElements(elements.([]interface{})) // cannot end with spaces
    }{
        return elements, nil
    }

SingleQuoteItalicTextElement <- 
    ItalicTextWord
    / Spaces
    / Newline !Newline // 2 newlines split the paragraph
    / AttributeSubstitution
    / SpecialCharacter
    / Symbol
    / InlineMacro
    / QuotedString
    / QuotedTextInSingleQuoteItalicText
    / ElementPlaceHolder
    / SingleQuoteItalicTextFallbackCharacter

QuotedTextInSingleQuoteItalicText <-
    attributes:(LongHandAttributes)? 
    text:(BoldText
        / DoubleQuoteItalicText
        / MarkedText
        / MonospaceText
        / SubscriptText
        / SuperscriptText) {
            return text.(*types.QuotedText).WithAttributes(attributes)
        }

SingleQuoteItalicTextFallbackCharacter <-
    [^\r\n _] // anything except EOL, space and italic delimiter (fallback in case nothing else matched)
    / "_" Alphanums {  // or an italic delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

EscapedItalicText <- 
    backslashes:(TwoOrMoreBackslashes) "__" elements:(DoubleQuoteItalicTextElements) "__" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "__", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "__" elements:(SingleQuoteItalicTextElements) "_" { // unbalanced `__` vs `_` punctuation
        result := append([]interface{}{"_"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "_", result)
    } / backslashes:(OneOrMoreBackslashes) "_" elements:(SingleQuoteItalicTextElements) "_" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "_", elements.([]interface{}))
    } 

// ------------------------------------------------------------------
// Quoted Monospace Text
// ------------------------------------------------------------------
MonospaceText <- DoubleQuoteMonospaceText / SingleQuoteMonospaceText

MonospaceTextDelimiter <- "`"

MonospaceTextWord <- 
    [\pL0-9]+ &(Space / MonospaceTextDelimiter) {
        return types.NewStringElement(string(c.text))
    }

// ------------------------------------
// Monospace text within double quotes
// ------------------------------------
DoubleQuoteMonospaceTextDelimiter <- "``"

DoubleQuoteMonospaceText <- 
    DoubleQuoteMonospaceTextDelimiter 
    elements:(DoubleQuoteMonospaceTextElements) 
    DoubleQuoteMonospaceTextDelimiter { 
        return types.NewQuotedText(types.DoubleQuoteMonospace, elements.([]interface{}))
    }

DoubleQuoteMonospaceTextElements <- DoubleQuoteMonospaceTextElement+ // may start and end with spaces

DoubleQuoteMonospaceTextElement <- 
    !DoubleQuoteMonospaceTextDelimiter
    element:(
        MonospaceTextWord
        / Spaces // may start and end with spaces
        / Newline !Newline // 2 newlines split the paragraph
        / AttributeSubstitution
        / SpecialCharacter
        / Symbol
        / InlineMacro
        / QuotedString
        / RawApostrophe // must be before SingleQuoteMonospaceText
        / QuotedTextInDoubleQuoteMonospaceText
        / ElementPlaceHolder
        / DoubleQuoteMonospaceTextFallbackCharacter) {
            return element, nil
        }

QuotedTextInDoubleQuoteMonospaceText <-
    attributes:(LongHandAttributes)? 
    text:(
        SingleQuoteMonospaceText
        / BoldText
        / ItalicText
        / MarkedText
        / SubscriptText
        / SuperscriptText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }

DoubleQuoteMonospaceTextFallbackCharacter <-
    [^\r\n`] // anything except EOL and monospace delimiter (fallback in case nothing else matched)
    / "``" Alphanums {  // ` or a monospace delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

// ------------------------------------
// Monospace text within single quotes
// ------------------------------------

// need to distinguish start vs end because of quoted string which also use the same "`"
SingleQuoteMonospaceTextStartDelimiter <- "`" 

SingleQuoteMonospaceTextEndDelimiter <- "`" 

SingleQuoteMonospaceText <- 
    SingleQuoteMonospaceTextStartDelimiter 
    elements:(SingleQuoteMonospaceTextElements) 
    SingleQuoteMonospaceTextEndDelimiter { 
        return types.NewQuotedText(types.SingleQuoteMonospace, elements.([]interface{}))
    } 

SingleQuoteMonospaceTextElements <- 
    !EOF !Space // cannot start with spaces
    elements:(SingleQuoteMonospaceTextElement)+
    &{
        return validateSingleQuoteElements(elements.([]interface{})) // cannot end with spaces
    }{
        return elements, nil
    }

SingleQuoteMonospaceTextElement <-  
    Word
    / Spaces 
    / Newline !Newline // 2 newlines split the paragraph
    / AttributeSubstitution
    / SpecialCharacter
    / Symbol
    / InlineMacro
    / QuotedString
    / QuotedTextInSingleQuoteMonospaceText
    / RawApostrophe
    / ElementPlaceHolder
    / SingleQuoteMonospaceTextFallbackCharacter

QuotedTextInSingleQuoteMonospaceText <-
    attributes:(LongHandAttributes)? 
    text:(
        DoubleQuoteMonospaceText
        / BoldText
        / ItalicText
        / MarkedText
        / SubscriptText
        / SuperscriptText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }

SingleQuoteMonospaceTextFallbackCharacter <-
    ([^\r\n` ] // ` anything except EOL, space and monospace delimiter (fallback in case nothing else matched)
    / MonospaceTextDelimiter Alphanums) {  // or an monospace delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

EscapedMonospaceText <- 
    backslashes:(TwoOrMoreBackslashes) "``" elements:(DoubleQuoteMonospaceTextElements) "``" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "``", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "``" elements:(SingleQuoteMonospaceTextElements) "`" { // unbalanced "``" vs "`" punctuation
        result := append([]interface{}{"`"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "`", result)
    } / backslashes:(OneOrMoreBackslashes) "`" elements:(SingleQuoteMonospaceTextElements) "`" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "`", elements.([]interface{}))
    }

// ---------------------------------------------------------
// Quoted Marked Text
// ---------------------------------------------------------
MarkedText <- DoubleQuoteMarkedText / SingleQuoteMarkedText

MarkedTextDelimiter <- "#"

MarkedTextWord <- 
    [\pL0-9,?!;]+ &(Space / MarkedTextDelimiter) {
        return types.NewStringElement(string(c.text))
    }

// ------------------------------------
// Marked text within double quotes
// ------------------------------------
DoubleQuoteMarkedTextDelimiter <- "##"

DoubleQuoteMarkedText <- 
    DoubleQuoteMarkedTextDelimiter 
    elements:(DoubleQuoteMarkedTextElements) 
    DoubleQuoteMarkedTextDelimiter { 
        return types.NewQuotedText(types.DoubleQuoteMarked, elements.([]interface{}))
    }

DoubleQuoteMarkedTextElements <- DoubleQuoteMarkedTextElement*

DoubleQuoteMarkedTextElement <- // may start and end with spaces
    !DoubleQuoteMarkedTextDelimiter
    element:(
        MarkedTextWord
        / Spaces // may start and end with spaces
        / Newline !Newline // 2 newlines split the paragraph
        / AttributeSubstitution
        / SpecialCharacter
        / Symbol
        / InlineMacro
        / QuotedString
        / QuotedTextInDoubleMarkedBoldText
        / ElementPlaceHolder
        / DoubleQuoteMarkedTextFallbackCharacter
    ) {
        return element, nil
    }

QuotedTextInDoubleMarkedBoldText <-
    attributes:(LongHandAttributes)? 
    text:(
        SingleQuoteMarkedText
        / BoldText
        / ItalicText
        / MonospaceText
        / SubscriptText
        / SuperscriptText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }

DoubleQuoteMarkedTextFallbackCharacter <-
    [^\r\n#] // anything except EOL and marked delimiter (fallback in case nothing else matched)
    / DoubleQuoteMarkedTextDelimiter Alphanums {  // or a marked delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

// ------------------------------------
// Marked text within single quotes
// ------------------------------------
SingleQuoteMarkedTextStartDelimiter <- "#"

SingleQuoteMarkedTextEndDelimiter <- "#" 

SingleQuoteMarkedText <- 
    SingleQuoteMarkedTextStartDelimiter
    elements:(SingleQuoteMarkedTextElements) 
    SingleQuoteMarkedTextEndDelimiter { 
        return types.NewQuotedText(types.SingleQuoteMarked, elements.([]interface{}))
    } 

SingleQuoteMarkedTextElements <- 
    !EOF !Space // cannot start with spaces
    elements:(SingleQuoteMarkedTextElement)+ 
    &{
        return validateSingleQuoteElements(elements.([]interface{})) // cannot end with spaces
    }{
        return elements, nil
    }

SingleQuoteMarkedTextElement <- 
    MarkedTextWord
    / Spaces
    / Newline !Newline // 2 newlines split the paragraph
    / AttributeSubstitution
    / SpecialCharacter
    / Symbol
    / InlineMacro
    / QuotedString
    / QuotedTextInSingleQuoteMarkedText
    / ElementPlaceHolder
    / SingleQuoteMarkedTextFallbackCharacter

QuotedTextInSingleQuoteMarkedText <-
    attributes:(LongHandAttributes)? 
    text:(
        DoubleQuoteMarkedText
        / BoldText
        / ItalicText
        / MonospaceText
        / SubscriptText
        / SuperscriptText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }

SingleQuoteMarkedTextFallbackCharacter <-
    [^\r\n #] // anything except EOL, space and mark delimiter (fallback in case nothing else matched)
    / "#" Alphanums {  // or a mark delimiter when immediately followed by an alphanum (ie, in the middle of some text)
        return types.NewStringElement(string(c.text))
    }

EscapedMarkedText <-
    backslashes:(TwoOrMoreBackslashes) "##" elements:(DoubleQuoteMarkedTextElements) "##" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "##", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "##" elements:(SingleQuoteMarkedTextElements) "#" { // unbalanced `##` vs `#` punctuation
        result := append([]interface{}{"#"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "#", result)
    } / backslashes:(OneOrMoreBackslashes) "#" elements:(SingleQuoteMarkedTextElements) "#" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "#", elements.([]interface{}))
    }

// ---------------------------------------------------------------
// Quoted Subscript Text
// ---------------------------------------------------------------
SubscriptText <- 
    SubscriptTextDelimiter
    element:(SubscriptTextElement)
    SubscriptTextDelimiter { // wraps a single word
        return types.NewQuotedText(types.SingleQuoteSubscript, element)
    }

SubscriptTextDelimiter <- "~"

SubscriptTextElement <- QuotedText / NonSubscriptText 

NonSubscriptText <- [^\r\n ~]+ { // anything except spaces, EOL or '~'
        return c.text, nil
    }

EscapedSubscriptText <- 
    backslashes:(OneOrMoreBackslashes) 
    SubscriptTextDelimiter 
    element:(SubscriptTextElement)
    SubscriptTextDelimiter { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "~", element)
    } 

// -----------------------
// Quoted Superscript Text
// -----------------------
SuperscriptText <- 
    SuperscriptTextDelimiter 
    element:(SuperscriptTextElement) 
    SuperscriptTextDelimiter { // wraps a single word
        return types.NewQuotedText(types.SingleQuoteSuperscript, element)
    }

SuperscriptTextDelimiter <- "^"

SuperscriptTextElement <- QuotedText / NonSuperscriptText 

NonSuperscriptText <- [^\r\n ^]+ { // anything except spaces, EOL or '^'
        return c.text, nil
    }

EscapedSuperscriptText <- 
    backslashes:(OneOrMoreBackslashes) 
    SuperscriptTextDelimiter 
    element:(SuperscriptTextElement) 
    SuperscriptTextDelimiter { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "^", element)
    } 

// -------------------------------------------------------------------------------------------------
// Quoted Strings (between curly single or double quotes)
// -------------------------------------------------------------------------------------------------

QuotedString <- SingleQuotedString / DoubleQuotedString

SingleQuotedString <- 
    SingleQuoteStringStart 
    elements:SingleQuotedStringElements 
    SingleQuoteStringEnd {
        return types.NewQuotedString(types.SingleQuote, elements.([]interface{}))
    }

SingleQuotedStringElements <- 
    elements:(SingleQuotedStringElement)+ {
        c.resetSpaceSuffixTracking()
        return types.NewInlineElements(elements)
    }

SingleQuoteStringStart <- "'`" ![ \t\r\n]

SingleQuoteStringEnd <- "`'"

QuotedStringWord <- [\pL0-9]+ &(Space / SingleQuoteStringEnd) {
        return types.NewStringElement(string(c.text))
    }

// We have to treat this one special, because of ambiguity with monospace markup.
SingleQuotedStringElement <- 
    !SingleQuoteStringEnd
    element:(
        QuotedStringWord
        / Space !SingleQuoteStringEnd
        / Newline !Newline // 2 newlines split the paragraph
        / AttributeSubstitution
        / SpecialCharacter
        / InlineMacro
        / LineBreak !SingleQuoteStringEnd
        / Symbol
        / QuotedTextInSingleQuotedString
        / DoubleQuotedString
        / SingleQuotedStringFallbackCharacter
    ) {
        c.trackSpaceSuffix(element)
        return element, nil
    }

QuotedTextInSingleQuotedString <-
    attributes:(LongHandAttributes)? 
    text:(BoldText
        / ItalicText
        / (!"`'" element:(MonospaceText) { return element, nil})
        / SubscriptText
        / SuperscriptText
        / MarkedText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }

SingleQuotedStringFallbackCharacter <-  [^\r\n\t `] / "`" !"'" { // '
        return types.NewStringElement(string(c.text))
    }

DoubleQuotedString <- DoubleQuoteStringStart elements:DoubleQuotedStringElements DoubleQuoteStringEnd {
        return types.NewQuotedString(types.DoubleQuote, elements.([]interface{}))
    }

DoubleQuotedStringElements <- elements:(DoubleQuotedStringElement+) {
        c.resetSpaceSuffixTracking()
        return types.NewInlineElements(elements)
    }

// We have to treat this one special, because of ambiguity with monospace markup.
DoubleQuotedStringElement <- 
    !DoubleQuoteStringEnd
    element:(
        QuotedStringWord
        / Space !DoubleQuoteStringEnd
        / Newline !Newline // 2 newlines split the paragraph
        / LineBreak !SingleQuoteStringEnd 
        / AttributeSubstitution
        / SpecialCharacter
        / InlineMacro
        / QuotedTextInDoubleQuotedString
        / SingleQuotedString
        / DoubleQuotedStringFallbackCharacter) {
            c.trackSpaceSuffix(element)
            return element, nil
        }

QuotedTextInDoubleQuotedString <-
    attributes:(LongHandAttributes)? 
    text:(
        BoldText
        / ItalicText
        / (!"`\"" element:(MonospaceText) { return element, nil})
        / SubscriptText
        / SuperscriptText
        / MarkedText) {
             return text.(*types.QuotedText).WithAttributes(attributes)
        }

DoubleQuoteStringStart <- "\"`" ![ \t\r\n]

DoubleQuoteStringEnd <- "`\""

DoubleQuotedStringFallbackCharacter <-  ([^\r\n\t `] / "`" !"\"") {
        return types.NewStringElement(string(c.text))
    }

// -------------------------------------------------------------------------------------
// Sections
// -------------------------------------------------------------------------------------
// we need to identify section titles to properly handle file inclusions with level offsets
Section <- 
    &{  
        return !c.isWithinDelimitedBlock(), nil
    }
    level:(("=")+ {   
        // `=` is level 0, `==` is level 1, etc.
        return (len(c.text)-1), nil 
    })
    &{  
        // use a predicate to make sure that only `=` (level 0) to `======` (level 5) are allowed
        return level.(int) <= 5, nil 
    } 
    Spaces title:(SectionTitle) EOL {
        return types.NewSection(level.(int), title.([]interface{})) 
    }

SectionTitle <- [^\r\n]+ { // can't have empty title, that may collide with example block delimiter (`====`)
    return []interface{}{
        types.RawLine(c.text),
    }, nil 
}

// -------------------------------------------------------------------------------------
// Substitutions
// -------------------------------------------------------------------------------------

// Substitution group for 'attributes' only
AttributesGroup <- elements:(
    Alphanums
    / Space
    / SpecialCharacter
    / Quote
    / InlinePassthrough
    / AttributeSubstitution
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.NewInlineElements(elements)
    }

// Substitution group element attributes
ElementAttributesGroup <- elements:(
    InlineWord
    / Space
    / AttributeSubstitution
    / Quote
    / SpecialCharacter
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.NewInlineElements(elements)
    }

// Default substitutions for Section Titles
HeaderGroup <- 
    elements:(HeaderGroupElement)+ EOF { 
        return types.NewInlineElements(elements)
    }

HeaderGroupElement <-
    !EOF
    element:(
        InlineWord
        / Space
        / InlinePassthrough
        / SpecialCharacter
        / Quote
        / Link
        / InlineIcon
        / AttributeSubstitution
        / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
        / Replacement
        / ShortHandAnchor
        / InlineFootnote
        / AnyChar) {
            return element, nil
        }

// Substitution group for 'macros' only
MacrosGroup <- elements:(
    InlineWord
    / InlineMacro
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.NewInlineElements(elements)
    }

// TODO: do we really need a grammar rule? can't we just skip substitutions?
// The 'none' substitution
NoneGroup <- elements:(NoneGroupElement)+ EOF { 
        return types.NewInlineElements(elements)
    }

NoneGroupElement <- 
    !EOF
    element:(
        InlineWord
        / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
        / AnyChar)+ EOF { 
            return element, nil
        }

// Default substitutions for Paragrapghs
// TODO: extract the substitutionContext once and check every rule choice here. Will also avoid setting "fake" context for BlockAttributes, SectionTitle, etc.
NormalGroup <- 
    elements:(NormalGroupElement)+ EOF { 
        c.resetSpaceSuffixTracking()
        return types.NewInlineElements(elements)
    }

NormalGroupElement <- 
    !EOF
    element:(
        InlineWord
        / Space
        / Newline
        / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
        / LineBreak 
        / Punctuation
        / Quote
        / InlinePassthrough
        / InlineMacro // must be before 'specialcharacter' (because of 'crossreference')
        / SpecialCharacter
        / AttributeSubstitution
        / Symbol
        / AnyChar) {
            c.trackSpaceSuffix(element)
            return element, nil
        }
PostReplacementsGroup <-  
    elements:(PostReplacementsGroupElement)+ EOF {
        c.resetSpaceSuffixTracking()
        return types.NewInlineElements(elements)
    }

PostReplacementsGroupElement <- 
    !EOF
    element:(
        InlineWord
        / Space
        / LineBreak
        / Newline
        / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
        / AnyChar) {
            c.trackSpaceSuffix(element)
            return element, nil
        }

// Substitution group for 'quotes' only
QuotesGroup <- elements:(
    InlineWord
    / Quote
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.NewInlineElements(elements)
    }

// Substitution group for 'replacements' only
ReplacementsGroup <- elements:(
    InlineWord
    / Replacement
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.NewInlineElements(elements)
    }

// Substitution group for 'specialcharacters' (or 'specialchars') only
SpecialCharactersGroup <- elements:(
    InlineWord
    / SpecialCharacter
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.NewInlineElements(elements)
    }

VerbatimGroup <- elements:(
    InlineWord
    / Callout // must be placed before SpecialCharacter
    / SpecialCharacter
    / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
    / AnyChar)+ EOF { 
        return types.NewInlineElements(elements)
    }
    
InlineMacro <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Macros)
    }
    element:(
        InlineIcon
        / InlineImage 
        / Link 
        / InlinePassthrough 
        / InlineFootnote 
        / CrossReference 
        / InlineUserMacro 
        / InlineElementID
        / ConcealedIndexTerm
        / IndexTerm
        / InlineUserMacro) {
            return element, nil
        }

InlinePassthrough <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(InlinePassthroughs)
    }
    element:(
        TriplePlusPassthrough / SinglePlusPassthrough / PassthroughMacro
    ) {
        return element, nil
    }

Quote <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Quotes)
    }
    element:(
        QuotedText 
        / QuotedString) {
            return element, nil
        }

Replacement <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Replacements)
    }
    element:(
        Symbol
    ) {
        return element, nil
    }

SpecialCharacter <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(SpecialCharacters)
    }
    element:(
        // if we have a InternalCrossReference we just return a StringElement. 
        InternalCrossReference {
            return types.NewStringElement(string(c.text))
        } 
        / ("<" / ">" / "&" ) {
            return types.NewSpecialCharacter(string(c.text))
        }) {
            return element, nil
        }

// -------------------------------------------------------------------------------------
// Single Line Comment
// -------------------------------------------------------------------------------------
SingleLineComment <- SingleLineCommentDelimiter content:(SingleLineCommentContent) EOL {
        return types.NewSingleLineComment(content.(string))
    }

// can be `//` but not `////` (comment block delimiter)
SingleLineCommentDelimiter <- "//" !"//" 

SingleLineCommentContent <- [^\r\n]* {
        return string(c.text), nil
    }

// -------------------------------------------------------------------------------------
// Symbols
// -------------------------------------------------------------------------------------
Symbol <- Apostrophe / Copyright / Trademark / Registered / Ellipsis / ImpliedApostrophe

Apostrophe <- "`'" {
        return types.NewStringElement("\u2019")
    }

RawApostrophe <- "`'" // no conversion

Copyright <- "(C)" {
        return types.NewStringElement("\u00a9")
    }

Trademark <- "(TM)" {
        return types.NewStringElement("\u2122")
    }

Registered <- "(R)" {
        return types.NewStringElement("\u00ae")
    }

Ellipsis <- "..." {
        return types.NewStringElement("\u2026\u200b")
    }

// The implied apostrophe is used in interior words, and intended to help
// cases like "mother's day".  asciidoctor requires that it be followed by
// a letter (not a digit) but it can have a digit just before it.

ImpliedApostrophe <- Alphanum "'" &[\pL] {
        return types.NewStringElement(string(c.text[:1])+"\u2019")
    }

// -------------------------------------------------------------------------------------
// Tables
// -------------------------------------------------------------------------------------
Table <- 
    TableStartDelimiter
    header:(TableHeader)?
    rows:(TableRow)*
    TableEndDelimiter {
        return types.NewTable(header, rows.([]interface{}))
    }


TableDelimiter <- "|===" Space* EOL 

TableStartDelimiter <- TableDelimiter

TableEndDelimiter <- TableDelimiter / EOF

TableHeader <- 
    // header cells MUST be on the same line
    cells:(HeaderCell)+ EOL
    BlankLine+ {
        return types.NewTableRow(cells.([]interface{}))
    }

HeaderCell <- 
    "|" Space* 
    content:(CellContent?) {
        return types.NewTableCell(content.(types.RawContent))
    }

TableRow <- MultiLineTableRow / SingleLineTableRow

SingleLineTableRow <- 
    !TableEndDelimiter
    cells:(TableCell)+ EOL
    BlankLine* {
        return types.NewTableRow(cells.([]interface{}))
    }

MultiLineTableRow <- 
    !TableEndDelimiter
    cells:(cell:(TableCell) EOL {
        return cell, nil
    })+ 
    (BlankLine+ / &TableEndDelimiter) // last series of cells may not be followed by a blankline
    {
        return types.NewTableRow(cells.([]interface{}))
    }

TableCell <- 
    !TableEndDelimiter
    !BlankLine
    "|" Space* content:(CellContent?) // TODO: also support cell styles
    {
        return types.NewTableCell(content.(types.RawContent))
    }

CellContent <- 
    content:([^\r\n|]+ {
        return string(c.text), nil
    }) {
        return types.NewRawContent(content.(string))
    }

// rule for the optional `cols` attribute on a Table
TableColumnsAttribute <- cols:(Column)* EOF {
        return cols, nil
    }

Column <- 
    !EOF
    // TODO: `multiplier` and `weight` with multiple digits and max values
    // TODO: also support column styles
    multiplier:(n:Integer "*" { return n, nil })?
    halign:(
        "<" { return types.HAlignLeft, nil }
        / ">" { return types.HAlignRight, nil }
        / "^" { return types.HAlignCenter, nil }
    )?
    valign:(
        ".<" { return types.VAlignTop, nil }
        / ".>" { return types.VAlignBottom, nil }
        / ".^" { return types.VAlignMiddle, nil }
    )?
    weight:(Integer / ("~" { return string(c.text), nil }))?
    style:([adehlms] { return string(c.text), nil })?
    // style:(("a" / "e" / "h" / "l" / "m" / "s") { return string(c.text), nil })?
    comma:(",")?
    &{
        // make sure that at least something was set
        // (otherwise the parser will run indefinitely)
        return multiplier != nil ||
            halign != nil ||
            valign != nil ||
            weight != nil ||
            style != nil ||
            comma != nil, nil
    }
    {
        return types.NewTableColumn(multiplier, halign, valign, weight, style)
    }

// -------------------------------------------------------------------------------------
// Thematic break
// -------------------------------------------------------------------------------------
ThematicBreak <- (
        "'''" // Asciidoc flavour
        / "***" / "* * *" / "---" / "- - -" / "___" / "_ _ _" // Markdown flavours are supported, too
        ) Space* EOL EOL { 
        return types.NewThematicBreak()
    }

// -------------------------------------------------------------------------------------
// User Macro
// -------------------------------------------------------------------------------------
UserMacroBlock <- 
    name:(UserMacroName) 
    &{
        // skip if no macro was registered under the given name 
      return c.globalStore.hasUserMacro(name.(string)), nil  
    }
    "::" 
    value:(UserMacroValue) 
    attributes:(InlineAttributes) EOL {
        return types.NewUserMacroBlock(name.(string), value.(string), attributes.(types.Attributes), string(c.text))
    }

InlineUserMacro <- 
    name:(UserMacroName) 
    &{
        // skip if no macro was registered under the given name 
      return c.globalStore.hasUserMacro(name.(string)), nil  
    }
    ":" 
    value:(UserMacroValue) 
    attributes:(InlineAttributes) {
        return types.NewInlineUserMacro(name.(string), value.(string), attributes.(types.Attributes), string(c.text))
    }

UserMacroName <- ([\pL0-9_-]+) {
        return string(c.text), nil
    }

UserMacroValue <- [^:[ \r\n]* {
        return string(c.text), nil
    }

// -------------------------------------------------------------------------------------
// Base Types
// -------------------------------------------------------------------------------------
Alphanum <- [\pL0-9]

Parenthesis <- "(" / ")" / "[" / "]" / "{" / "}" 

Alphanums <- [\pL0-9]+ {
        return string(c.text), nil
    }

Word <-
    // very straightforward content: alphanums followed by attached single quote delimiter and more characters 
    // (in this case, the quoted text delimiters are intepreted as regular characters)
    // then followed by spaces but not the "+" signs because it needs a heading space to become a LineBreak element
    [\pL0-9]+ &([\r\n ,\]] / EOF) {
        return types.NewStringElement(string(c.text))
    } / [\pL0-9]+ ([=*_`] [\pL0-9]+)+ {  // allow `
        return types.NewStringElement(string(c.text))
    }

InlineWord <- 
    [\pL0-9,;!?]+ // TODO: support `_` and `-` ?
    (Space / &("." / ElementPlaceHolderDelimiter / EOL)) {
        return types.NewStringElement(string(c.text))
    }


Punctuation <- ("." / "," / ";" / "!" / "?") &(Space / EOL) {
    return string(c.text), nil
}

// this is a fall-back rule in case all preceeding rules failed to match the current content.
// AnyChar <- [^\r\n] { 
AnyChar <- . { 
        return types.NewStringElement(string(c.text))
    } 

FileLocation <- path:(Filename / ElementPlaceHolder)+ {
        return types.NewLocation("", path.([]interface{}))
    }

Location <- scheme:(Scheme)? path:(Filename / ElementPlaceHolder)+ {
        return types.NewLocation(scheme, path.([]interface{}))
    }

LocationWithScheme <- !"[" scheme:(Scheme) path:(Filename / ElementPlaceHolder)+ {
        return types.NewLocation(scheme, path.([]interface{}))
    }

Filename <- elements:(
    ([^\r\n[\]\uFFFD&<>{ ])+ { // not supported for now: EOL, space, "{", "[", "]"
        return types.NewStringElement(string(c.text))
    }
    / AttributeSubstitution 
    / SpecialCharacter
    / "{" {
        return types.NewStringElement(string(c.text))
    })+ {
        return types.NewInlineElements(elements.([]interface{}))
    }

Scheme <- "http://" / "https://" / "ftp://" / "irc://" / "mailto:"

Id <- [^[\]<>,]+ { // previously: (Alphanums / (!Newline !Space !"[" !"]" !"<<" !">>" !","  .))+
        return string(c.text), nil
    }

Number <- Float
    / Integer

Integer <- ("-"? [0-9]+) {
        return strconv.Atoi(string(c.text))
    }

Float <- ("-"? [0-9]+ "." [0-9]+) {
        return strconv.ParseFloat(string(c.text), 64)
    }

Space <- (" " / "\t") {
        return string(c.text), nil
    }

Spaces <- (" " / "\t")+ {
        // log.Debug("matched multiple spaces")
        return string(c.text), nil
    }

Newline <- ("\n" / "\r\n" / "\r") { // TODO: just use "\n" 
    return string(c.text), nil
}

EOF <- !.

// TODO: remove and use `EOF` instead?
EOL <- Newline / EOF