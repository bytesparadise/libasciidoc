{
package parser 

import (
    "io"
    "strconv"
    "strings"
    "unicode"
    "github.com/bytesparadise/libasciidoc/pkg/types"
)

}

// ----------------------------------------------------------------
// RawSource - source with file inclusions or just plain text
// ----------------------------------------------------------------
RawSource <- lines:(AttributeDeclaration / RawSection / FileInclusion / RawLine)* {
    return lines.([]interface{}), nil
}

// we need to identify section titles to properly handle file inclusions with level offsets
RawSection <- 
    level:(("=")+ {   
        // `=` is level 0, etc.
        return (len(c.text)-1), nil 
    })
    &{  
        // use a predicate to make sure that only `=` (level 0) to `======` (level 5) are allowed
        return level.(int) <= 5, nil 
    } 
    Space+ title:(RawSectionTitle) EOL {
    return types.NewRawSection(level.(int), title.(string)) 
}

RawSectionTitle <- [^\r\n]* { 
    return string(c.text), nil 
}

RawLine <- !EOF content:([^\r\n]* { 
        return string(c.text), nil 
    }) EOL { // line MAY have content
        return types.NewRawLine(content.(string))
    }

// ----------------------------------------------------------------
// RawDocument - fully parsed document with raw blocks
// ----------------------------------------------------------------
RawDocument <- frontmatter:(FrontMatter?) blocks:(RawBlocks) EOF {
    return types.NewRawDocument(frontmatter, blocks.([]interface{}))
}

// ------------------------------------------
// Document blocks
// ------------------------------------------
RawBlocks <- Newline* header:(DocumentHeader?) blocks:(DocumentRawBlock*) {
    if header != nil && blocks != nil {
        return append([]interface{}{header}, blocks.([]interface{})...), nil
    } else if blocks != nil {
        return blocks.([]interface{}), nil
    }
    return []interface{}{}, nil
}

DocumentRawBlock <- 
        LabeledListItem // must appear before simple paragraph
        / ImageBlock
        / SimpleRawParagraph
        / BlankLine // must be before LiteralBlock 
        / Section
        / DelimitedBlock
        / SingleLineComment
        / Table
        / ThematicBreak
        / OrderedListItem
        / UnorderedListItem 
        / CalloutListItem
        / ContinuedListItemElement
        / LiteralBlock 
        / AttributeDeclaration 
        / AttributeReset 
        / TableOfContentsPlaceHolder
        / UserMacroBlock
        / RawParagraph
        / StandaloneAttributes

// ------------------------------------------
// Front Matter
// ------------------------------------------
FrontMatter <- YamlFrontMatter 

YamlFrontMatter <- YamlFrontMatterToken content:(YamlFrontMatterContent)? YamlFrontMatterToken {
    return types.NewYamlFrontMatter(content.(string))
}

YamlFrontMatterToken  <- "---" Space* EOL

YamlFrontMatterContent <- ((!YamlFrontMatterToken .)+)* {
    return string(c.text), nil
}

// ------------------------------------------
// Document Header and Metadata
// ------------------------------------------
DocumentHeader <- "=" Space+ title:(TitleElements) id:(InlineElementID*) EOL
        (Space* SingleLineComment / CommentBlock)*
        authors:(DocumentAuthors?) 
        (Space* SingleLineComment / CommentBlock)*
        revision:(DocumentRevision?) {
    return types.NewDocumentHeader(title.([]interface{}), authors, revision)
}

DocumentAuthors <- DocumentAuthorsInlineForm / DocumentAuthorsAttributeForm

DocumentAuthorsInlineForm <- Space* !":" authors:(DocumentAuthor+) EOL {
    return types.NewDocumentAuthors(authors.([]interface{}))
}

DocumentAuthorsAttributeForm <- Space* ":author:" author:(DocumentAuthor) EOL {
    return []types.DocumentAuthor{author.(types.DocumentAuthor)}, nil
}

DocumentAuthor <- Space* fullname:(DocumentAuthorName) email:(DocumentAuthorEmail)? Space* ";"? Space* {
    return types.NewDocumentAuthor(fullname, email)
}

// "<" marks the beginning of the author email, and ";" is the authors separator
DocumentAuthorName <- [^<;\r\n]+ {
    return string(c.text), nil
}

DocumentAuthorEmail <- "<" email:(([^>\r\n]+) {
    return string(c.text), nil
}) ">" {
    return email, nil
}

// see http://asciidoctor.org/docs/user-manual/#revision-number-date-and-remark
// Eg: "v1.0, October 2, 2013: First incarnation"
DocumentRevision <- Space* !":" revision:(
        (revnumber:(DocumentRevisionNumber) ","? revdate:(DocumentRevisionDate)? ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(revnumber, revdate, revremark)
        }) / (revdate:(DocumentRevisionDate) ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(nil, revdate, revremark)
        })) EOL {
    return revision, nil
}

// DocumentRevisionNumber MUST start with a `v` or MAY start with a `v` but MUST end with a `,`
DocumentRevisionNumber <- "v"i DIGIT  [^:,\r\n]+ {
    return string(c.text), nil
} / "v"i? DIGIT  [^:,\r\n]+ Space* &"," {
    return string(c.text), nil
}

DocumentRevisionDate <- [^:\r\n]+ {
    return string(c.text), nil
}

DocumentRevisionRemark <- [^\r\r\n]+ {
    return string(c.text), nil
}

// ------------------------------------------
// Attributes
// ------------------------------------------
AttributeDeclaration <- ":" name:(AttributeName) ":" 
        value:((Space+ value:(AttributeDeclarationValue)) { 
            return value, nil 
        })? Space* EOL {
    return types.NewAttributeDeclaration(name.(string), value)
} 

// AttributeName must be at least one character long, 
// must begin with a word character (A-Z, a-z, 0-9 or _) and 
// must only contain word Word and hyphens ("-").
AttributeName <- [\pL0-9_] ([\pL0-9-])* {
    return string(c.text), nil
}

AttributeDeclarationValue <- [^\r\n]+ {
    return string(c.text), nil
}

AttributeReset <- ":!" name:(AttributeName) ":" Space* EOL {
    return types.NewAttributeReset(name.(string))
} / ":" name:(AttributeName) "!:" Space* EOL {
    return types.NewAttributeReset(name.(string))
}

AttributeSubstitution <- CounterSub / AttrSub

AttrSub <- "{" name:AttributeName "}" {
    return types.NewAttributeSubstitution(name.(string))
}

CounterSub <- CounterSub1 / CounterSub2 / CounterSubAlpha / CounterSubAlpha2 / CounterSubStart / CounterSubStart2

CounterSub1 <- "{counter:" name:AttributeName "}" {
    return types.NewCounterSubstitution(name.(string), false, nil)
}

CounterSub2 <- "{counter2:" name:AttributeName "}" {
    return types.NewCounterSubstitution(name.(string), true, nil)
}

CounterSubAlpha <- "{counter:" name:AttributeName ":" start:[A-Za-z] "}" {
    return types.NewCounterSubstitution(name.(string), false, start)
}

CounterSubAlpha2 <- "{counter2:" name:AttributeName ":" start:[A-Za-z] "}" {
    return types.NewCounterSubstitution(name.(string), true, start)
}

CounterSubStart <- "{counter:" name:AttributeName ":" num:([0-9]+ { return strconv.Atoi(string(c.text)) }) "}" {
    return types.NewCounterSubstitution(name.(string), false, num.(int))
}

CounterSubStart2 <- "{counter2:" name:AttributeName ":" num:([0-9]+ { return strconv.Atoi(string(c.text)) }) "}" {
    return types.NewCounterSubstitution(name.(string), true, num.(int))
}

Attributes <- attrs:(ElementAttribute)+ BlankLine* {
    return types.NewAttributes(attrs.([]interface{}))
}

ElementAttribute <- &("[" / "." ) // skip if the content does not start with one of those characters
    attr:(ElementID / 
        ElementTitle / 
        ElementShortHandAttributes /
        LiteralAttribute / 
        SourceAttributes / 
        QuoteAttributes / 
        VerseAttributes / 
        AdmonitionMarkerAttribute / 
        PassthroughBlockAttribute /
        AttributeGroup) {
    return attr, nil // avoid returning something like `[]interface{}{attr, EOL}`
}

ElementID <- "[[" id:(ID) "]]" Space* EOL {
    return types.NewElementID(id)
}

InlineElementID <- "[[" id:(ID) "]]" Space* { // no EOL here since there can be multiple InlineElementID on the same line
    return types.NewInlineElementID(id.(string))
}

// a title attached to an element, such as a ImageBlock
// a title starts with a single "." followed by the value, without space in-between
ElementTitle <- "." title:(ElementTitleContent) Space* EOL {
    return types.NewElementTitle(title.(string))
}

ElementTitleContent <- [\pL0-9][^\r\n<>]* { // "<" and ">" characters are not allowed as they are used as cross-reference markers
    return string(c.text), nil
}

// These are elements that do not start with a leading positional attribute, except
// perhaps the shorthand attributes.
ElementShortHandAttributes <- "[" attrs:(ShortHandAttr* NamedAttr*) "]" Space* EOL {
    return types.NewElementAttributes(attrs)
}

BlockAttrs <- BlockAttrList / ElementTitle / ElementID

// All blocks have style as their first element, and no block has more than 3 positional elements.
// This allows us to keep the grammar simpler, and use context to determine what the second and third attributes are.
BlockAttrList <- '[' attrs:(BlockAttrStyle? ShortHandAttr* BlockAttrPositional2? BlockAttrPositional3? NamedAttr*) ']' EOL {
    return types.NewElementAttributes(attrs)
}

BlockAttrStyle <- style:PositionalValue {
    return types.NewElementStyle(style)
}

BlockAttrPositional2 <- Space* "," Space* value:PositionalValue? {
    if value != nil {
        return types.NewElementNamedAttr(types.AttrPositional2, value)
    }
    return nil, nil
}

BlockAttrPositional3 <- Space* "," Space* value:PositionalValue? {
    if value != nil {
        return types.NewElementNamedAttr(types.AttrPositional3, value)
    }
    return nil, nil
}

LiteralAttribute <- "[literal]" Space* Newline {
    return types.NewLiteralAttribute()
}

PassthroughBlockAttribute <- "[pass]" Space* Newline {
    return types.NewPassthroughBlockAttribute()
}

// expression for the whole admonition marker, but only retains the actual kind
AdmonitionMarkerAttribute <- "[" k:(AdmonitionKind) "]" Space* EOL {
    return types.NewAdmonitionAttribute(k.(types.AdmonitionKind))
}

// a paragraph or a delimited block may contain source code in a given language
SourceAttributes <- "[source" 
    language:("," attr:(StandaloneAttributeValue)? { return attr, nil })? 
    others:("," attr:(GenericAttribute)? { return attr, nil })* 
    "]" Space* EOL {
    return types.NewSourceAttributes(language, others.([]interface{})...)
}

// one or more attributes. eg: [foo, key1=value1, key2 = value2 , ]
AttributeGroup <- "[" attributes:(GenericAttribute)* "]" Space* EOL {
    return types.NewAttributeGroup(attributes.([]interface{}))
}

GenericAttribute <- GenericAttributeWithValue / GenericAttributeWithoutValue

GenericAttributeWithValue <- key:(AttributeKey) "=" value:(AttributeValue)? ","? Space* { // value is (optionally) set
    return types.NewGenericAttribute(key.(string), value)
}

GenericAttributeWithoutValue <- key:(AttributeKey) ","? Space* { // value is not set
    return types.NewGenericAttribute(key.(string), nil)
}

AttributeKey <- !"quote" !"verse" !"literal" !(Space+) key:([^\r\n=,\]]+) Space* {
    return string(c.text), nil
}

AttributeValue <- value:([^\r\n=,\]]+) { 
    return string(c.text), nil
}

StandaloneAttributeValue <- value:([^\r\n=,\]]+) !"=" { // standalone attribute value cannot be followed by a `=`, otherwise it causes troubles for standalone values (eg: in images)
    return string(c.text), nil
}

QuoteAttributes <- "[quote" Space* ","? author:(QuoteAttribute)? ","? title:(QuoteAttribute)? "]" Space* EOL {
    return types.NewQuoteAttributes("quote", author, title)
}

VerseAttributes <- "[verse" Space* ","? author:(QuoteAttribute)? ","? title:(QuoteAttribute)? "]" Space* EOL {
    return types.NewQuoteAttributes("verse", author.(string), title.(string))
}

QuoteAttribute <- ([^\r\n,\]]*) {
    return string(c.text), nil
}

QuotedTextAttrs <- "[" attrs:(QuotedTextAttrRole? ShortHandAttr* NamedAttr*) "]" {
    return types.NewElementAttributes(attrs)
}

QuotedTextAttrRole <- role:PositionalValue {
    return types.NewElementRole(role)
}

StandaloneAttributes <- attributes:(ElementAttribute)+ BlankLine* { // standalone attributes, i.e., with nothing afterwards
    return types.NewAttributes(attributes)
}

ShortHandAttr <- ShortHandAttrID / ShortHandAttrOption / ShortHandAttrRole

ShortHandAttrOption <- "%" option:ShortHandValue &[,#%.\r\n\]] {
    return types.NewElementOption(option)
}

ShortHandAttrID <- "#" id:ShortHandValue &[,#%.\r\n\]] {
    return types.NewElementID(id)
}

ShortHandAttrRole <- '.' role:ShortHandValue &[,#%.\r\n\]] {
    return types.NewElementRole(role)
}

// PositionalValue is an unnamed attribute.
PositionalValue <- value:ShortHandValue &[,#%.\]] {
    return value, nil
}

InlineVal <- AttrEmpty / AttrValSQ / AttrValDQ / AttrValPosFB

NamedAttrs <- attrs:NamedAttrPair* {
    return types.NewElementAttributes(attrs)
}

NamedAttrPair <- ","? Space* n:NamedAttrKey Space* "=" v:(AttrValDQ / AttrValSQ / AttrValNamedFB) {
    return types.NewElementNamedAttr(n.(string), v.(string))
}

// Empty attribute - this prevents us from assigning an empty string to unspecified positional attributes.
AttrEmpty <- [ \t]* &[,\]] {
    return nil, nil
}

// Single Quoted Attribute Values
// TODO: These values need to be passed through attribute substitution
AttrValSQ <- Space* "'" val:AttrValSQin "'" Space* &[,\]] { return val, nil }

AttrValSQin <- val:( AttrValSQEsc / [^\r\n'\\]+ / `\` )* { return types.NewString(val) }

AttrValSQEsc <- `\'` { return `'`, nil }

// Double Quoted Attribute Values
AttrValDQ <- Space* '"' val:AttrValDQin '"' Space* { return val, nil }

AttrValDQin <- val:( AttrValDQEsc / [^\r\n"\\]+ / `\` )* { return types.NewString(val) }

AttrValDQEsc <- `\"` { return `"`, nil }

// Fallback Positional Attribute Values, must not include equals
AttrValPosFB <- [^,=\r\n\]]* &[,\]] { return strings.TrimSpace(string(c.text)), nil }

// Fallback Named Attribute Value, may include equals
AttrValNamedFB <- [^,\r\n\]]* &[,\]] { return strings.TrimSpace(string(c.text)), nil }

ShortHandValue <- ShortHandValuePlain / AttrValueSingleQuoted / AttrValueDoubleQuoted

// ShortHandValuePlain is sort of like AttrValuePlain, but it also needs to exclude the characters
// used to start a short hand role, id, or option, as well as equals signs.
ShortHandValuePlain <- first:([^,\r\n"' \t.#%=\]] {
       return types.NewStringElement(string(c.text))
    })
    others: (ElementPlaceHolder 
        / ([^ \t,\r\n"'.#%=\]] / [ \t][^ \t,\r\n"'.#%=\]] {
            return types.NewStringElement(string(c.text))
        })
    )* {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

NamedAttr <-( "," Space* )? key:NamedAttrKey Space* "=" Space* value:NamedAttrValue Space* {
    return types.NewElementNamedAttr(key.(string), value)
}

// The spec says attributes have be alphanumeric but does not consider foreign letters.  We are more generous.
NamedAttrKey <- [\pL0-9_][\pL0-9_-]* {
    return string(c.text), nil
}

NamedAttrValue <- AttrValueNone / AttrValueSingleQuoted / AttrValueDoubleQuoted / AttrValuePlain

AttrValuePlain <- [^,\r\n"' \t\]]+ {
    return string(c.text), nil
}

AttrValueSingleQuoted <- "'" elements:(
    ([^'\r\n\uFFFD]+ { 
        return types.NewStringElement(string(c.text))
    }) / ElementPlaceHolder)+ "'" {
        return elements, nil
    }

AttrValueDoubleQuoted <- "\"" elements:(
    ([^"\r\n\uFFFD]+ { 
        return types.NewStringElement(string(c.text))
    }) / ElementPlaceHolder)+ "\"" {
        return elements, nil
    }

// TODO: None is magic word meant to undefine the attribute.  It is unclear what the value of this is.
// For now we just set it to the empty string.  That should have the same effect in practice.
AttrValueNone <- "None" {
    return "", nil
}

// ------------------------------------------
// Sections
// ------------------------------------------
Section <- attributes:(BlockAttrs)*
    level:(("=")+ {   
        // `=` is level 0, etc.
        return (len(c.text)-1), nil 
    })
    &{  
        // use a predicate to make sure that only `=` (level 0) to `======` (level 5) are allowed
        return level.(int) <= 5, nil 
    } 
    Space+ title:(TitleElements) id:(InlineElementID*) EOL {
    return types.NewSection(level.(int), title.([]interface{}), id.([]interface{}), attributes) 
}

TitleElements <- elements:(!Newline !InlineElementID TitleElement)+ { // absorbs heading and trailing spaces
    return types.NewInlineElements(elements.([]interface{}))
} 

TitleElement <- element:(Word
        / LineBreak // must be before spaces
        / Space+ 
        / ElementPlaceHolder
        / AnyChar) {
    return element, nil
}

// ------------------------------------------
// Table of Contents
// ------------------------------------------
TableOfContentsPlaceHolder <- "toc::[]" EOL

// ------------------------------------------
// User Macro
// ------------------------------------------
UserMacroBlock <- name:(UserMacroName) "::" value:(UserMacroValue) attrs:(UserMacroAttributes) {
    return types.NewUserMacroBlock(name.(string), value.(string), attrs, string(c.text))
}

InlineUserMacro <- name:(UserMacroName) ":" value:(UserMacroValue) attrs:(UserMacroAttributes) {
    return types.NewInlineUserMacro(name.(string), value.(string), attrs, string(c.text))
}

UserMacroName <- !"include" ([\pL0-9_-]+) {
    return string(c.text), nil
}

UserMacroValue <- [^:[ \r\n]* {
    return string(c.text), nil
}

UserMacroAttributes <- "[" attrs:(GenericAttribute)* "]" {
    return types.NewAttributes(attrs.([]interface{}))								
}

// ------------------------------------------
// File inclusions
// ------------------------------------------
FileInclusion <- incl:("include::" path:(FileLocation) inlineAttributes:(FileIncludeAttributes) { 
        return types.NewFileInclusion(path.(types.Location), inlineAttributes.(types.Attributes), string(c.text))
    }) Space* EOL {
    return incl.(types.FileInclusion), nil
}

FileIncludeAttributes <- "[" attrs:(LineRangesAttribute / TagRangesAttribute / GenericAttribute)* "]" {
    return types.NewAttributes(attrs.([]interface{}))								
} 

LineRangesAttribute <- "lines=" lines:(LineRangesAttributeValue) ","? { 
    return types.NewLineRangesAttribute(lines)
} 

LineRangesAttributeValue <- value:(MultipleLineRanges // TODO: just have MultipleLineRanges, MultipleQuotedLineRanges and UndefinedLineRange?
        / MultipleQuotedLineRanges 
        / MultiLineRange 
        / MultiLineQuotedRange 
        / SingleLineQuotedRange
        / SingleLineRange 
        / UndefinedLineRange) Space* (&"," / &"]") {
    return value, nil
}

MultipleLineRanges <- first:(MultiLineRange / SingleLineRange) 
    others:(";" other:(MultiLineRange / SingleLineRange) {
        return other, nil
    })+ {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

MultipleQuotedLineRanges <- "\"" first:(MultiLineRange / SingleLineRange) 
    others:("," other:(MultiLineRange / SingleLineRange) {
        return other, nil
    })+ "\"" {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

MultiLineRange <- start:(NUMBER) ".." end:(NUMBER) { // eg: lines=12..14
    return types.NewLineRange(start.(int), end.(int))
} 

MultiLineQuotedRange <- "\"" start:(NUMBER) ".." end:(NUMBER) "\"" { // eg: lines=12..14
    return types.NewLineRange(start.(int), end.(int))
} 

SingleLineRange <- singleline:(NUMBER) { // eg: lines=12
    return types.NewLineRange(singleline.(int), singleline.(int))
}

SingleLineQuotedRange <- "\"" singleline:(NUMBER) "\"" { // eg: lines=12
    return types.NewLineRange(singleline.(int), singleline.(int))
}

UndefinedLineRange <- [^\], ]* {
    return string(c.text), nil
}

TagRangesAttribute <- ("tags=" / "tag=") tags:(TagRangesAttributeValue) ","? { //TODO: check if 'tags'/'tag' is allowed for both single and multiple values
    return types.NewTagRangesAttribute(tags.([]interface{}))
} 

TagRangesAttributeValue <- value:(MultipleTagRanges) Space* (&"," / &"]") {
    return value, nil
}

MultipleTagRanges <- first:(TagRange)
    others:(";" other:(TagRange) {
        return other, nil
    })* {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

TagRange <- tag:(Alphanums / TagWildcard) {
    return types.NewTagRange(tag.(string), true)
} / "!" tag:(Alphanums / TagWildcard) {
    return types.NewTagRange(tag.(string), false)
}

TagWildcard <- stars:(("*")+ {
        return string(c.text), nil
    })
    &{  
        // use a predicate to make sure that only `*` and `**` are allowed
        return len(stars.(string)) <= 2, nil 
    } {
    return stars, nil
}

// ------------------------------------------
// Tag macros in lines of files to include
// ------------------------------------------
IncludedFileLine <- content:(IncludedFileStartTag / IncludedFileEndTag / . {return string(c.text), nil})* EOL {
    return types.NewIncludedFileLine(content.([]interface{}))
}

IncludedFileStartTag <- "tag::" tag:(Alphanums {return string(c.text), nil}) "[]" {
    return types.NewIncludedFileStartTag(tag.(string))
}

IncludedFileEndTag <- "end::" tag:(Alphanums {return string(c.text), nil}) "[]" {
    return types.NewIncludedFileEndTag(tag.(string))
}

// ------------------------------------------
// Lists
// ------------------------------------------
ListParagraph <- comment:(SingleLineComment) {
        return comment, nil
    } / lines:(ListParagraphLine)+ {
        return types.NewParagraph(lines.([]interface{}), nil)
    } 

ListParagraphLine <- !EOF
    !BlankLine 
    !SingleLineComment
    !OrderedListItemPrefix
    !UnorderedListItemPrefix
    !CalloutListItemPrefix
    !ListItemContinuation
    !ElementAttribute
    !BlockDelimiter
    !LabeledListItemPrefix 
    line:(elements:(InlineElement)+ { 
            return types.NewInlineElements(elements.([]interface{}))
        }) EOL { 
        return line, nil
    }

ListItemContinuation <- "+" Space* Newline // there should be something after, so `EOL` is not valid here

ContinuedListItemElement <- ListItemContinuation element:ContinuedListItemContent {
    return types.NewContinuedListItemElement(element) // offset is negative
}

ContinuedListItemContent <- !EOF 
    content:(DelimitedBlock
        / SingleLineComment
        / Table
        / ImageBlock
        / ThematicBreak
        / OrderedListItem 
        / UnorderedListItem 
        / LabeledListItem 
        // / ContinuedListItemElement
        / BlankLine // must be before LiteralBlock
        / LiteralBlock 
        / AttributeDeclaration 
        / AttributeReset 
        / TableOfContentsPlaceHolder
        / UserMacroBlock
        / ContinuedRawParagraph) {
    return content, nil
}

// ------------------------------------------
// Ordered List Items
// ------------------------------------------
OrderedListItem <- attrs:(BlockAttrs)* prefix:(OrderedListItemPrefix) content:(OrderedListItemContent) {
    return types.NewOrderedListItem(prefix.(types.OrderedListItemPrefix), content.([]interface{}), attrs)
}

OrderedListItemPrefix <- 
    Space* prefix:(
        // implicit numbering: "." to "....."
        depth:((".")+ {   
            // `.` is 1, etc.
            return (len(c.text)), nil 
        }) 
        &{  
            // use a predicate to make sure that only `.` to `.....` are allowed
            return depth.(int) <= 5, nil 
        } 
        {
            switch depth.(int){
            case 1:
                return types.NewOrderedListItemPrefix(types.Arabic, 1)
            case 2:
                return types.NewOrderedListItemPrefix(types.LowerAlpha, 2)
            case 3:
                return types.NewOrderedListItemPrefix(types.LowerRoman, 3)
            case 4:
                return types.NewOrderedListItemPrefix(types.UpperAlpha, 4)
            default:
                return types.NewOrderedListItemPrefix(types.UpperRoman, 5)
            }
        }
        // explicit numbering
        / ([0-9])+ "." {  // numbering style: "1."
            return types.NewOrderedListItemPrefix(types.Arabic, 1)
        } / ([a-z]) "." { // numbering style: "a."
            return types.NewOrderedListItemPrefix(types.LowerAlpha, 1)
        } / ([A-Z]) "." { // numbering style: "A."
            return types.NewOrderedListItemPrefix(types.UpperAlpha, 1)
        } / ([a-z])+ ")" { // numbering style: "i)"
            return types.NewOrderedListItemPrefix(types.LowerRoman, 1)
        } / ([A-Z])+ ")" { // numbering style: "I)"
            return types.NewOrderedListItemPrefix(types.UpperRoman, 1)
        }) Space+ {
    return prefix, nil
}

OrderedListItemContent <- elements:(ListParagraph+) {
    return types.NewListItemContent(elements.([]interface{}))
} 

// ------------------------------------------
// Unordered List Items
// ------------------------------------------
UnorderedListItem <- attrs:(BlockAttrs)* prefix:(UnorderedListItemPrefix) checkstyle:(UnorderedListItemCheckStyle)? content:(UnorderedListItemContent) {
    return types.NewUnorderedListItem(prefix.(types.UnorderedListItemPrefix), checkstyle, content.([]interface{}), attrs)
}

UnorderedListItemPrefix <- 
    Space* prefix:((
        // implicit numbering: "*" to "*****" 
        depth:(("*")+ {   
            // `*` is 1, etc.
            return (len(c.text)), nil 
        }) 
        &{  
            // use a predicate to make sure that only `*` to `*****` are allowed
            return depth.(int) <= 5, nil 
        } 
        {
            switch depth.(int){
            case 1:
                return types.NewUnorderedListItemPrefix(types.OneAsterisk, 1)
            case 2:
                return types.NewUnorderedListItemPrefix(types.TwoAsterisks, 2)
            case 3:
                return types.NewUnorderedListItemPrefix(types.ThreeAsterisks, 3)
            case 4:
                return types.NewUnorderedListItemPrefix(types.FourAsterisks, 4)
            default:
                return types.NewUnorderedListItemPrefix(types.FiveAsterisks, 5)
            }
        }) / depth:(("-") {
            return types.NewUnorderedListItemPrefix(types.Dash, 1)
        })) Space+ {
    return prefix, nil
} 

UnorderedListItemCheckStyle <- &"[" style:(
      "[ ]" { return types.Unchecked, nil } 
    / "[*]" { return types.Checked, nil } 
    / "[x]" { return types.Checked, nil }
    ) Space+ {
        return style, nil
    }

UnorderedListItemContent <- elements:(ListParagraph+) { // Another list or a literal paragraph immediately following a list item will be implicitly included in the list item
    return types.NewListItemContent(elements.([]interface{}))
} 

// ------------------------------------------
// Labeled List Items
// ------------------------------------------
LabeledListItem <- attrs:(BlockAttrs)* term:(VerbatimLabeledListItemTerm) separator:(LabeledListItemSeparator) description:(LabeledListItemDescription)? {
    return types.NewLabeledListItem(len(separator.(string)) - 1, term.([]interface{}), description, attrs)
}

LabeledListItemPrefix <- VerbatimLabeledListItemTerm LabeledListItemSeparator

VerbatimLabeledListItemChars <- [^:\r\n]+ / ":" !":"
VerbatimLabeledListItemTerm <- content:( VerbatimLabeledListItemChars + {
    return types.NewStringElement(strings.TrimSpace(string(c.text)))
})  {
    return types.NewInlineElements(content)
}

LabeledListItemTerm <- elements:(!Newline !"::" LabeledListItemTermElement)+ { // rule as an extra entrypoint
    return types.NewInlineElements(elements.([]interface{}))
} 

LabeledListItemTermElement <- element:(Word
        / LineBreak // must appear before spaces
        / Space+ 
        / CrossReference
        / ConcealedIndexTerm
        / IndexTerm
        / InlinePassthrough // must be before the SpecialCharacter rule (because of `+`)
        / InlineIcon
        / InlineImage 
        / Link
        / InlineFootnote
        / QuotedString
        / QuotedText
        / SpecialCharacter
        / Symbol
        / AttributeSubstitution
        / AnyChar ) {
    return element, nil
}

LabeledListItemSeparator <- 
    separator:((":")+ {   
        return string(c.text), nil
    }) 
    &{  
        // use a predicate to make sure that only `::` to `::::` are allowed
        return len(separator.(string)) >= 2 && len(separator.(string)) <= 4, nil 
    } 
    ((Space / Newline)+ / EOL) {
    return separator, nil
}
    
LabeledListItemDescription <- elements:(ListParagraph)+ { 
    return types.NewListItemContent(elements.([]interface{}))
}

// ------------------------------------------
// Admonitions
// ------------------------------------------
AdmonitionKind <- "TIP" {
    return types.Tip, nil
} / "NOTE" {
    return types.Note, nil
} / "IMPORTANT" {
    return types.Important, nil
} / "WARNING" {
    return types.Warning, nil
} / "CAUTION" {
    return types.Caution, nil
}

// ------------------------------------------
// Paragraphs
// ------------------------------------------

// a "raw paragraph" is the intermediate representation of a paragraph (see below),
// but with "raw line", ie, content which has not been substituted yet.
// 
RawParagraph <- 
    // admonition paragraph 
    attributes:(Attributes)? t:(AdmonitionKind) ": " lines:(SingleLineComment / RawParagraphLine)+ { 
        return types.NewAdmonitionParagraph(lines.([]interface{}), t.(types.AdmonitionKind), attributes)
    } / 
    // markdown-style blockquote paragraph
    // TODO: move with other Delimited block rules?
    attributes:(Attributes)? "> " content:(MarkdownQuoteBlockRawContent) {
        return types.NewMarkdownQuoteBlock(content.([]interface{}), attributes)
    } /
    // passthrough open block: requires `[pass]`
    attributes:(Attributes)? &{  
        // verify that one of the attributes is `passthrough`
        if attrs, ok := attributes.(types.Attributes); ok {
            kind, exists := attrs[types.AttrKind]
            return exists && kind == types.Passthrough, nil
        }
        return false, nil
    } content:(RawParagraphLine)+ { 
        return types.NewPassthroughBlock(content.([]interface{}), attributes)
    } /
    // other kind of paragraph (verse, regular, etc.)
    attributes:(Attributes)?  lines:(SingleLineComment / RawParagraphLine)+ { 
        return types.NewParagraph(lines.([]interface{}), attributes)
    }

MarkdownQuoteBlockRawContent <- (!BlankLine "> "? content:(RawLine) { 
    return content, nil
})+

RawParagraphLine <- !BlockDelimiter 
    content:(RawParagraphLineContent) EOL &{
        // exclude line if it is a blankline
        if strings.Trim(content.(string), " \t") == "" {
            return false, nil
        }
        return true, nil
    } {
        return types.NewRawLine(content.(string))
    }

RawParagraphLineContent <- [^\r\n]+ { 
    return string(c.text), nil 
}

// a paragraph whose first line begins with a word followed by spaces
SimpleRawParagraph <- attributes:(Attributes)? 
    &{
        // skip if the '[literal]' attribute was set on this paragraph
        if attrs, ok := attributes.(types.Attributes); ok {
            kind, exists := attrs[types.AttrKind]
            return !exists || kind != types.Literal, nil
        }
        return true, nil
    }
    firstLine: FirstParagraphRawLine
    otherLines:(SingleLineComment / RawParagraphLine)* { 
    return types.NewParagraph(append([]interface{}{firstLine}, otherLines.([]interface{})...), attributes)
}

FirstParagraphRawLine <- 
    content:(elements:Word [^\r\n]* { return string(c.text), nil}) EOL { 
    return types.NewRawLine(content.(string))
}



// ------------------------------------------
// Continued Paragraphs
// ------------------------------------------

// same as RawParagraph, but without allowing for ListItemContinuation (`+`)
ContinuedRawParagraph <- 
    // admonition paragraph 
    attributes:(Attributes)? t:(AdmonitionKind) ": " lines:(ContinuedRawParagraphLines) { 
        return types.NewAdmonitionParagraph(lines.([]interface{}), t.(types.AdmonitionKind), attributes)
    } / 
    // other kind of paragraph (verse, regular, etc.)
    attributes:(Attributes)? lines:(ContinuedRawParagraphLines) { 
        return types.NewParagraph(lines.([]interface{}), attributes)
} 

ContinuedRawParagraphLines <- firstLine:(FirstParagraphRawLine) otherLines:(!ListItemContinuation line:(SingleLineComment / RawParagraphLine) { return line, nil })* {
    return append([]interface{}{firstLine}, otherLines.([]interface{})...), nil
}

// ------------------------------------------
// Inline Elements
// ------------------------------------------
    
InlineElements <- !BlankLine
    elements:(comment:(SingleLineComment) {
        return types.NewInlineElements([]interface{}{comment})
    } / elements:(InlineElement)+ EOL { 
        return types.NewInlineElements(elements.([]interface{}))
    }) {
        return elements, nil
    }

InlineElement <-  
    element:(InlineWord // more permissive than the 'Word' rule
        / LineBreak // must be before spaces
        / Space+ 
        / !EOL (
            QuotedString
            / QuotedText
            / InlineIcon
            / InlineImage 
            / Link 
            / InlinePassthrough // must be before the SpecialCharacter rule (because of `+`)
            / InlineFootnote 
            / CrossReference // must appear before SpecialCharacter
            / SpecialCharacter
            / Symbol
            / InlineUserMacro 
            / AttributeSubstitution 
            / InlineElementID
            / ConcealedIndexTerm
            / IndexTerm
            / ElementPlaceHolder
            / AnyChar)) {
    return element, nil
}

// ----------------------------------------------------------------------------
// Explicit line breaks
// ----------------------------------------------------------------------------
LineBreak <- Space "+" Space* &EOL {
    return types.NewLineBreak()    
}

// ----------------------------------------------------------------------------
// Quoted Texts (bold, italic and monospace) including substitution prevention
// ----------------------------------------------------------------------------
QuotedText <- UnconstrainedQuotedText / ConstrainedQuotedText / EscapedQuotedText

ConstrainedQuotedTextMarker <- "*" !"*" / "_" !"_" / "#" !"#" / "`" !"`"

UnconstrainedQuotedTextPrefix <- "**" / "__" / "``" / "##" / "^" / "~"

ConstrainedQuotedText <- text:(SingleQuoteBoldText 
            / SingleQuoteItalicText
            / SingleQuoteMarkedText
            / SingleQuoteMonospaceText 
            / SubscriptText 
            / SuperscriptText 
            / SubscriptOrSuperscriptPrefix) { // if a '^' or '~' is alone (ie, badly formatted superscript or subscript, then accept it as-is) 
    return text, nil
}

UnconstrainedQuotedText <- DoubleQuoteBoldText
            / DoubleQuoteItalicText
            / DoubleQuoteMarkedText
            / DoubleQuoteMonospaceText

EscapedQuotedText <- EscapedBoldText 
            / EscapedItalicText
            / EscapedMarkedText
            / EscapedMonospaceText 
            / EscapedSubscriptText 
            / EscapedSuperscriptText

SubscriptOrSuperscriptPrefix <- "^" / "~" { // rule used withn `words` to detect superscript or subscript portions, eg in math formulae.
    return string(c.text), nil
}

OneOrMoreBackslashes <- `\`+ {
    return string(c.text), nil
}

TwoOrMoreBackslashes <- `\\` `\`* {
    return string(c.text), nil
}

// -----------------
// Bold text
// -----------------

BoldText <- DoubleQuoteBoldText / SingleQuoteBoldText // double punctuation must be evaluated first

DoubleQuoteBoldText <- attrs:(QuotedTextAttrs)? "**" elements:(DoubleQuoteBoldTextElements) "**" {
    return types.NewQuotedText(types.Bold, attrs, elements.([]interface{}))
} 

DoubleQuoteBoldTextElements <- DoubleQuoteBoldTextElement*  

DoubleQuoteBoldTextElement <- !("**") element:(Word
        / Space // may start and end with spaces
        / Newline !Newline
        / SingleQuoteBoldText
        / QuotedString
        / ItalicText
        / MarkedText
        / MonospaceText
        / SubscriptText
        / SuperscriptText
        / ElementPlaceHolder
        / DoubleQuoteBoldTextFallbackCharacter) {
    return element, nil
}

DoubleQuoteBoldTextFallbackCharacter <-
    [^\r\n*] // anything except EOL and bold delimiter (fallback in case nothing else matched)
    / "**" Alphanums {  // or a bold delimiter when immediately followed by an alphanum (ie, in the middle of some text)
    return types.NewStringElement(string(c.text))
}

SingleQuoteBoldText <- attrs:(QuotedTextAttrs)? ( "*" !"*") elements:(SingleQuoteBoldTextElements) "*" &(!Alphanum) { // single punctuation cannot be followed by a character (needs '**' to emphazise a portion of a word)
    return types.NewQuotedText(types.Bold, attrs, elements.([]interface{}))
} / attrs:(QuotedTextAttrs)? "*" elements:("*" SingleQuoteBoldTextElements) "*" { // unbalanced `**` vs `*` punctuation.
    return types.NewQuotedText(types.Bold, attrs, elements.([]interface{})) // include the second heading `*` as a regular StringElement in the bold content
} 

SingleQuoteBoldTextElements <- !Space SingleQuoteBoldTextElement+

SingleQuoteBoldTextElement <- Word
        / Newline !Newline
        / DoubleQuoteBoldText
        / QuotedString
        / Space+ ('*' !'*')?
        / ItalicText
        / MarkedText
        / MonospaceText
        / SubscriptText
        / SuperscriptText
        / ElementPlaceHolder
        / SingleQuoteBoldTextFallbackCharacter

SingleQuoteBoldTextFallbackCharacter <-
    [^\r\n*] // anything except EOL and bold delimiter (fallback in case nothing else matched)
    / "*" Alphanums {  // or a bold delimiter when immediately followed by an alphanum (ie, in the middle of some text)
    return types.NewStringElement(string(c.text))
}

EscapedBoldText <- 
    backslashes:(TwoOrMoreBackslashes) "**" elements:(DoubleQuoteBoldTextElements) "**" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "**", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "**" elements:(SingleQuoteBoldTextElements) "*" { // unbalanced `**` vs `*` punctuation
        result := append([]interface{}{"*"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "*", result)
    } / backslashes:(OneOrMoreBackslashes) "*" elements:(SingleQuoteBoldTextElements) "*" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "*", elements.([]interface{}))
} 

// -----------------
// Italic text
// -----------------

ItalicText <- DoubleQuoteItalicText / SingleQuoteItalicText

DoubleQuoteItalicText <- attrs:(QuotedTextAttrs)? "__" elements:(DoubleQuoteItalicTextElements) "__" { // double punctuation must be evaluated first
    return types.NewQuotedText(types.Italic, attrs, elements.([]interface{}))
}

DoubleQuoteItalicTextElements <- DoubleQuoteItalicTextElement* 

DoubleQuoteItalicTextElement <- !("__") element:(Word
        / Space // may start and end with spaces
        / Newline !Newline
        / SingleQuoteItalicText
        / QuotedString
        / BoldText
        / MarkedText
        / MonospaceText
        / SubscriptText
        / SuperscriptText
        / ElementPlaceHolder
        / DoubleQuoteItalicTextFallbackCharacter) {
    return element, nil
}

DoubleQuoteItalicTextFallbackCharacter <-
    [^\r\n_] // anything except EOL and italic delimiter (fallback in case nothing else matched)
    / "__" Alphanums {  // or a italic delimiter when immediately followed by an alphanum (ie, in the middle of some text)
    return types.NewStringElement(string(c.text))
}

SingleQuoteItalicText <- attrs:(QuotedTextAttrs)? ("_" !"_") elements:(SingleQuoteItalicTextElements) "_" { // single punctuation cannot be followed by a character (needs '__' to emphazise a portion of a word)
    return types.NewQuotedText(types.Italic, attrs, elements.([]interface{}))
} / attrs:(QuotedTextAttrs)? "_" elements:("_" SingleQuoteItalicTextElements) "_" { // unbalanced `__` vs `_` punctuation.
    return types.NewQuotedText(types.Italic, attrs, elements.([]interface{})) // include the second heading `_` as a regular StringElement in the italic content
} 

SingleQuoteItalicTextElements <- !Space SingleQuoteItalicTextElement+

SingleQuoteItalicTextElement <- Word
        / Newline !Newline
        / DoubleQuoteItalicText
        / QuotedString
        / Space+ ('_' !'_')?
        / BoldText
        / MarkedText
        / MonospaceText
        / SubscriptText
        / SuperscriptText
        / ElementPlaceHolder
        / SingleQuoteItalicTextFallbackCharacter

SingleQuoteItalicTextFallbackCharacter <-
    [^\r\n_] // anything except EOL and italic delimiter (fallback in case nothing else matched)
    / "_" Alphanums {  // or an italic delimiter when immediately followed by an alphanum (ie, in the middle of some text)
    return types.NewStringElement(string(c.text))
}

EscapedItalicText <- 
    backslashes:(TwoOrMoreBackslashes) "__" elements:(DoubleQuoteItalicTextElements) "__" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "__", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "__" elements:(SingleQuoteItalicTextElements) "_" { // unbalanced `__` vs `_` punctuation
        result := append([]interface{}{"_"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "_", result)
    } / backslashes:(OneOrMoreBackslashes) "_" elements:(SingleQuoteItalicTextElements) "_" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "_", elements.([]interface{}))
} 

// -----------------
// Monospace text
// -----------------
MonospaceText <- DoubleQuoteMonospaceText / SingleQuoteMonospaceText

DoubleQuoteMonospaceText <- attrs:(QuotedTextAttrs)? "``" elements:(DoubleQuoteMonospaceTextElements) "``" { // double punctuation must be evaluated first
    return types.NewQuotedText(types.Monospace, attrs, elements.([]interface{}))
}

DoubleQuoteMonospaceTextElements <- DoubleQuoteMonospaceTextElement* // may start and end with spaces

DoubleQuoteMonospaceTextElement <- !("``") element:(Word
        / Space // may start and end with spaces
        / Newline !Newline
        / QuotedString
        / Apostrophe { // must be before SingleQuoteMonospaceText
            // do not convert to apostrophe (yet)
            return types.NewStringElement(string(c.text))
        }
        / SingleQuoteMonospaceText
        / BoldText
        / ItalicText
        / MarkedText
        / SubscriptText
        / SuperscriptText
        / ElementPlaceHolder
        / DoubleQuoteMonospaceTextFallbackCharacter) {
    return element, nil
}

DoubleQuoteMonospaceTextFallbackCharacter <-
    [^\r\n`] // anything except EOL and monospace delimiter (fallback in case nothing else matched)
    / "``" Alphanums {  // or a monospace delimiter when immediately followed by an alphanum (ie, in the middle of some text)
    return types.NewStringElement(string(c.text))
}

SingleQuoteMonospaceText <- attrs:(QuotedTextAttrs)? ("`" !"`") elements:(SingleQuoteMonospaceTextElements) "`" { // single punctuation cannot be followed by a character (needs "``" to emphazise a portion of a word)
    return types.NewQuotedText(types.Monospace, attrs, elements.([]interface{}))
} / attrs:(QuotedTextAttrs)? "`" elements:("`" SingleQuoteMonospaceTextElements) "`" { // unbalanced "``" vs "`" punctuation.
   return types.NewQuotedText(types.Monospace, attrs, elements.([]interface{})) // include the second heading "`" as a regular StringElement in the monospace content
}

SingleQuoteMonospaceTextElements <- !Space SingleQuoteMonospaceTextElement+

SingleQuoteMonospaceTextElement <-  Word
        / Newline !Newline
        / DoubleQuoteMonospaceText
        / QuotedString
        / Space+ ('`' !'`')?  // allow for content such as "`some `nested monospace`". Also, do not allow for double backticks after spaces.
        / BoldText
        / ItalicText
        / MarkedText
        / SubscriptText
        / SuperscriptText
        / Apostrophe {
            // do not convert to apostrophe (yet)
            return types.NewStringElement(string(c.text))
        }
        / ElementPlaceHolder
        / SingleQuoteMonospaceTextFallbackCharacter

SingleQuoteMonospaceTextFallbackCharacter <-
    [^\r\n`] // anything except EOL and monospace delimiter (fallback in case nothing else matched)
    / "`" Alphanums {  // or an monospace delimiter when immediately followed by an alphanum (ie, in the middle of some text)
    return types.NewStringElement(string(c.text))
}

EscapedMonospaceText <- 
    backslashes:(TwoOrMoreBackslashes) "``" elements:(DoubleQuoteMonospaceTextElements) "``" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "``", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "``" elements:(SingleQuoteMonospaceTextElements) "`" { // unbalanced "``" vs "`" punctuation
        result := append([]interface{}{"`"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "`", result)
    } / backslashes:(OneOrMoreBackslashes) "`" elements:(SingleQuoteMonospaceTextElements) "`" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "`", elements.([]interface{}))
} 

// ------------------------------------------------------
// Quoted Strings (between curly single or double quotes)
// ------------------------------------------------------

QuotedString <- SingleQuotedString / DoubleQuotedString

SingleQuotedString <- SingleQuoteStringStart elements:SingleQuotedStringElements SingleQuoteStringEnd {
    return types.NewQuotedString(types.SingleQuote, elements.([]interface{}))
}

SingleQuotedStringElements <- elements:(SingleQuotedStringElement+) {
    return types.NewInlineElements(elements)
}

SingleQuoteStringStart <- "'`" ![ \t\r\n]

SingleQuoteStringEnd <- "`'"

// We have to treat this one special, because of ambiguity with monospace markup.
SingleQuotedStringElement <- element:(
        LineBreak !SingleQuoteStringEnd // must be before spaces
        / Space+ !SingleQuoteStringEnd
        / !"`" Symbol  // Exclude the explicit quote
        / BoldText
        / ItalicText
        / MarkedText
        / SubscriptText
        / SuperscriptText
        / !"`'" MonospaceText
        / DoubleQuotedString
        / SingleQuotedStringFallbackCharacter) {
    return element, nil
}

SingleQuotedStringFallbackCharacter <-  [^\r\n\t `] / "`" !"'" {
    return types.NewStringElement(string(c.text))
}

DoubleQuotedString <- DoubleQuoteStringStart elements:DoubleQuotedStringElements DoubleQuoteStringEnd {
    return types.NewQuotedString(types.DoubleQuote, elements.([]interface{}))
}

DoubleQuotedStringElements <- elements:(DoubleQuotedStringElement+) {
    return types.NewInlineElements(elements)
}

// We have to treat this one special, because of ambiguity with monospace markup.
DoubleQuotedStringElement <- element:(
        LineBreak !DoubleQuoteStringEnd // must be before spaces
        / Space+ !DoubleQuoteStringEnd
        / BoldText
        / ItalicText
        / MarkedText
        / SubscriptText
        / SuperscriptText
        / !"`\"" MonospaceText
        /SingleQuotedString
        / DoubleQuotedStringFallbackCharacter) {
            return element, nil
}

DoubleQuoteStringStart <- "\"`" ![ \t\r\n]

DoubleQuoteStringEnd <- "`\""

DoubleQuotedStringFallbackCharacter <-  ([^\r\n\t `] / "`" !"\"") {
    return types.NewStringElement(string(c.text))
}


// -----------------
// Marked text
// -----------------

MarkedText <- DoubleQuoteMarkedText / SingleQuoteMarkedText

DoubleQuoteMarkedText <- attrs:(QuotedTextAttrs)? "##" elements:(DoubleQuoteMarkedTextElements) "##" { // double punctuation must be evaluated first
    return types.NewQuotedText(types.Marked, attrs, elements.([]interface{}))
}

DoubleQuoteMarkedTextElements <- DoubleQuoteMarkedTextElement (!("##") (Space / DoubleQuoteMarkedTextElement))*  // may start and end with spaces

DoubleQuoteMarkedTextElement <- Word
        / SingleQuoteMarkedText
        / Newline !Newline
        / QuotedString
        / BoldText
        / ItalicText
        / MonospaceText
        / SubscriptText
        / SuperscriptText
        / ElementPlaceHolder
        / DoubleQuoteMarkedTextFallbackCharacter

DoubleQuoteMarkedTextFallbackCharacter <-
    [^\r\n#] // anything except EOL and marked delimiter (fallback in case nothing else matched)
    / "##" Alphanums {  // or a marked delimiter when immediately followed by an alphanum (ie, in the middle of some text)
    return types.NewStringElement(string(c.text))
}

SingleQuoteMarkedText <- attrs:(QuotedTextAttrs)? ("#" !"#") elements:(SingleQuoteMarkedTextElements) "#" { // single punctuation cannot be followed by a character (needs '##' to emphazise a portion of a word)
    return types.NewQuotedText(types.Marked, attrs, elements.([]interface{}))
} / attrs:(QuotedTextAttrs)? "#" elements:("#" SingleQuoteMarkedTextElements) "#" { // unbalanced `##` vs `#` punctuation.
    return types.NewQuotedText(types.Marked, attrs, elements.([]interface{})) // include the second heading `_` as a regular StringElement in the italic content
}

SingleQuoteMarkedTextElements <- !Space SingleQuoteMarkedTextElement+

SingleQuoteMarkedTextElement <- Word
        / DoubleQuoteMarkedText
        / Newline !Newline
        / QuotedString
        / Space+ ('#' !'#')?
        / BoldText
        / ItalicText
        / MonospaceText
        / SubscriptText
        / SuperscriptText
        / ElementPlaceHolder
        / SingleQuoteMarkedTextFallbackCharacter

SingleQuoteMarkedTextFallbackCharacter <-
    [^\r\n#] // anything except EOL and mark delimiter (fallback in case nothing else matched)
    / "#" Alphanums {  // or a mark delimiter when immediately followed by an alphanum (ie, in the middle of some text)
    return types.NewStringElement(string(c.text))
}

EscapedMarkedText <-
    backslashes:(TwoOrMoreBackslashes) "##" elements:(DoubleQuoteMarkedTextElements) "##" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "##", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "##" elements:(SingleQuoteMarkedTextElements) "#" { // unbalanced `##` vs `#` punctuation
        result := append([]interface{}{"#"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "#", result)
    } / backslashes:(OneOrMoreBackslashes) "#" elements:(SingleQuoteMarkedTextElements) "#" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "#", elements.([]interface{}))
}


SubscriptText <- attrs:(QuotedTextAttrs)? "~" element:(SubscriptTextElement) "~" { // wraps a single word
    return types.NewQuotedText(types.Subscript, attrs, element)
}

SubscriptTextElement <- QuotedText / NonSubscriptText 

NonSubscriptText <- [^\r\n ~]+ { // anything except spaces, EOL or '~'
    return c.text, nil
}

EscapedSubscriptText <- backslashes:(OneOrMoreBackslashes) "~" element:(SubscriptTextElement) "~" { // simple punctuation must be evaluated last
    return types.NewEscapedQuotedText(backslashes.(string), "~", element)
} 

SuperscriptText <- attrs:(QuotedTextAttrs)? "^" element:(SuperscriptTextElement) "^" { // wraps a single word
    return types.NewQuotedText(types.Superscript, attrs, element)
}

SuperscriptTextElement <- QuotedText / NonSuperscriptText 

NonSuperscriptText <- [^\r\n ^]+ { // anything except spaces, EOL or '^'
    return c.text, nil
}

EscapedSuperscriptText <- backslashes:(OneOrMoreBackslashes) "^" element:(SuperscriptTextElement) "^" { // simple punctuation must be evaluated last
    return types.NewEscapedQuotedText(backslashes.(string), "^", element)
} 

// ------------------------------------------
// InlinePassthrough
// ------------------------------------------
InlinePassthrough <- TriplePlusPassthrough / SinglePlusPassthrough / PassthroughMacro

SinglePlusPassthroughPrefix <- "+"

SinglePlusPassthrough <- SinglePlusPassthroughPrefix content:(SinglePlusPassthroughContent) SinglePlusPassthroughPrefix !Alphanum {
    return types.NewInlinePassthrough(types.SinglePlusPassthrough, []interface{}{content})
}

SinglePlusPassthroughContent <- ((!SinglePlusPassthroughPrefix !Space !Newline .) (!(Space+ SinglePlusPassthroughPrefix) !SinglePlusPassthroughPrefix !Newline .)* { // no space in the first or last position of the content, but allowed elsewhere
    return types.NewStringElement(string(c.text))
}) / ((!Space !Newline !SinglePlusPassthroughPrefix .)  { // a single character
    return types.NewStringElement(string(c.text))
})

TriplePlusPassthroughPrefix <- "+++"

TriplePlusPassthrough <- TriplePlusPassthroughPrefix content:(TriplePlusPassthroughContent) TriplePlusPassthroughPrefix !Alphanum {
    return types.NewInlinePassthrough(types.TriplePlusPassthrough, []interface{}{content})
}

TriplePlusPassthroughContent <- ((!TriplePlusPassthroughPrefix .)* { // spaces and newlines are also allowed in the first or last position of the content and elsewhere too
    return types.NewStringElement(string(c.text))
}) / ((!Space !Newline !TriplePlusPassthroughPrefix .)?  { // a single character
    return types.NewStringElement(string(c.text))
})

PassthroughMacro <- "pass:[" content:(PassthroughMacroCharacter)* "]" {
    return types.NewInlinePassthrough(types.PassthroughMacro, []interface{}{content})
} / "pass:q[" content:(QuotedText / PassthroughMacroCharacter)* "]" {
    return types.NewInlinePassthrough(types.PassthroughMacro, content.([]interface{}))
}

PassthroughMacroCharacter <- [^\]] {
    return types.NewStringElement(string(c.text))
}

// ------------------------------------------
// Cross References
// ------------------------------------------
CrossReference <- InternalCrossReference / ExternalCrossReference 

InternalCrossReference <- "<<" id:(ID) Space* "," label:(CrossReferenceLabel) ">>" {
    return types.NewInternalCrossReference(id.(string), label.(string))
} / "<<" id:(ID) ">>" {
    return types.NewInternalCrossReference(id.(string), nil)
} 

ExternalCrossReference <- "xref:" url:(FileLocation) inlineAttributes:(LinkAttributes) {
    return types.NewExternalCrossReference(url.(types.Location), inlineAttributes.(types.Attributes))
}

CrossReferenceLabel <- ElementTitleContent

// ------------------------------------------
// Links
// ------------------------------------------
Link <- RelativeLink / ExternalLink

// url preceeding with `link:` MUST be followed by square brackets
RelativeLink <- "link:" url:(Location) inlineAttributes:(LinkAttributes) {
    return types.NewInlineLink(url.(types.Location), inlineAttributes.(types.Attributes))
}

ExternalLink <- url:(LocationWithScheme) inlineAttributes:(LinkAttributes)? {
    return types.NewInlineLink(url.(types.Location), inlineAttributes)
}

LinkAttributes <- "[" firstAttr:(FirstLinkAttributeElement)*
    Space* otherattrs:(GenericAttribute)* "]" {
    return types.NewInlineLinkAttributes(append(firstAttr.([]interface{}), otherattrs.([]interface{})...))
} 

FirstLinkAttributeElement <- element:(
    // surrounded with double quotes
    ("\"" elements:(QuotedString / QuotedText / ElementPlaceHolder / QuotedAttributeChar)+ "\"" &(!"=") ","? {
        return types.NewInlineElements(elements.([]interface{}))
    }) /
    // not surrounded with double quotes
    (elements:(QuotedString / QuotedText / ElementPlaceHolder / UnquotedAttributeChar)+ &(!"=") ","? {
        return types.NewInlineElements(elements.([]interface{}))
    }))  {
        return element, nil
}

AttributeChar <- [^\r\n"=\],] { // excludes comma
    return types.NewStringElement(string(c.text))
}

QuotedAttributeChar <- [^\r\n"=\]] { // does not exclude comma
    return types.NewStringElement(string(c.text))
}

UnquotedAttributeChar <- [^\r\n"=\],] { // excludes comma
    return types.NewStringElement(string(c.text))
}

ResolvedLink <- ResolvedRelativeLink / ResolvedExternalLink // links without AttributeSubstitution

// url preceeding with `link:` MUST be followed by square brackets
ResolvedRelativeLink <- "link:" url:(ResolvedLocation / ResolvedFileLocation) inlineAttributes:(LinkAttributes) {
    return types.NewInlineLink(url.(types.Location), inlineAttributes.(types.Attributes))
}

ResolvedExternalLink <- url:(ResolvedLocation) inlineAttributes:(LinkAttributes)? {
    return types.NewInlineLink(url.(types.Location), inlineAttributes)
}

// ------------------------------------------
// Images
// ------------------------------------------
ImageBlock <- attributes:(BlockImageAttrs)* "image::" path:(Location) inlineAttrs:(InlineImageAttrs) Space* EOL {
    // 'imagesdir' attribute is added after applying the attribute substitutions on the image location
    return types.NewImageBlock(path.(types.Location), inlineAttrs.(types.Attributes), attributes)
}

InlineImage <- "image:" !":" path:(Location) inlineAttrs:(InlineImageAttrs) {
    return types.NewInlineImage(path.(types.Location), inlineAttrs.(types.Attributes), c.globalStore["imagesdir"])
}

InlineImageAttrs <- '[' alt:ImageAltInline w:ImageWidth h:ImageHeight nv:NamedAttrs ']' {
    return types.NewElementAttributes(alt, w, h, nv)
}

BlockImageAttrs <- ImageAttrList / ElementTitle / ElementID

ImageAttrList <- '[' attrs:(ImageAltAttr? ShortHandAttr* ImageWidthAttr? ImageHeightAttr? NamedAttr*) ']' Space* EOL {
    return types.NewElementAttributes(attrs)
}

ImageAltInline <- value:InlineVal? {
    return types.NewInlineAttribute(types.AttrImageAlt, value)
}

ImageWidth <- ","? value:InlineVal? {
    return types.NewInlineAttribute(types.AttrWidth, value)
}

ImageHeight <- ","? value:InlineVal? {
    return types.NewInlineAttribute(types.AttrImageHeight, value)
}

ImageAltAttr <- Space* value:PositionalValue Space* {
    return types.NewElementNamedAttr(types.AttrImageAlt, value)
}

ImageWidthAttr <- Space* "," Space* value:PositionalValue? {
    if value != nil {
        return types.NewElementNamedAttr(types.AttrWidth, value)
    }
    return nil, nil
}

ImageHeightAttr <- Space* "," Space* value:PositionalValue? {
    if value != nil {
        return types.NewElementNamedAttr(types.AttrImageHeight, value)
    }
    return nil, nil
}


// ------------------------------------------------------------------------------------
// Inline icons
// ------------------------------------------------------------------------------------
InlineIcon <- "icon:" icon:([\pL0-9_-]+ { return string(c.text), nil }) attrs:(IconAttrs) {
    return types.NewIcon(icon.(string), attrs.(types.Attributes))
}

IconAttrs <- '[' size:IconSize nv:NamedAttrs ']' {
    return types.NewElementAttributes(size, nv)
}

IconSize <- value:InlineVal? {
    return types.NewInlineAttribute(types.AttrIconSize, value)
}

// ------------------------------------------------------------------------------------
// Inline foot notes
// ------------------------------------------------------------------------------------
InlineFootnote <- "footnote:[" content:(FootnoteContent) "]" {
    return types.NewFootnote("", content.([]interface{}))
} / "footnote:" ref:(FootnoteRef) "[" content:(FootnoteContent)? "]" {
    return types.NewFootnote(ref.(string), content)
}

FootnoteRef <- Alphanums

FootnoteContent <- elements:(!"]" InlineElement)+  { // footnote content may span multiple lines
    return types.NewInlineElements(elements.([]interface{}))
}

// ------------------------------------------------------------------------------------
// Callouts
// ------------------------------------------------------------------------------------

Callout <- "<" ref:([0-9]+ { return strconv.Atoi(string(c.text)) }) ">" Space* &(EOL / Callout) {
    return types.NewCallout(ref.(int))
}

CalloutListItem <- ref:(CalloutListItemPrefix) description:(ListParagraph+) {
    return types.NewCalloutListItem(ref.(int), description.([]interface{}))
}

CalloutListItemPrefix <- "<" ref:([0-9]+ { return strconv.Atoi(string(c.text)) }) ">" Space+ {
    return ref, nil
}

// -------------------------------------------------------------------------------------
// Thematic break
// -------------------------------------------------------------------------------------

// Thematic break
ThematicBreak <- ("***" / "* * *" / "---" / "- - -" / "___" / "_ _ _") EOL {
    return types.NewThematicBreak()
}

// -------------------------------------------------------------------------------------
//
// Delimited blocks
//
// -------------------------------------------------------------------------------------

DelimitedBlock <- !Alphanum // delimited blocks, even without attributes, never start with an alphanum
    block:(FencedBlock 
        / ListingBlock 
        / ExampleBlock 
        / VerseBlock
        / QuoteBlock
        / SidebarBlock
        / PassthroughBlock
        / CommentBlock) {
    return block, nil
}

BlockDelimiter <- !(Alphanum) LiteralBlockDelimiter //TODO: use "start" delimiters
                / FencedBlockDelimiter 
                / ListingBlockDelimiter 
                / ExampleBlockDelimiter 
                / CommentBlockDelimiter 
                / QuoteBlockDelimiter
                / SidebarBlockDelimiter
                / PassthroughBlockDelimiter

// -------------------------------------------------------------------------------------
// Example blocks
// -------------------------------------------------------------------------------------
ExampleBlock <- attributes:(Attributes)? ExampleBlockStartDelimiter blocks:(ExampleBlockRawContent) ExampleBlockEndDelimiter {
    return types.NewExampleBlock(blocks.([]interface{}), attributes)
}

ExampleBlockDelimiter <- "====" Space* EOL

ExampleBlockStartDelimiter <- "====" Space* EOL

ExampleBlockEndDelimiter <- ("====" Space* EOL) / EOF

ExampleBlockRawContent <- (
       !ExampleBlockEndDelimiter 
       element:(BlankLine 
            / ImageBlock
            / ThematicBreak
            / OrderedListItem 
            / UnorderedListItem 
            / LabeledListItem 
            / ContinuedListItemElement
            / FencedBlock 
            / ListingBlock 
            / VerseBlock
            / QuoteBlock
            / SidebarBlock
            / SingleLineComment
            / PassthroughBlock
            / Table
            / CommentBlock
            / LiteralBlock 
            / RawParagraph
            / StandaloneAttributes) {
        return element, nil
    })* 

// -------------------------------------------------------------------------------------
// Quote blocks
// -------------------------------------------------------------------------------------
QuoteBlock <- attributes:(Attributes)? 
    &{
        if attributes == nil {
            return true, nil
        }
        if attrs, ok := attributes.(types.Attributes); ok {
            kind, ok := attrs[types.AttrKind]
            // if AttrKind is missing, then accept as a QuoteBlock
            return !ok || kind == types.Quote, nil
        }
        return false, nil
    }
    QuoteBlockStartDelimiter content:(QuoteBlockRawContent) QuoteBlockEndDelimiter {
        return types.NewQuoteBlock(content.([]interface{}), attributes)
    }

QuoteBlockDelimiter <- "____" Space* EOL // same for verse blocks

QuoteBlockStartDelimiter <- "____" Space* EOL // same for verse blocks

QuoteBlockEndDelimiter <- ("____" Space* EOL) / EOF // same for verse blocks

QuoteBlockRawContent <- (
       !QuoteBlockEndDelimiter 
       element:(BlankLine 
            / ImageBlock
            / ThematicBreak
            / OrderedListItem 
            / UnorderedListItem 
            / LabeledListItem 
            / ContinuedListItemElement
            / FencedBlock 
            / ListingBlock 
            / VerseBlock
            / ExampleBlock
            / SidebarBlock
            / SingleLineComment
            / PassthroughBlock
            / Table
            / CommentBlock
            / LiteralBlock 
            / RawParagraph
            / StandaloneAttributes) {
        return element, nil
    })* 

// -------------------------------------------------------------------------------------
// Sidebar blocks
// -------------------------------------------------------------------------------------
SidebarBlock <- attributes:(Attributes)? SidebarBlockStartDelimiter content:(SidebarBlockRawContent) SidebarBlockEndDelimiter {
    return types.NewSidebarBlock(content.([]interface{}), attributes)
}

SidebarBlockDelimiter <- "****" Space* EOL

SidebarBlockStartDelimiter <- "****" Space* EOL

SidebarBlockEndDelimiter <- ("****" Space* EOL) / EOF

SidebarBlockRawContent <- (
       !SidebarBlockEndDelimiter 
       element:(BlankLine 
            / ImageBlock
            / ThematicBreak
            / OrderedListItem 
            / UnorderedListItem 
            / LabeledListItem 
            / ContinuedListItemElement
            / FencedBlock 
            / ListingBlock
            / VerseBlock 
            / ExampleBlock
            / QuoteBlock
            / SingleLineComment
            / PassthroughBlock
            / Table
            / CommentBlock
            / LiteralBlock 
            / RawParagraph
            / StandaloneAttributes) {
        return element, nil
    })* 

// -------------------------------------------------------------------------------------
// Fenced blocks
// -------------------------------------------------------------------------------------
FencedBlock <- attributes:(Attributes)? FencedBlockStartDelimiter content:(FencedBlockRawContent) FencedBlockEndDelimiter {
    return types.NewFencedBlock(content.([]interface{}), attributes)
}

FencedBlockDelimiter <- "```" Space* EOL // Deprecated: use 'FencedBlockStartDelimiter' instead

FencedBlockStartDelimiter <- "```" Space* EOL

FencedBlockEndDelimiter <- ("```" Space* EOL) / EOF

FencedBlockRawContent <- (!FencedBlockEndDelimiter line:(RawLine) { 
    return line, nil
})*

// -------------------------------------------------------------------------------------
// Listing blocks
// -------------------------------------------------------------------------------------
ListingBlock <- attributes:(Attributes)? ListingBlockStartDelimiter content:(ListingBlockRawContent) ListingBlockEndDelimiter {
    return types.NewListingBlock(content.([]interface{}), attributes)
}

ListingBlockDelimiter <- "----" Space* EOL

ListingBlockStartDelimiter <- "----" Space* EOL

ListingBlockEndDelimiter <- ("----" Space* EOL) / EOF

ListingBlockRawContent <- (!ListingBlockEndDelimiter line:(RawLine) { 
    return line, nil
})*

// -------------------------------------------------------------------------------------
// Verse blocks
// -------------------------------------------------------------------------------------
VerseBlock <- attributes:(Attributes)? 
    &{
        if attrs, ok := attributes.(types.Attributes); ok {
            kind, ok := attrs[types.AttrKind]
            return ok && kind == types.Verse, nil
        }
        return false, nil
    }
    QuoteBlockStartDelimiter content:(VerseBlockRawContent) QuoteBlockEndDelimiter {
        return types.NewVerseBlock(content.([]interface{}), attributes)
    }

VerseBlockRawContent <- (!QuoteBlockEndDelimiter line:(RawLine) { 
    return line, nil
})*

// -------------------------------------------------------------------------------------
// Passthrough blocks
// -------------------------------------------------------------------------------------
PassthroughBlock <- attributes:(Attributes)? PassthroughBlockStartDelimiter content:(PassthroughBlockRawContent) PassthroughBlockEndDelimiter {
    return types.NewPassthroughBlock(content.([]interface{}), attributes)
}

PassthroughBlockDelimiter <- "++++" Space* EOL

PassthroughBlockStartDelimiter <- "++++" Space* EOL

PassthroughBlockEndDelimiter <- ("++++" Space* EOL) / EOF

PassthroughBlockRawContent <- (!PassthroughBlockEndDelimiter line:(RawLine) { 
    return line, nil
})*

// -------------------------------------------------------------------------------------
// Comment blocks
// -------------------------------------------------------------------------------------
CommentBlockDelimiter <- "////" Space* EOL

CommentBlockStartDelimiter <- "////" Space* EOL

CommentBlockEndDelimiter <- ("////" Space* EOL) / EOF

CommentBlock <- CommentBlockStartDelimiter content:(CommentBlockRawContent)  CommentBlockEndDelimiter {
    return types.NewCommentBlock(content.([]interface{}), nil)
}

CommentBlockRawContent <- (!CommentBlockEndDelimiter line:(RawLine) { 
    return line, nil
})*

SingleLineComment <- !CommentBlockDelimiter "//" content:(SingleLineCommentContent) EOL {
    return types.NewSingleLineComment(content.(string))
}

SingleLineCommentContent <- [^\r\n]* {
    return string(c.text), nil
}

// -------------------------------------------------------------------------------------
// DelimitedBlock and Paragraph Substitutions (standalone rules)
// -------------------------------------------------------------------------------------

InlineMacros <- InlineIcon
                / InlineImage 
                / Link 
                / InlinePassthrough 
                / InlineFootnote 
                / CrossReference 
                / InlineUserMacro 
                / InlineElementID
                / ConcealedIndexTerm
                / IndexTerm

ElementPlaceHolder <- "\uFFFD" ref:([0-9]+ { return string(c.text), nil }) "\uFFFD" {
    return types.NewElementPlaceHolder(ref.(string))
}

// internal rule to detect passthrough blocks before other substitutions are applied
InlinePassthroughSubs <- 
    (InlinePassthrough 
        / InlineWord // more permissive than the 'Word' rule
        / ElementPlaceHolder
        / Space+ 
        / AnyChar
        / Newline)* EOF

// standalone rule for the "specialcharacters" substitution when callouts should be processed as special characters
SpecialCharacterSubs <- 
    (InlineWord // more permissive than the 'Word' rule
        / SpecialCharacter
        / ElementPlaceHolder
        / Space+
        / AnyChar
        / Newline)* EOF

// standalone rule for the "quotes" substitution
QuotedTextSubs <- 
    (InlineWord // more permissive than the 'Word' rule
        / Space+ 
        / QuotedText 
        / QuotedString
        / ElementPlaceHolder
        / AnyChar
        / Newline)* EOF

// standalone rule for the "attributes" substitution
AttributeSubs <- 
    (InlineWord // more permissive than the 'Word' rule
        / Space+ 
        / AttributeSubstitution
        / ElementPlaceHolder
        / AnyChar
        / Newline)* EOF

// standalone rule for the "macros" substitution
InlineMacroSubs <- 
    (InlineWord // more permissive than the 'Word' rule
        / Space+ 
        / InlineMacros
        / ElementPlaceHolder
        / AnyChar
        / Newline)* EOF

// standalone rule for the "macros" substitution for Markdown Quote blocks
MarkdownQuoteMacroSubs <- lines:(MarkdownQuoteLine)* EOF {
    return types.NewParagraph(lines.([]interface{}), nil)
}

MarkdownQuoteLine <- 
    elements:(InlineWord // more permissive than the 'Word' rule
        / Space+ 
        / InlineMacros
        / ElementPlaceHolder
        / AnyChar)+ EOL {
    return types.NewInlineElements(elements.([]interface{})) 
}

MarkdownQuoteAttribution <- "-- " author:(([^\r\n]+) {
    return string(c.text), nil
    }) EOL {
    return author, nil
}

// standalone rule for the "replacements" substitution
ReplacementSubs <- 
    (InlineWord // more permissive than the 'Word' rule
        / Space+ 
        / Symbol 
        / ElementPlaceHolder
        / AnyChar
        / Newline)* EOF

// standalone rule for the "post_replacements" substitution 
// TODO: simplify as we only need to search for LineBreak at the end of the line?
PostReplacementSubs <- (
    InlineWord // more permissive than the 'Word' rule
    / ElementPlaceHolder
    / LineBreak // must be before `Space+`
    / Space+ 
    / AnyChar
    / Newline)* EOF

// standalone rule for the "callouts" substitution 
CalloutSubs <- 
    (InlineWord // more permissive than the 'Word' rule
        / ElementPlaceHolder
        / Space+
        / Callout
        / AnyChar
        / Newline)* EOF

// standalone rule for the "none" substitution
NoneSubs <- (
    ElementPlaceHolder 
    / (!EOF [^\r\n]* EOL { // just text, including empty lines
        return types.NewStringElement(string(c.text))
    }))* EOF

// -------------------------------------------------------------------------------------
// Tables
// -------------------------------------------------------------------------------------
Table <- attrs:(BlockAttrs*)? TableDelimiter
    header:(TableLineHeader)?
    lines:(TableLine)*
    (TableDelimiter / EOF) { // end delimiter or end of file
        return types.NewTable(header, lines.([]interface{}), attrs)
}

TableCellSeparator <- "|" Space*

TableDelimiter <- "|===" Space* EOL
        
// table line header is a line followed by a blankline
TableLineHeader <- !TableDelimiter cells:(TableCell)+ EOL BlankLine {
    return types.NewTableLine(cells.([]interface{}))
}

TableLine <- !TableDelimiter cells:(TableCell)+ EOL BlankLine* {
    return types.NewTableLine(cells.([]interface{}))
}

TableCell <- TableCellSeparator elements:(!TableCellSeparator !EOL Space* InlineElement Space*)+ {
    return types.NewInlineElements(elements)
}

// -------------------------------------------------------------------------------------
// Literal Blocks (see http://asciidoctor.org/docs/user-manual/#literal-text-and-blocks)
// -------------------------------------------------------------------------------------
LiteralBlock <- ParagraphWithLiteralAttribute / ParagraphWithHeadingSpaces / ParagraphWithLiteralBlockDelimiter

LiteralBlockDelimiter <- "...."

// paragraph indented with one or more spaces on the first line
ParagraphWithHeadingSpaces <- attributes:(Attributes)? lines:(ParagraphWithHeadingSpacesLines) {
    return types.NewLiteralBlock(types.LiteralBlockWithSpacesOnFirstLine, lines.([]interface{}), attributes)
}

// first line MUST start with one (or more) space. Stop when reaching a blank line
ParagraphWithHeadingSpacesLines <- 
    firstLine:(Space+ [^\r\n]+ { // TODO: use ParagraphWithLiteralBlockDelimiterLine
        return types.NewRawLine(string(c.text))
    }) EOL // do not include the trailing 'EOL' on the first line
    otherLines:(
        !BlankLine 
        otherLine:([^\r\n]+ { // TODO: use ParagraphWithLiteralBlockDelimiterLine
            return types.NewRawLine(string(c.text))
        }) EOL {
            return otherLine, nil // do not include the trailing 'EOL'
        })* { 
    return append([]interface{}{firstLine}, otherLines.([]interface{})...), nil
}

// paragraph with the literal block delimiter (`....`)
ParagraphWithLiteralBlockDelimiter <- attributes:(Attributes)?
        LiteralBlockDelimiter Space* Newline lines:(ParagraphWithLiteralBlockDelimiterLines) ((LiteralBlockDelimiter Space* EOL) / EOF) {
    return types.NewLiteralBlock(types.LiteralBlockWithDelimiter, lines.([]interface{}), attributes)
}

// include all lines until delimiter is reached
ParagraphWithLiteralBlockDelimiterLines <- lines:(ParagraphWithLiteralBlockDelimiterLine)* {
    return lines.([]interface{}), nil
}

ParagraphWithLiteralBlockDelimiterLine <-         
    line:(!LiteralBlockDelimiter [^\r\n]* {
        return types.NewRawLine(string(c.text))
    }) EOL { 
        return line, nil // do not include the trailing 'EOL'
}

// paragraph with the literal attribute (`[literal]`)
ParagraphWithLiteralAttribute <- 
    attributes:(Attributes)?
    &{
        if attrs, ok := attributes.(types.Attributes); ok {
            kind, ok := attrs[types.AttrKind]
            return ok && kind == types.Literal, nil
        }
        return false, nil
    }
    lines:(ParagraphWithLiteralAttributeLines) {
        return types.NewLiteralBlock(types.LiteralBlockWithAttribute, lines.([]interface{}), attributes)
    }

LiteralKind <- "literal" {
    return string(c.text), nil
}

// include all lines until blankline
ParagraphWithLiteralAttributeLines <- lines:(ParagraphWithLiteralAttributeLine)+ { 
    return lines.([]interface{}), nil
}

ParagraphWithLiteralAttributeLine <- !BlankLine content:([^\r\n]+ {
    return types.NewRawLine(string(c.text))
}) EOL {
    return content, nil // do not include the trailing 'EOL'
}

// ------------------------------------------
// Index Terms
// ------------------------------------------
IndexTerm <- "((" term:(IndexTermContent) "))" {
       return types.NewIndexTerm(term.([]interface{}))
}

IndexTermContent <- elements:(Word / QuotedString / QuotedText / Space / SpecialCharacter / ElementPlaceHolder / (!"))" .) {
    return string(c.text), nil
})+ {
    return types.NewInlineElements(elements.([]interface{}))
}

ConcealedIndexTerm <- "(((" term1:(ConcealedIndexTermContent) 
    term2:(Space* "," Space* content:(ConcealedIndexTermContent) { return content, nil })? 
    term3:(Space* "," Space* content:(ConcealedIndexTermContent) { return content, nil })? 
    ")))" {
        return types.NewConcealedIndexTerm(term1, term2, term3)
    }

ConcealedIndexTermContent <- (Alphanum / Space)+ {
    return string(c.text), nil
}

// ------------------------------------------
// BlankLine
// ------------------------------------------
BlankLine <- !EOF Space* EOL {
    return types.NewBlankLine()
}

// ------------------------------------------
// Symbols
// ------------------------------------------

Symbol <- Apostrophe / Copyright / Trademark / Registered / Ellipsis / ImpliedApostrophe

Apostrophe <- "`'" {
    return types.NewStringElement("\u2019")
}
Copyright <- "(C)" {
    return types.NewStringElement("\u00a9")
}
Trademark <- "(TM)" {
    return types.NewStringElement("\u2122")
}
Registered <- "(R)" {
    return types.NewStringElement("\u00ae")
}
Ellipsis <- "..." {
    return types.NewStringElement("\u2026\u200b")
}

// The implied apostrophe is used in interior words, and intended to help
// cases like "mother's day".  asciidoctor requires that it be followed by
// a letter (not a digit) but it can have a digit just before it.

ImpliedApostrophe <- Alphanum "'" &[\pL] {
    return types.NewStringElement(string(c.text[:1])+"\u2019")
}

// ------------------------------------------------------------------------------------
// Special Characters 
// They need to be identified as they may have a special treatment during the rendering
// ------------------------------------------------------------------------------------

SpecialCharacter <- InternalCrossReference {
    // if we have a InternalCrossReference we just return a StringElement. 
        return types.NewStringElement(string(c.text))
    } / ("<" / ">" / "&" ) {
        return types.NewSpecialCharacter(string(c.text))
    }

// ------------------------------------------
// Base Types
// ------------------------------------------
Alphanum <- [\pL0-9]

Parenthesis <- "(" / ")" / "[" / "]" / "{" / "}" 

Alphanums <- [\pL0-9]+ {
    return string(c.text), nil
}

Word <-
    // very straightforward content: alphanums followed by attached simple quote delimiter and more characters 
    // (in this case, the quoted text delimiters are intepreted as regular characters)
    // then followed by spaces but not the "+" signs because it needs a heading space to become a LineBreak element
    [\pL0-9]+ &([\r\n ,\]] / EOF) { 
        return types.NewStringElement(string(c.text))
    } / [\pL0-9]+ ([=*_`] [\pL0-9]+)+ { 
        return types.NewStringElement(string(c.text))
    }

InlineWord <- // same as word, but may also contain some punctuation markers
    [\pL0-9,?!;]+ &([\r\n ] / EOF) {
        return types.NewStringElement(string(c.text))
    } / Word

// this is a fall-back rule in case all preceeding rules failed to match the current content.
AnyChar <- [^\r\n] { 
    return types.NewStringElement(string(c.text))
} 

FileLocation <- path:(FILENAME / ElementPlaceHolder)+ {
    return types.NewLocation("", path.([]interface{}))
}

ResolvedFileLocation <- path:([^\r\n [])+ {
    return types.NewLocation("", path.([]interface{}))
}

Location <- scheme:(URL_SCHEME)? path:(FILENAME  / ElementPlaceHolder)+ {
    return types.NewLocation(scheme, path.([]interface{}))
}

LocationWithScheme <- scheme:(URL_SCHEME) path:(FILENAME / ElementPlaceHolder)+ {
    return types.NewLocation(scheme, path.([]interface{}))
}

FILENAME <- ([^\r\n[\]\uFFFD ])+ // not supported for now: EOL, space, "[", "]"

ResolvedLocation <- scheme:(URL_SCHEME) path:(RESOLVED_FILENAME) {
    return types.NewLocation(scheme, path.([]interface{}))
}

//RESOLVED_FILENAME <- ([ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~:/?#@!$&;=()*+_,%{}] / "-" / ".")+ // here, `{` and `}` are valid characters
RESOLVED_FILENAME <- ([^\r\n[\] ])+ // not supported for now: EOL, space, "[", "]", "{" and "}" as they may be used for document attribute substitutions

URL <-  [^\r\n[\]]+ {
    return string(c.text), nil
}

URL_SCHEME <- "http://" / "https://" / "ftp://" / "irc://" / "mailto:"

ID <- [^[\]<>,]+ { // previously: (Alphanums / (!Newline !Space !"[" !"]" !"<<" !">>" !","  .))+
    return string(c.text), nil
}

DIGIT <- [0-9] {
    return string(c.text), nil
}

NUMBER <- "-"? DIGIT+ {
    return strconv.Atoi(string(c.text))
}

Space <- " " / "\t" {
    return string(c.text), nil
}

Newline <- "\r\n" / "\r" / "\n"

EOF <- !.

EOL <- Newline / EOF