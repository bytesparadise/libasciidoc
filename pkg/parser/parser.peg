{
package parser 

import (
    "strconv"
    "io"
    "unicode"

    "github.com/bytesparadise/libasciidoc/pkg/types"
)

}

// ----------------------------------------------------------------
// AsciidocDocument - fully parsed document, line by line
// ----------------------------------------------------------------
AsciidocDocument <- frontmatter:(FrontMatter?) blocks:(AsciidocDocumentBlocks) EOF {
    return types.NewDraftDocument(frontmatter, blocks.([]interface{}))
}

AsciidocDocumentWithinDelimitedBlock <- frontmatter:(FrontMatter?) blocks:(AsciidocDocumentBlocksWithinDelimitedBlock) EOF {
    return types.NewDraftDocument(frontmatter, blocks.([]interface{}))
}

TextDocument <- blocks:(TextDocumentBlocks) EOF {
    return types.NewDraftDocument(nil, blocks.([]interface{}))
}

// ------------------------------------------
// Document blocks
// ------------------------------------------
AsciidocDocumentBlocks <- header:(DocumentHeader?) others:(DocumentBlock*) {
    if header != nil && others != nil {
        return append([]interface{}{header}, others.([]interface{})...), nil
    } else if others != nil {
        return others.([]interface{}), nil
    }
    return []interface{}{}, nil
}

DocumentBlock <- !EOF 
    block:(SimpleParagraph
        / Section 
        / DelimitedBlock
        / FileInclusion
        / VerseParagraph // must be before ImageBlock
        / ImageBlock 
        / ListItem
        / BlankLine // must be before LiteralBlock
        / LiteralBlock 
        / DocumentAttributeDeclaration 
        / DocumentAttributeReset 
        / TableOfContentsPlaceHolder
        / UserMacroBlock
        / Paragraph) {
    return block, nil
}

AsciidocDocumentBlocksWithinDelimitedBlock <- blocks:(DocumentBlockWithinDelimitedBlock)*

DocumentBlockWithinDelimitedBlock <- !EOF 
    block:(DelimitedBlock
        / FileInclusion
        / VerseParagraph
        / ImageBlock 
        / ListItem
        / BlankLine // must be before LiteralBlock
        / LiteralBlock 
        / DocumentAttributeDeclaration 
        / DocumentAttributeReset 
        / TableOfContentsPlaceHolder
        / UserMacroBlock
        / Paragraph) {
    return block, nil
}

TextDocumentBlocks <- blocks:(TextDocumentBlock)*

TextDocumentBlock <- !EOF 
    block:(BlankLine / Paragraph) {
    return block, nil
}

// ------------------------------------------
// Front Matter
// ------------------------------------------
FrontMatter <- YamlFrontMatter 

YamlFrontMatter <- YamlFrontMatterToken content:(YamlFrontMatterContent)? YamlFrontMatterToken {
    return types.NewYamlFrontMatter(content.(string))
}

YamlFrontMatterToken  <- "---" EOLS

YamlFrontMatterContent <- ((!YamlFrontMatterToken .)+)* {
    return string(c.text), nil
}

// ------------------------------------------
// Document Header and Metadata
// ------------------------------------------
DocumentHeader <- "=" WS+ title:(TitleElements) id:(InlineElementID*) EOL
        (SingleLineComment / CommentBlock)*
        authors:(DocumentAuthors?) 
        (SingleLineComment / CommentBlock)*
        revision:(DocumentRevision?) {
    return types.NewDocumentHeader(title.([]interface{}), authors, revision)
}

DocumentAuthors <- DocumentAuthorsInlineForm / DocumentAuthorsAttributeForm

DocumentAuthorsInlineForm <- WS* !":" authors:(DocumentAuthor+) EOL {
    return types.NewDocumentAuthors(authors.([]interface{}))
}

DocumentAuthorsAttributeForm <- WS* ":author:" author:(DocumentAuthor) EOL {
    return []types.DocumentAuthor{author.(types.DocumentAuthor)}, nil
}

DocumentAuthor <- WS* fullname:(DocumentAuthorName) email:(DocumentAuthorEmail)? WS* ";"? WS* {
    return types.NewDocumentAuthor(fullname, email)
}

// "<" marks the beginning of the author email, and ";" is the authors separator
DocumentAuthorName <- (Alphanums / (!"<" !";" !Newline .))+ {
    return string(c.text), nil
}

DocumentAuthorEmail <- "<" email:((Alphanums / (!">" !EOL  .))+ {
    return string(c.text), nil
}) ">" {
    return email, nil
}

// see http://asciidoctor.org/docs/user-manual/#revision-number-date-and-remark
// Eg: "v1.0, October 2, 2013: First incarnation"
DocumentRevision <- WS* !":" revision:(
        (revnumber:(DocumentRevisionNumber) ","? revdate:(DocumentRevisionDate)? ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(revnumber, revdate, revremark)
        }) / (revdate:(DocumentRevisionDate) ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(nil, revdate, revremark)
        })) EOL {
    return revision, nil
}

// DocumentRevisionNumber MUST start with a `v` or MAY start with a `v` but MUST end with a `,`
DocumentRevisionNumber <- "v"i DIGIT  (Alphanums / Spaces / (!EOL !"," !":"  .))+ {
    return string(c.text), nil
} / "v"i? DIGIT  (Alphanums / Spaces / (!EOL !"," !":"  .))+ WS* &"," {
    return string(c.text), nil
}

DocumentRevisionDate <- (Alphanums / Spaces / (!EOL !":"  .))+ {
    return string(c.text), nil
}

DocumentRevisionRemark <- (Alphanums / Spaces / (!EOL  .))+ {
    return string(c.text), nil
}

// ------------------------------------------
// Document Attributes
// ------------------------------------------
DocumentAttributeDeclaration <- ":" name:(DocumentAttributeName) ":" value:((WS+ value:(DocumentAttributeValue)) { return value, nil })? EOLS {
    return types.NewDocumentAttributeDeclaration(name.(string), value)
} 

// AttributeName must be at least one character long, 
// must begin with a word character (A-Z, a-z, 0-9 or _) and 
// must only contain word Word and hyphens ("-").
DocumentAttributeName <- ([A-Z] / [a-z] / [0-9] / "_") ([A-Z] / [a-z] / [0-9] / "-")* {
    return string(c.text), nil
}

DocumentAttributeValue <- (!Newline .)+ {
    return string(c.text), nil
}

DocumentAttributeReset <- ":!" name:(DocumentAttributeName) ":" EOLS {
    return types.NewDocumentAttributeReset(name.(string))
} / ":" name:(DocumentAttributeName) "!:" EOLS {
    return types.NewDocumentAttributeReset(name.(string))
}

DocumentAttributeSubstitution <- "{" name:(DocumentAttributeName) "}" {
    return types.NewDocumentAttributeSubstitution(name.(string))
}

// ------------------------------------------
// Element Attributes
// ------------------------------------------
ElementAttributes <- attrs:(ElementAttribute)+ {
    return types.NewElementAttributes(attrs.([]interface{})), nil
}

ElementAttribute <- &("[" / "." / "#") // skip if the content does not start with one of those characters
    attr:(ElementID / 
        ElementTitle / 
        ElementRole / 
        LiteralAttribute / 
        SourceAttributes / 
        QuoteAttributes / 
        VerseAttributes / 
        AdmonitionMarkerAttribute / 
        HorizontalLayout / 
        AttributeGroup) {
    return attr, nil // avoid returning something like `[]interface{}{attr, EOL}`
}

// identify all attributes that masquerade a block element into something else.
MasqueradeAttribute <- QuoteAttributes / VerseAttributes

ElementID <- "[[" id:(ID) "]]" EOLS {
    return types.NewElementID(id.(string))
} / "[#" id:(ID) "]"  EOLS {
    return types.NewElementID(id.(string))
}

InlineElementID <- "[[" id:(ID) "]]" WS* { // no EOL here since there can be multiple InlineElementID on the same line
    return types.NewInlineElementID(id.(string))
}

// a title attached to an element, such as a ImageBlock
// a title starts with a single "." followed by the value, without space in-between
ElementTitle <- "." title:(Alphanums (Alphanums / Spaces / (!Newline .))* {
    return string(c.text), nil
}) EOL {
    return types.NewElementTitle(title.(string))
}

// a role attached to an element, such as a ImageBlock
// a role starts is wrapped in "[. ]" 
ElementRole <- "[." role:(Alphanums (Alphanums / Spaces / (!Newline !"]" .))* {
    return string(c.text), nil
}) "]" EOLS {
    return types.NewElementRole(role.(string))
}

LiteralAttribute <- "[literal]" WS* Newline {
    return types.NewLiteralAttribute()
}

// expression for the whole admonition marker, but only retains the actual kind
AdmonitionMarkerAttribute <- "[" k:(AdmonitionKind) "]" EOLS {
    return types.NewAdmonitionAttribute(k.(types.AdmonitionKind))
}

// a paragraph or a delimited block may contain source code in a given language
SourceAttributes <- "[source" 
    language:("," attr:(StandaloneAttributeValue)? { return attr, nil })? 
    others:("," attr:(GenericAttribute)? { return attr, nil })* 
    "]" EOLS {
    return types.NewSourceAttributes(language, others.([]interface{})...)
}

// one or more attributes. eg: [foo, key1=value1, key2 = value2 , ]
AttributeGroup <- "[" attributes:(GenericAttribute)* "]" EOLS {
    return types.NewAttributeGroup(attributes.([]interface{}))
}

GenericAttribute <- 
    key:(AttributeKey) "=" value:(AttributeValue)? ","? WS* { // value is (optionally) set
        return types.NewGenericAttribute(key.(string), value)
    } / key:(AttributeKey) ","? WS* { // value is not set
        return types.NewGenericAttribute(key.(string), nil)
    }

AttributeKey <- !"quote" !"verse" !"literal" !Spaces key:(Alphanums / OtherAttributeChar)+ WS* {
    return string(c.text), nil
}

AttributeValue <- value:(Alphanums / Spaces / OtherAttributeChar)+ { 
    return string(c.text), nil
}

StandaloneAttributeValue <- value:(Alphanums / Spaces / OtherAttributeChar)+ !"=" { // standalone attribute value cannot be followed by a `=`, otherwise it causes troubles for standalone values (eg: in images)
    return string(c.text), nil
}

OtherAttributeChar <- (!Newline !"=" !"," !"]" .)

HorizontalLayout <- "[horizontal]" EOLS {
    return types.ElementAttributes{"layout": "horizontal"}, nil
}

QuoteAttributes <- "[quote" WS* ","? author:(QuoteAttribute)? ","? title:(QuoteAttribute)? "]" EOLS {
    return types.NewQuoteAttributes("quote", author, title)
}

VerseAttributes <- "[verse" WS* ","? author:(QuoteAttribute)? ","? title:(QuoteAttribute)? "]" EOLS {
    return types.NewQuoteAttributes("verse", author.(string), title.(string))
}

QuoteAttribute <- (Alphanums / Spaces / (!"," !"]" !EOL .))* {
    return string(c.text), nil
}

InlineAttributes <- "[" attrs:(GenericAttribute)* "]" {
    return types.NewInlineAttributes(attrs.([]interface{}))
} 

// ------------------------------------------
// Sections
// ------------------------------------------
Section <- attributes:(ElementAttributes)?
    level:(("=")+ {   
        // `=` is level 0, etc.
        return (len(c.text)-1), nil 
    })
    &{  
        // use a predicate to make sure that only `=` (level 0) to `======` (level 5) are allowed
        return level.(int) <= 5, nil 
    } 
    WS+ title:(TitleElements) id:(InlineElementID*) EOL {
    return types.NewSection(level.(int), title.([]interface{}), id.([]interface{}), attributes) 
}

TitleElements <- elements:(!Newline !InlineElementID TitleElement)+ { // absorbs heading and trailing spaces
    return types.NewInlineElements(elements.([]interface{}))
} 

TitleElement <- element:(SimpleWord
        / Spaces 
        / CrossReference
        / Passthrough
        / InlineImage 
        / Link
        / InlineFootnote
        / QuotedText
        / DocumentAttributeSubstitution
        / LineBreak
        / OtherWord
        / Parenthesis) {
    return element, nil
}

// ------------------------------------------
// Table of Contents
// ------------------------------------------
TableOfContentsPlaceHolder <- "toc::[]" EOL

// ------------------------------------------
// User Macro
// ------------------------------------------
UserMacroBlock <- name:(UserMacroName) "::" value:(UserMacroValue) attrs:(UserMacroAttributes) {
    return types.NewUserMacroBlock(name.(string), value.(string), attrs.(types.ElementAttributes), string(c.text))
}

InlineUserMacro <- name:(UserMacroName) ":" value:(UserMacroValue) attrs:(UserMacroAttributes) {
    return types.NewInlineUserMacro(name.(string), value.(string), attrs.(types.ElementAttributes), string(c.text))
}

UserMacroName <- ([a-zA-Z0-9] / "_" / "-")+ {
    return string(c.text), nil
}

UserMacroValue <- (Alphanums / (!WS !":" !"[" !EOL .))* {
    return string(c.text), nil
}

UserMacroAttributes <- "[" attrs:(GenericAttribute)* "]" {
    return types.NewInlineAttributes(attrs.([]interface{}))
}

// ------------------------------------------
// File inclusions
// ------------------------------------------
FileInclusion <- incl:("include::" path:(FileLocation) inlineAttributes:(FileIncludeAttributes) { 
        return types.NewFileInclusion(path.(types.Location), inlineAttributes.(types.ElementAttributes), string(c.text))
    }) EOLS {
    return incl.(types.FileInclusion), nil
}

FileIncludeAttributes <- "[" attrs:(LineRangesAttribute / TagRangesAttribute / GenericAttribute)* "]" {
    return types.NewInlineAttributes(attrs.([]interface{}))
} 

LineRangesAttribute <- "lines=" lines:(LineRangesAttributeValue) ","? { 
    return types.NewLineRangesAttribute(lines)
} 

LineRangesAttributeValue <- value:(MultipleLineRanges // TODO: just have MultipleLineRanges, MultipleQuotedLineRanges and UndefinedLineRange?
        / MultipleQuotedLineRanges 
        / MultiLineRange 
        / MultiLineQuotedRange 
        / SingleLineQuotedRange
        / SingleLineRange 
        / UndefinedLineRange) WS* (&"," / &"]") {
    return value, nil
}

MultipleLineRanges <- first:(MultiLineRange / SingleLineRange) 
    others:(";" other:(MultiLineRange / SingleLineRange) {
        return other, nil
    })+ {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

MultipleQuotedLineRanges <- "\"" first:(MultiLineRange / SingleLineRange) 
    others:("," other:(MultiLineRange / SingleLineRange) {
        return other, nil
    })+ "\"" {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

MultiLineRange <- start:(NUMBER) ".." end:(NUMBER) { // eg: lines=12..14
    return types.NewLineRange(start.(int), end.(int))
} 

MultiLineQuotedRange <- "\"" start:(NUMBER) ".." end:(NUMBER) "\"" { // eg: lines=12..14
    return types.NewLineRange(start.(int), end.(int))
} 

SingleLineRange <- singleline:(NUMBER) { // eg: lines=12
    return types.NewLineRange(singleline.(int), singleline.(int))
}

SingleLineQuotedRange <- "\"" singleline:(NUMBER) "\"" { // eg: lines=12
    return types.NewLineRange(singleline.(int), singleline.(int))
}

UndefinedLineRange <- (!"]" !"," !WS .)* {
    return string(c.text), nil
}

TagRangesAttribute <- ("tags=" / "tag=") tags:(TagRangesAttributeValue) ","? { //TODO: check if 'tags'/'tag' is allowed for both single and multiple values
    return types.NewTagRangesAttribute(tags.([]interface{}))
} 

TagRangesAttributeValue <- value:(MultipleTagRanges) WS* (&"," / &"]") {
    return value, nil
}

MultipleTagRanges <- first:(TagRange)
    others:(";" other:(TagRange) {
        return other, nil
    })* {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

TagRange <- tag:(Alphanums / TagWildcard) {
    return types.NewTagRange(tag.(string), true)
} / "!" tag:(Alphanums / TagWildcard) {
    return types.NewTagRange(tag.(string), false)
}

TagWildcard <- stars:(("*")+ {
        return string(c.text), nil
    })
    &{  
        // use a predicate to make sure that only `*` and `**` are allowed
        return len(stars.(string)) <= 2, nil 
    } {
    return stars, nil
}

// ------------------------------------------
// Tag macros in lines of files to include
// ------------------------------------------
IncludedFileLine <- content:(IncludedFileStartTag / IncludedFileEndTag / . {return string(c.text), nil})* EOL {
    return types.NewIncludedFileLine(content.([]interface{}))
}

IncludedFileStartTag <- "tag::" tag:(Alphanums {return string(c.text), nil}) "[]" {
    return types.NewIncludedFileStartTag(tag.(string))
}

IncludedFileEndTag <- "end::" tag:(Alphanums {return string(c.text), nil}) "[]" {
    return types.NewIncludedFileEndTag(tag.(string))
}

// ------------------------------------------
// Lists
// ------------------------------------------
ListItems <- ListItem+

ListItem <- OrderedListItem / UnorderedListItem / LabeledListItem / ContinuedListItemElement

ListParagraph <- comment:(SingleLineComment) {
        return comment, nil
    } / lines:(ListParagraphLine)+ {
        return types.NewParagraph(lines.([]interface{}), nil)
    } 

ListParagraphLine <- !EOF
    !BlankLine 
    !SingleLineComment
    !OrderedListItemPrefix
    !UnorderedListItemPrefix
    !(SimpleLabeledListItemTerm LabeledListItemSeparator) 
    !ListItemContinuation
    !ElementAttribute
    !BlockDelimiter
    line:(
        elements:(InlineElement)+ linebreak:(LineBreak)? { // absorbs heading and trailing spaces
            return types.NewInlineElements(append(elements.([]interface{}), linebreak))
        }) EOL { 
            return line, nil
        }

ListItemContinuation <- "+" EOLS 

ContinuedListItemElement <- blanklines:(BlankLine*) ListItemContinuation element:DocumentBlock{
    return types.NewContinuedListItemElement(-len(blanklines.([]interface{})), element) // offset is negative
}

// ------------------------------------------
// Ordered List Items
// ------------------------------------------
OrderedListItem <- attributes:(ElementAttributes)? prefix:(OrderedListItemPrefix) content:(OrderedListItemContent) {
    return types.NewOrderedListItem(prefix.(types.OrderedListItemPrefix), content.([]interface{}), attributes)
}

OrderedListItemPrefix <- 
    WS* prefix:(
        // implicit numbering: "." to "....."
        depth:((".")+ {   
            // `.` is 1, etc.
            return (len(c.text)), nil 
        }) 
        &{  
            // use a predicate to make sure that only `.` to `.....` are allowed
            return depth.(int) <= 5, nil 
        } 
        {
            switch depth.(int){
            case 1:
                return types.NewOrderedListItemPrefix(types.Arabic, 1)
            case 2:
                return types.NewOrderedListItemPrefix(types.LowerAlpha, 2)
            case 3:
                return types.NewOrderedListItemPrefix(types.LowerRoman, 3)
            case 4:
                return types.NewOrderedListItemPrefix(types.UpperAlpha, 4)
            default:
                return types.NewOrderedListItemPrefix(types.UpperRoman, 5)
            }
        }
        // explicit numbering
        / ([0-9])+ "." {  // numbering style: "1."
            return types.NewOrderedListItemPrefix(types.Arabic, 1)
        } / ([a-z]) "." { // numbering style: "a."
            return types.NewOrderedListItemPrefix(types.LowerAlpha, 1)
        } / ([A-Z]) "." { // numbering style: "A."
            return types.NewOrderedListItemPrefix(types.UpperAlpha, 1)
        } / ([a-z])+ ")" { // numbering style: "i)"
            return types.NewOrderedListItemPrefix(types.LowerRoman, 1)
        } / ([A-Z])+ ")" { // numbering style: "I)"
            return types.NewOrderedListItemPrefix(types.UpperRoman, 1)
        }) WS+ {
    return prefix, nil
}

OrderedListItemContent <- elements:(ListParagraph+) {
    return types.NewListItemContent(elements.([]interface{}))
} 

// ------------------------------------------
// Unordered List Items
// ------------------------------------------
UnorderedListItem <- attributes:(ElementAttributes)? prefix:(UnorderedListItemPrefix) checkstyle:(UnorderedListItemCheckStyle)? content:(UnorderedListItemContent) {
    return types.NewUnorderedListItem(prefix.(types.UnorderedListItemPrefix), checkstyle, content.([]interface{}), attributes)
}

UnorderedListItemPrefix <- 
    WS* prefix:((
        // implicit numbering: "*" to "*****" 
        depth:(("*")+ {   
            // `*` is 1, etc.
            return (len(c.text)), nil 
        }) 
        &{  
            // use a predicate to make sure that only `*` to `*****` are allowed
            return depth.(int) <= 5, nil 
        } 
        {
            switch depth.(int){
            case 1:
                return types.NewUnorderedListItemPrefix(types.OneAsterisk, 1)
            case 2:
                return types.NewUnorderedListItemPrefix(types.TwoAsterisks, 2)
            case 3:
                return types.NewUnorderedListItemPrefix(types.ThreeAsterisks, 3)
            case 4:
                return types.NewUnorderedListItemPrefix(types.FourAsterisks, 4)
            default:
                return types.NewUnorderedListItemPrefix(types.FiveAsterisks, 5)
            }
        }) / depth:(("-") {
            return types.NewUnorderedListItemPrefix(types.Dash, 1)
        })) WS+ {
    return prefix, nil
} 

UnorderedListItemCheckStyle <- &"[" style:(
      "[ ]" { return types.Unchecked, nil } 
    / "[*]" { return types.Checked, nil } 
    / "[x]" { return types.Checked, nil }
    ) WS+ {
        return style, nil
    }

UnorderedListItemContent <- elements:(ListParagraph+) { // Another list or a literal paragraph immediately following a list item will be implicitly included in the list item
    return types.NewListItemContent(elements.([]interface{}))
} 

// ------------------------------------------
// Labeled List Items
// ------------------------------------------
LabeledListItem <- attributes:(ElementAttributes)? term:(SimpleLabeledListItemTerm) separator:(LabeledListItemSeparator) description:(LabeledListItemDescription)? {
    return types.NewLabeledListItem(len(separator.(string)) - 1, term.([]interface{}), description, attributes)
}

SimpleLabeledListItemTerm <- content:((Alphanums / Spaces / (!Newline !LabeledListItemSeparator .))+ {
    return types.NewStringElement(strings.TrimSpace(string(c.text)))
})  {
    return types.NewInlineElements(content)
}

LabeledListItemTerm <- elements:(!Newline !LabeledListItemSeparator LabeledListItemTermElement)+ { // absorbs heading and trailing spaces
    return types.NewInlineElements(elements.([]interface{}))
} 

LabeledListItemTermElement <- element:(SimpleWord
        / Spaces 
        / CrossReference
        / Passthrough
        / InlineImage 
        / Link
        / InlineFootnote
        / QuotedText
        / DocumentAttributeSubstitution
        / LineBreak
        / OtherWord
        / Parenthesis) {
    return element, nil
}

LabeledListItemSeparator <- 
    separator:((":")+ {   
        return string(c.text), nil
    }) 
    &{  
        // use a predicate to make sure that only `::` to `::::` are allowed
        return len(separator.(string)) >= 2 && len(separator.(string)) <= 4, nil 
    } 
    ((WS / Newline)+ / EOL) {
    return separator, nil
}
    
LabeledListItemDescription <- elements:(ListParagraph)+ { 
    return types.NewListItemContent(elements.([]interface{}))
}

// ------------------------------------------
// Admonitions
// ------------------------------------------
AdmonitionKind <- "TIP" {
        return types.Tip, nil
    } / "NOTE" {
        return types.Note, nil
    } / "IMPORTANT" {
        return types.Important, nil
    } / "WARNING" {
        return types.Warning, nil
    } / "CAUTION" {
        return types.Caution, nil
}

// ------------------------------------------
// Paragraphs
// ------------------------------------------
// a paragraph is a group of line ending with a blank line (or end of file)
// a paragraph cannot start with the `section` sequence (`= `, `== `, etc.)
Paragraph <- 
    // admonition paragraph 
    attributes:(ElementAttributes)? t:(AdmonitionKind) ": " lines:(InlineElements)+ { 
        return types.NewAdmonitionParagraph(lines.([]interface{}), t.(types.AdmonitionKind), attributes)
    } / 
    // other kind of paragraph (verse, regular, etc.)
    attributes:(ElementAttributes)? lines:(InlineElements)+ { 
        return types.NewParagraph(lines.([]interface{}), attributes)
} 

// a paragraph whose first line begins with a word surrounded by spaces
SimpleParagraph <- attributes:(ElementAttributes)? 
    &{
        // skip if the '[literal]' attribute was set on this paragraph
        if attrs, ok := attributes.(types.ElementAttributes); ok {
            kind, found := attrs[types.AttrKind]
            return !found || kind != types.Literal, nil
        }
        return true, nil
    }
    firstLine: FirstParagraphLine
    otherLines:(OtherParagraphLine)* { 
    return types.NewParagraph(append([]interface{}{firstLine}, otherLines.([]interface{})...), attributes)
}

ParagraphLines <- firstLine:(FirstParagraphLine) otherLines:(OtherParagraphLine)* {
    return append([]interface{}{firstLine}, otherLines.([]interface{})...), nil
}

FirstParagraphLine <- !(SimpleLabeledListItemTerm LabeledListItemSeparator)
    elements:(SimpleWord InlineElement*) linebreak:(LineBreak)? EOL { 
    return types.NewInlineElements(append(elements.([]interface{}), linebreak))
}

OtherParagraphLine <- elements:(InlineElements) {
    return elements, nil
}

VerseParagraph <- 
    // admonition paragraph 
    attributes:(ElementAttributes)?
    &{
        if attrs, ok := attributes.(types.ElementAttributes); ok {
            kind, ok := attrs[types.AttrKind]
            return ok && kind == types.Verse, nil
        }
        return false, nil
    }
    t:(AdmonitionKind) ": " lines:(InlineElements)+ { 
        return types.NewAdmonitionParagraph(lines.([]interface{}), t.(types.AdmonitionKind), attributes)
    } / 
    // other kind of paragraph (verse, regular, etc.)
    attributes:(ElementAttributes)?
    &{
        if attrs, ok := attributes.(types.ElementAttributes); ok {
            kind, ok := attrs[types.AttrKind]
            return ok && kind == types.Verse, nil
        }
        return false, nil
    }
    lines:(InlineElements)+ { 
        return types.NewParagraph(lines.([]interface{}), attributes)
    } 
    
InlineElements <- !EOF !BlankLine
    elements:(comment:(SingleLineComment) {
        return types.NewInlineElements([]interface{}{comment})
    } / !BlockDelimiter elements:(InlineElement)+ linebreak:(LineBreak)? EOL { 
        return types.NewInlineElements(append(elements.([]interface{}), linebreak))
    }) {
        return elements, nil
    }

InlineElement <- !EOL !LineBreak 
    element:(SimpleWord
        / Spaces 
        / InlineImage 
        / Link 
        / Passthrough 
        / InlineFootnote 
        / QuotedText 
        / CrossReference 
        / InlineUserMacro 
        / DocumentAttributeSubstitution 
        / InlineElementID 
        / OtherWord
        / ConceleadIndexTerm
        / Parenthesis) {
    return element, nil
}


// special case for re-parsing a group of elements after a document substitution:
// we should treat substitution that did not happen (eg: missing attribute) as regular
// strings - (used by the inline element renderer)
InlineElementsWithoutSubtitution <- !BlankLine !BlockDelimiter elements:(InlineElementWithoutSubtitution)* linebreak:(LineBreak)? EOL { 
    return types.NewInlineElements(append(elements.([]interface{}), linebreak))
} 

InlineElementWithoutSubtitution <- !EOL !LineBreak 
    element:(SimpleWord
        / Spaces 
        / InlineImage 
        / Link 
        / Passthrough 
        / QuotedText 
        / CrossReference 
        / InlineElementID
        / OtherWord
        / Parenthesis) {
    return element, nil
}

VerbatimParagraph <- attributes:(ElementAttributes)? lines:(!EOF line:(VerbatimParagraphLine) {
    return line, nil
})+ {
    return types.NewParagraph(lines.([]interface{}), attributes)
}

VerbatimParagraphLine <- !BlockDelimiter !BlankLine elements:(VerbatimParagraphLineElement)* linebreak:(LineBreak)? EOL { 
    return types.NewInlineElements(append(elements.([]interface{}), linebreak))
} 

VerbatimParagraphLineElement <- (!EOL !LineBreak .)+ {
    return string(c.text), nil
}

// ----------------------------------------------------------------------------
// Explicit line breaks
// ----------------------------------------------------------------------------
LineBreak <- WS "+" WS* &EOL {
    return types.NewLineBreak()    
}

// ----------------------------------------------------------------------------
// Quoted Texts (bold, italic and monospace) including substitution prevention
// ----------------------------------------------------------------------------
QuotedText <- !WS text:(BoldText 
            / ItalicText 
            / MonospaceText 
            / SubscriptText 
            / SuperscriptText 
            / EscapedBoldText 
            / EscapedItalicText 
            / EscapedMonospaceText 
            / EscapedSubscriptText 
            / EscapedSuperscriptText
            / SubscriptOrSuperscriptPrefix) { // if a '^' or '~' is alone (ie, badly formatted superscript or subscript, then accept it as-is) 
    return text, nil
}

QuotedTextPrefix <- "**" / "*" / "__" / "_" / "``" / "`" / "^" / "~"

SubscriptOrSuperscriptPrefix <- "^" / "~" { // rule used withn `words` to detect superscript or subscript portions, eg in math formulae.
    return string(c.text), nil
}

OneOrMoreBackslashes <- `\`+ {
    return string(c.text), nil
}

TwoOrMoreBackslashes <- `\\` `\`* {
    return string(c.text), nil
}

// -----------------
// Bold text
// -----------------

BoldText <- DoubleQuoteBoldText / SingleQuoteBoldText

DoubleQuoteBoldText <- !`\\` "**" elements:(DoubleQuoteBoldTextElements) "**" { // double punctuation must be evaluated first
    return types.NewQuotedText(types.Bold, elements.([]interface{}))
} 

DoubleQuoteBoldTextElements <- DoubleQuoteBoldTextElement (!("**") (WS / DoubleQuoteBoldTextElement))*  // may start and end with spaces

DoubleQuoteBoldTextElement <- !Newline element:(SingleQuoteBoldText 
        / ItalicText 
        / MonospaceText
        / SubscriptText
        / SuperscriptText
        / InlineImage 
        / QuotedLink 
        / Passthrough 
        / DocumentAttributeSubstitution
        / NonDoubleQuoteBoldText
        / Parenthesis) { // word with quote punctuation is only accepted if nothing matched before, so we have a chance to stop
    return element, nil
}

NonDoubleQuoteBoldText <- (.) (!"**" !WS !"^" !"~" !Newline !Parenthesis .)* { 
    return types.NewStringElement(string(c.text))
}

SingleQuoteBoldText <- !`\` "*" !"*" elements:(SingleQuoteBoldTextElements) "*" { // single punctuation cannot be followed by a character (needs '**' to emphazise a portion of a word)
    return types.NewQuotedText(types.Bold, elements.([]interface{}))
} / !`\\` "*" elements:("*" SingleQuoteBoldTextElements) "*" { // unbalanced `**` vs `*` punctuation.
    return types.NewQuotedText(types.Bold, elements.([]interface{})) // include the second heading `*` as a regular StringElement in the bold content
} 

SingleQuoteBoldTextElements <- !WS SingleQuoteBoldTextElement (!("*" !Alphanum) WS* SingleQuoteBoldTextElement)* 

SingleQuoteBoldTextElement <- !Newline element:(DoubleQuoteBoldText
        / ItalicText 
        / MonospaceText
        / SubscriptText
        / SuperscriptText
        / InlineImage 
        / QuotedLink 
        / Passthrough 
        / DocumentAttributeSubstitution
        / NonSingleQuoteBoldText
        / Parenthesis) { // word with quote punctuation is only accepted if nothing matched before, so we have a chance to stop
    return element, nil
}

NonSingleQuoteBoldText <- (.) (!"*" !WS !"^" !"~" !Newline !Parenthesis .)* { 
    return types.NewStringElement(string(c.text))
}

EscapedBoldText <- 
    backslashes:(TwoOrMoreBackslashes) "**" elements:(DoubleQuoteBoldTextElements) "**" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "**", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "**" elements:(SingleQuoteBoldTextElements) "*" { // unbalanced `**` vs `*` punctuation
        result := append([]interface{}{"*"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "*", result)
    } / backslashes:(OneOrMoreBackslashes) "*" elements:(SingleQuoteBoldTextElements) "*" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "*", elements.([]interface{}))
} 

// -----------------
// Italic text
// -----------------

ItalicText <- DoubleQuoteItalicText / SingleQuoteItalicText

DoubleQuoteItalicText <- !`\\` "__" elements:(DoubleQuoteItalicTextElements) "__" { // double punctuation must be evaluated first
    return types.NewQuotedText(types.Italic, elements.([]interface{}))
}

DoubleQuoteItalicTextElements <- DoubleQuoteItalicTextElement (!("__") (WS / DoubleQuoteItalicTextElement))*  // may start and end with spaces

DoubleQuoteItalicTextElement <- !Newline element:(SingleQuoteItalicText 
        / BoldText 
        / MonospaceText
        / SubscriptText
        / SuperscriptText
        / InlineImage 
        / QuotedLink 
        / Passthrough 
        / NonDoubleQuoteItalicText
        / Parenthesis) { // word with quote punctuation is only accepted if nothing matched before, so we have a chance to stop
    return element, nil
}

NonDoubleQuoteItalicText <- (.) (!"__" !"^" !"~" !Newline !Parenthesis .)* { 
    return types.NewStringElement(string(c.text))
}

SingleQuoteItalicText <- !`\` "_" !"_" elements:(SingleQuoteItalicTextElements) "_" { // single punctuation cannot be followed by a character (needs '__' to emphazise a portion of a word)
    return types.NewQuotedText(types.Italic, elements.([]interface{}))
} / !`\\` "_" elements:("_" SingleQuoteItalicTextElements) "_" { // unbalanced `__` vs `_` punctuation.
    return types.NewQuotedText(types.Italic, elements.([]interface{})) // include the second heading `_` as a regular StringElement in the italic content
} 

SingleQuoteItalicTextElements <- !WS SingleQuoteItalicTextElement (!("_" !Alphanum) WS* SingleQuoteItalicTextElement)*

SingleQuoteItalicTextElement <- !Newline element:(DoubleQuoteItalicText
        / BoldText 
        / MonospaceText
        / SubscriptText
        / SuperscriptText
        / InlineImage 
        / QuotedLink 
        / Passthrough 
        / NonSingleQuoteItalicText
        / Parenthesis) { // word with quote punctuation is only accepted if nothing matched before, so we have a chance to stop
    return element, nil
}

NonSingleQuoteItalicText <- (.) (!"_" !WS !"^" !"~" !Newline !Parenthesis .)* { 
    return types.NewStringElement(string(c.text))
}

EscapedItalicText <- 
    backslashes:(TwoOrMoreBackslashes) "__" elements:(DoubleQuoteItalicTextElements) "__" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "__", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "__" elements:(SingleQuoteItalicTextElements) "_" { // unbalanced `__` vs `_` punctuation
        result := append([]interface{}{"_"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "_", result)
    } / backslashes:(OneOrMoreBackslashes) "_" elements:(SingleQuoteItalicTextElements) "_" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "_", elements.([]interface{}))
} 

// -----------------
// Monospace text
// -----------------
MonospaceText <- DoubleQuoteMonospaceText / SingleQuoteMonospaceText

DoubleQuoteMonospaceText <- !`\\` "``" elements:(DoubleQuoteMonospaceTextElements) "``" { // double punctuation must be evaluated first
    return types.NewQuotedText(types.Monospace, elements.([]interface{}))
}

DoubleQuoteMonospaceTextElements <- DoubleQuoteMonospaceTextElement (!("``") (WS / DoubleQuoteMonospaceTextElement))* // may start and end with spaces

DoubleQuoteMonospaceTextElement <- !Newline element:(SingleQuoteMonospaceText 
        / BoldText
        / ItalicText 
        / SubscriptText
        / SuperscriptText
        / InlineImage 
        / QuotedLink 
        / Passthrough 
        / NonDoubleQuoteMonospaceText
        / Parenthesis) { // word with quote punctuation is only accepted if nothing matched before, so we have a chance to stop
    return element, nil
}

NonDoubleQuoteMonospaceText <- (.) (!"``" !WS !"^" !"~" !Newline !Parenthesis .)* { 
    return types.NewStringElement(string(c.text))
}

SingleQuoteMonospaceText <- !`\` !"``" "`" elements:(SingleQuoteMonospaceTextElements) "`" { // single punctuation cannot be followed by a character (needs "``" to emphazise a portion of a word)
    return types.NewQuotedText(types.Monospace, elements.([]interface{}))
} / !`\\` "`" elements:("`" SingleQuoteMonospaceTextElements) "`" { // unbalanced "``" vs "`" punctuation.
    return types.NewQuotedText(types.Monospace, elements.([]interface{})) // include the second heading "`" as a regular StringElement in the monospace content
} 

SingleQuoteMonospaceTextElements <- !WS SingleQuoteMonospaceTextElement (!("`" !Alphanum) WS* SingleQuoteMonospaceTextElement)*

SingleQuoteMonospaceTextElement <-  element:(Newline // allows multiline
        / DoubleQuoteMonospaceText 
        / BoldText 
        / ItalicText
        / SubscriptText
        / SuperscriptText
        / InlineImage 
        / QuotedLink 
        / Passthrough 
        / NonSingleQuoteMonospaceText
        / Parenthesis) { // word with quote punctuation is only accepted if nothing matched before, so we have a chance to stop
    return element, nil
}

NonSingleQuoteMonospaceText <- (.) (!WS !"`" !"^" !"~" !Newline !Parenthesis .)* { // break at multiline
    return types.NewStringElement(string(c.text))
}

EscapedMonospaceText <- 
    backslashes:(TwoOrMoreBackslashes) "``" elements:(DoubleQuoteMonospaceTextElements) "``" { // double punctuation must be evaluated first
        return types.NewEscapedQuotedText(backslashes.(string), "``", elements.([]interface{}))
    } / backslashes:(OneOrMoreBackslashes) "``" elements:(SingleQuoteMonospaceTextElements) "`" { // unbalanced "``" vs "`" punctuation
        result := append([]interface{}{"`"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "`", result)
    } / backslashes:(OneOrMoreBackslashes) "`" elements:(SingleQuoteMonospaceTextElements) "`" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "`", elements.([]interface{}))
} 

SubscriptText <- !`\` "~" element:(SubscriptTextElement) "~" { // wraps a single word
    return types.NewQuotedText(types.Subscript, element)
}

SubscriptTextElement <- QuotedText / NonSubscriptText 

NonSubscriptText <- (!Newline !WS !"~" .)+ { 
    return c.text, nil
}

EscapedSubscriptText <- backslashes:(OneOrMoreBackslashes) "~" element:(SubscriptTextElement) "~" { // simple punctuation must be evaluated last
    return types.NewEscapedQuotedText(backslashes.(string), "~", element)
} 

SuperscriptText <- !`\` "^" element:(SuperscriptTextElement) "^" { // wraps a single word
    return types.NewQuotedText(types.Superscript, element)
}

SuperscriptTextElement <- QuotedText / NonSuperscriptText 

NonSuperscriptText <- (!Newline !WS !"^" .)+ { 
    return c.text, nil
}

EscapedSuperscriptText <- backslashes:(OneOrMoreBackslashes) "^" element:(SuperscriptTextElement) "^" { // simple punctuation must be evaluated last
    return types.NewEscapedQuotedText(backslashes.(string), "^", element)
} 

// ------------------------------------------
// Passthrough
// ------------------------------------------
Passthrough <- TriplePlusPassthrough / SinglePlusPassthrough / PassthroughMacro

SinglePlusPassthroughPrefix <- "+"

SinglePlusPassthrough <- SinglePlusPassthroughPrefix content:(SinglePlusPassthroughContent) SinglePlusPassthroughPrefix !Alphanum {
    return types.NewPassthrough(types.SinglePlusPassthrough, []interface{}{content})
}

SinglePlusPassthroughContent <- ((!SinglePlusPassthroughPrefix !WS !Newline .) (!(WS+ SinglePlusPassthroughPrefix) !SinglePlusPassthroughPrefix !Newline .)* { // no space in the first or last position of the content, but allowed elsewhere
    return types.NewStringElement(string(c.text))
}) / ((!WS !Newline !SinglePlusPassthroughPrefix .)  { // a single character
    return types.NewStringElement(string(c.text))
})

TriplePlusPassthroughPrefix <- "+++"

TriplePlusPassthrough <- TriplePlusPassthroughPrefix content:(TriplePlusPassthroughContent) TriplePlusPassthroughPrefix !Alphanum {
    return types.NewPassthrough(types.TriplePlusPassthrough, []interface{}{content})
}

TriplePlusPassthroughContent <- ((!TriplePlusPassthroughPrefix .)* { // spaces and newlines are also allowed in the first or last position of the content and elsewhere too
    return types.NewStringElement(string(c.text))
}) / ((!WS !Newline !TriplePlusPassthroughPrefix .)?  { // a single character
    return types.NewStringElement(string(c.text))
})

PassthroughMacro <- "pass:[" content:(PassthroughMacroCharacter)* "]" {
    return types.NewPassthrough(types.PassthroughMacro, []interface{}{content})
} / "pass:q[" content:(QuotedText / PassthroughMacroCharacter)* "]" {
    return types.NewPassthrough(types.PassthroughMacro, content.([]interface{}))
}

PassthroughMacroCharacter <- (Alphanums / Spaces / (!"]" .){
    return types.NewStringElement(string(c.text))
})

// ------------------------------------------
// Cross References
// ------------------------------------------
CrossReference <- InternalCrossReference / ExternalCrossReference 

InternalCrossReference <- "<<" id:(ID) WS* "," label:(CrossReferenceLabel) ">>" {
    return types.NewInternalCrossReference(id.(string), label.(string))
} / "<<" id:(ID) ">>" {
    return types.NewInternalCrossReference(id.(string), nil)
} 

ExternalCrossReference <- "xref:" url:(FileLocation) inlineAttributes:(LinkAttributes) {
    return types.NewExternalCrossReference(url.(types.Location), inlineAttributes.(types.ElementAttributes))
}

CrossReferenceLabel <- (Alphanums / Spaces / (!">>"  .))+ {
    return string(c.text), nil
}

// ------------------------------------------
// Links
// ------------------------------------------
Link <- RelativeLink / ExternalLink

// url preceeding with `link:` MUST be followed by square brackets
RelativeLink <- "link:" url:(Location / FileLocation) inlineAttributes:(LinkAttributes) {
    return types.NewInlineLink(url.(types.Location), inlineAttributes.(types.ElementAttributes))
}

ExternalLink <- url:(Location) inlineAttributes:(LinkAttributes)? {
    return types.NewInlineLink(url.(types.Location), inlineAttributes)
}

LinkAttributes <- TextOnlyLinkAttributes / TextAndMoreLinkAttributes

TextOnlyLinkAttributes <- "[" text:(LinkTextWithCommaAttribute)? "]" {
    return types.NewInlineLinkAttributes(text, nil)
} 

LinkTextWithCommaAttribute <- 
    // surrounded with double quotes
    "\"" elements:(!"=" !"]" !"\"" (QuotedText / SimpleWord / Spaces / ((!WS .) {
        return types.NewStringElement(string(c.text))
    })))+ "\"" Spaces* &(!"=") {
        return types.NewInlineElements(elements.([]interface{}))
    } /
    // not surrounded with double quotes
    elements:(!"=" !"]" (QuotedText / SimpleWord / Spaces / ((!WS .) {
        return types.NewStringElement(string(c.text))
    })))+ &(!"=") {
        return types.NewInlineElements(elements.([]interface{}))
    }


TextAndMoreLinkAttributes <- "[" text:(LinkTextAttribute)? ","? WS* otherattrs:(GenericAttribute)* "]" {
    return types.NewInlineLinkAttributes(text, otherattrs.([]interface{}))
} 

LinkTextAttribute <- 
    // surrounded with double quotes
    "\"" elements:(!"=" !"]" !"\"" (QuotedText / SimpleWord / Spaces / ((!QuotedTextPrefix .) {
        return types.NewStringElement(string(c.text))
    })))+ "\"" Spaces* &(!"=") {
        return types.NewInlineElements(elements.([]interface{}))
    } /
    // not surrounded with double quotes
    elements:(!"=" !"," !"]" (QuotedText / SimpleWord / Spaces / ((!QuotedTextPrefix .) {
        return types.NewStringElement(string(c.text))
    })))+ &(!"=") {
        return types.NewInlineElements(elements.([]interface{}))
    }

// rule used after document attribute substitution, to discover links 
InlineLinks <- 
    elements:(SimpleWord
        / Spaces 
        / ResolvedLink 
        / OtherWord
        / Parenthesis
        / Newline)+ EOF {
    return types.NewInlineElements(elements.([]interface{}))
}

ResolvedLink <- ResolvedRelativeLink / ResolvedExternalLink // links without DocumentAttributeSubstitution

// url preceeding with `link:` MUST be followed by square brackets
ResolvedRelativeLink <- "link:" url:(ResolvedLocation / ResolvedFileLocation) inlineAttributes:(LinkAttributes) {
    return types.NewInlineLink(url.(types.Location), inlineAttributes.(types.ElementAttributes))
}

ResolvedExternalLink <- url:(ResolvedLocation) inlineAttributes:(LinkAttributes)? {
    return types.NewInlineLink(url.(types.Location), inlineAttributes)
}

QuotedLink <- RelativeLink / ExternalQuotedLink

ExternalQuotedLink <- url:(Location) inlineAttributes:(LinkAttributes) { // here attributes are required, so we can safely use the `_` and `*` characters in the URL without messing with the bold or italic markers.
    return types.NewInlineLink(url.(types.Location), inlineAttributes)
}

// ------------------------------------------
// Images
// ------------------------------------------
ImageBlock <- attributes:(ElementAttributes)? "image::" path:(Location / FileLocation) inlineAttributes:(ImageAttributes) EOLS {
    return types.NewImageBlock(path.(types.Location), inlineAttributes.(types.ElementAttributes), attributes)
}

InlineImage <- "image:" !":" path:(Location / FileLocation) inlineAttributes:(ImageAttributes) {
    return types.NewInlineImage(path.(types.Location), inlineAttributes.(types.ElementAttributes))
}

ImageAttributes <- "[" alt:(StandaloneAttributeValue)? ","? width:(StandaloneAttributeValue)? ","? height:(StandaloneAttributeValue)? ","? WS* otherattrs:(GenericAttribute)* "]" {
    return types.NewImageAttributes(alt, width, height, otherattrs.([]interface{}))
}

// ------------------------------------------------------------------------------------
// Inline foot notes
// ------------------------------------------------------------------------------------
InlineFootnote <- "footnote:[" content:(FootnoteContent) "]" {
    return types.NewFootnote("", content.([]interface{}))
} / "footnoteref:[" ref:(FootnoteRef) "," content:(FootnoteContent) "]" {
    return types.NewFootnote(ref.(string), content.([]interface{}))
} / "footnoteref:[" ref:(FootnoteRef) "]" {
    return types.NewFootnote(ref.(string), []interface{}{}) // foot note referring to another note
}

FootnoteRef <- (Alphanums / Spaces / (!"," !"]" !EOL  .))*  { // footnote ID not may span multiple lines
    return string(c.text), nil
}

FootnoteContent <- elements:(!"]" !EOL WS* !InlineElementID InlineElement WS*)+  { // footnote content may span multiple lines
    return types.NewInlineElements(elements.([]interface{}))
}

// ------------------------------------------------------------------------------------
// Delimited Blocks 
// ------------------------------------------------------------------------------------
DelimitedBlock <- !Alphanum // quick escape
    block:(FencedBlock 
        / ListingBlock 
        / ExampleBlock 
        / VerseBlock 
        / QuoteBlock 
        / SidebarBlock
        / SingleLineComment
        / Table
        / CommentBlock) {
    return block, nil
}

BlockDelimiter <- LiteralBlockDelimiter 
                / FencedBlockDelimiter 
                / ListingBlockDelimiter 
                / ExampleBlockDelimiter 
                / CommentBlockDelimiter 
                / QuoteBlockDelimiter
                / SidebarBlockDelimiter


// -------------------------------------------------------------------------------------
// Fenced Blocks
// -------------------------------------------------------------------------------------
FencedBlockDelimiter <- "```" EOLS

FencedBlock <- attributes:(ElementAttributes)? FencedBlockDelimiter content:(FencedBlockContent)* (FencedBlockDelimiter / EOF) {
    return types.NewDelimitedBlock(types.Fenced, content.([]interface{}), types.None, attributes)
}

FencedBlockContent <- BlankLine / FileInclusion / ListItem / FencedBlockParagraph

// blocks content
FencedBlockParagraph <- lines:(FencedBlockParagraphLine)+ {
    return types.NewParagraph(lines.([]interface{}), types.ElementAttributes{})
} 

FencedBlockParagraphLine <- !FencedBlockDelimiter !BlankLine line:(InlineElements) {
    return line, nil
}

// -------------------------------------------------------------------------------------
// Listing blocks
// -------------------------------------------------------------------------------------
ListingBlockDelimiter <- "----" EOLS

ListingBlock <- attributes:(ElementAttributes)? ListingBlockDelimiter content:(ListingBlockElement)* (ListingBlockDelimiter / EOF) {
    return types.NewDelimitedBlock(types.Listing, content.([]interface{}), types.None, attributes)
}

ListingBlockElement <- FileInclusion / ListingBlockParagraph / BlankLine

ListingBlockParagraph <- lines:(ListingBlockParagraphLine)+ { 
    return types.NewParagraph(lines.([]interface{}), nil) // no attributes supported
}

ListingBlockParagraphLine <- !ListingBlockDelimiter line:(!EOF (Alphanums / Spaces / (!EOL .))+ {return string(c.text), nil }) EOL { // skip EOL in line content, and stop when quote block delimiter is encountered
    return types.NewInlineElements(line)
}

// -------------------------------------------------------------------------------------
// Example blocks
// -------------------------------------------------------------------------------------
ExampleBlockDelimiter <- "====" EOLS

ExampleBlock <- attributes:(ElementAttributes)? ExampleBlockDelimiter content:(BlankLine / FileInclusion / ListItem / ExampleBlockParagraph)*  (ExampleBlockDelimiter / EOF) {
    return types.NewDelimitedBlock(types.Example, content.([]interface{}), types.None, attributes)
}

// blocks content
ExampleBlockParagraph <- lines:(ExampleBlockParagraphLine)+ {
    return types.NewParagraph(lines.([]interface{}), types.ElementAttributes{})
} 

ExampleBlockParagraphLine <- !ExampleBlockDelimiter !BlankLine line:(InlineElements) {
    return line, nil
}

// -------------------------------------------------------------------------------------
// Quote blocks
// -------------------------------------------------------------------------------------
QuoteBlockDelimiter <- "____" EOLS // same for verse blocks

QuoteBlock <- attributes:(ElementAttributes)? QuoteBlockDelimiter content:(QuoteBlockElement)* (QuoteBlockDelimiter / EOF) {
    return types.NewDelimitedBlock(types.Quote, content.([]interface{}), types.None, attributes)
}

QuoteBlockElement <- 
    !QuoteBlockDelimiter !EOF element:(BlankLine 
            / FileInclusion
            / ImageBlock 
            / ListItem
            / FencedBlock
            / ListingBlock
            / ExampleBlock
            / CommentBlock
            / SingleLineComment
            / QuoteBlock 
            / SidebarBlock
            / Table 
            / LiteralBlock 
            / DocumentAttributeDeclaration 
            / DocumentAttributeReset 
            / TableOfContentsPlaceHolder
            / QuoteBlockParagraph) {
        return element, nil
    } 

QuoteBlockParagraph <- lines:(InlineElements)+ { 
    return types.NewParagraph(lines.([]interface{}), types.ElementAttributes{})
}

// -------------------------------------------------------------------------------------
// Verse blocks
// -------------------------------------------------------------------------------------
// VerseBlockDelimiter: see QuoteBlockDelimiter

VerseBlock <- attributes:(ElementAttributes) 
    &{  
        kind := attributes.(types.ElementAttributes).GetAsString("kind") // once we got the attributes, check that `[verse]`  was set
        return kind == "verse", nil
    } 
    QuoteBlockDelimiter content:(VerseBlockElement)* (QuoteBlockDelimiter / EOF) {
        return types.NewDelimitedBlock(types.Verse, content.([]interface{}), types.None, attributes)
    }

VerseBlockElement <- VerseFileInclude / BlankLine / VerseBlockParagraph

VerseFileInclude <- !QuoteBlockDelimiter include:(FileInclusion) {
    return include, nil
}

// blocks content
VerseBlockParagraph <- lines:(VerseBlockParagraphLine)+ {
    return types.NewParagraph(lines.([]interface{}), nil)
} 

VerseBlockParagraphLine <- !QuoteBlockDelimiter !BlankLine line:(elements:(VerseBlockParagraphLineElement)+ EOL {
    return types.NewInlineElements(elements.([]interface{}))
}) {
    return line, nil
}

VerseBlockParagraphLineElement <- !EOL !LineBreak 
    element:(Spaces 
        / InlineImage 
        / Link 
        / Passthrough 
        / InlineFootnote 
        / QuotedText 
        / CrossReference 
        / InlineUserMacro 
        / DocumentAttributeSubstitution 
        / InlineElementID 
        / OtherWord
        / Parenthesis) {
    return element, nil
}

// -------------------------------------------------------------------------------------
// Sidebars
// -------------------------------------------------------------------------------------
SidebarBlockDelimiter <- "****" EOLS

SidebarBlock <- attributes:(ElementAttributes)? SidebarBlockDelimiter content:(SidebarBlockContent)*  (SidebarBlockDelimiter / EOF) {
    return types.NewDelimitedBlock(types.Sidebar, content.([]interface{}), types.None, attributes)
}

SidebarBlockContent <- BlankLine / FileInclusion / ListItem / NonSidebarBlock / SidebarBlockParagraph

NonSidebarBlock <- !SidebarBlock content:(DelimitedBlock) {
    return content, nil
}

// blocks content
SidebarBlockParagraph <- lines:(SidebarBlockParagraphLine)+ {
    return types.NewParagraph(lines.([]interface{}), types.ElementAttributes{})
} 

SidebarBlockParagraphLine <- !SidebarBlockDelimiter !BlankLine line:(InlineElements) {
    return line, nil
}


// -------------------------------------------------------------------------------------
// Tables
// -------------------------------------------------------------------------------------
Table <- attributes:(ElementAttributes)? TableDelimiter
    header:(TableLineHeader)?
    lines:(TableLine)*
    (TableDelimiter / EOF) { // end delimiter or end of file
        return types.NewTable(header, lines.([]interface{}), attributes)
}

TableCellSeparator <- "|" WS*

TableDelimiter <- "|===" EOLS
        
// table line header is a line followed by a blankline
TableLineHeader <- !TableDelimiter cells:(TableCell)+ EOL BlankLine {
    return types.NewTableLine(cells.([]interface{}))
}

TableLine <- !TableDelimiter cells:(TableCell)+ EOL BlankLine* {
    return types.NewTableLine(cells.([]interface{}))
}

TableCell <- TableCellSeparator elements:(!TableCellSeparator !EOL WS* InlineElement WS*)+ {
    return types.NewInlineElements(elements)
}

// -------------------------------------------------------------------------------------
// Comments
// -------------------------------------------------------------------------------------
CommentBlockDelimiter <- "////"

CommentBlock <- CommentBlockDelimiter WS* Newline content:(CommentBlockLine)*  ((CommentBlockDelimiter EOLS) / EOF) {
    return types.NewDelimitedBlock(types.Comment, content.([]interface{}), types.Verbatim, nil)
}

CommentBlockLine <- (Alphanums / Spaces / (!CommentBlockDelimiter !EOL .))* EOL {
    return string(c.text), nil
}

SingleLineComment <- !CommentBlockDelimiter WS* "//" content:(SingleLineCommentContent) EOL {
    return types.NewSingleLineComment(content.(string))
}

SingleLineCommentContent <- (Alphanums / Spaces / (!EOL  .))* {
    return string(c.text), nil
}


// -------------------------------------------------------------------------------------
// Literal Blocks (see http://asciidoctor.org/docs/user-manual/#literal-text-and-blocks)
// -------------------------------------------------------------------------------------
LiteralBlock <- ParagraphWithLiteralAttribute / ParagraphWithHeadingSpaces / ParagraphWithLiteralBlockDelimiter

LiteralBlockDelimiter <- "...."

// paragraph indented with one or more spaces on the first line
ParagraphWithHeadingSpaces <- attributes:(ElementAttributes)? lines:(ParagraphWithHeadingSpacesLines) {
    return types.NewLiteralBlock(types.LiteralBlockWithSpacesOnFirstLine, lines.([]interface{}), attributes)
}

// first line MUST start with one (or more) space. Stop when reaching a blank line
ParagraphWithHeadingSpacesLines <- 
    firstLine:(WS (Alphanums / Spaces / (!EOL  .){
        return string(c.text), nil
    })+ {
        return string(c.text), nil
    }) EOL // do not include the trailing 'EOL' on the first line
    otherLines:(
        !BlankLine 
        otherLine:((Alphanums / Spaces / (!EOL  .))+ {
            return string(c.text), nil
        }) EOL {
            return otherLine, nil // do not include the trailing 'EOL'
        })* { 
    return append([]interface{}{firstLine}, otherLines.([]interface{})...), nil
}

// paragraph with the literal block delimiter (`....`)
ParagraphWithLiteralBlockDelimiter <- attributes:(ElementAttributes)?
        LiteralBlockDelimiter WS* Newline lines:(ParagraphWithLiteralBlockDelimiterLines) ((LiteralBlockDelimiter EOLS) / EOF) {
    return types.NewLiteralBlock(types.LiteralBlockWithDelimiter, lines.([]interface{}), attributes)
}

// include all lines until delimiter is reached
ParagraphWithLiteralBlockDelimiterLines <- lines:(ParagraphWithLiteralBlockDelimiterLine)* {
    return lines.([]interface{}), nil
}

ParagraphWithLiteralBlockDelimiterLine <-         
    line:((Alphanums / Spaces / (!LiteralBlockDelimiter !EOL .))* {
        return string(c.text), nil
    }) EOL { 
        return line, nil // do not include the trailing 'EOL'
}

// paragraph with the literal attribute (`[literal]`)
ParagraphWithLiteralAttribute <- 
    attributes:(ElementAttributes)?
    &{
        if attrs, ok := attributes.(types.ElementAttributes); ok {
            kind, ok := attrs[types.AttrKind]
            return ok && kind == types.Literal, nil
        }
        return false, nil
    }
    lines:(ParagraphWithLiteralAttributeLines) {
        return types.NewLiteralBlock(types.LiteralBlockWithAttribute, lines.([]interface{}), attributes)
    }

LiteralKind <- "literal" {
    return string(c.text), nil
}

// include all lines until blankline
ParagraphWithLiteralAttributeLines <- lines:(ParagraphWithLiteralAttributeLine)+ { 
    return lines.([]interface{}), nil
}

ParagraphWithLiteralAttributeLine <- line:(!(BlankLine) (Alphanums / Spaces / (!EOL  .))+ {
    return string(c.text), nil
}) EOL {
    return line, nil // do not include the trailing 'EOL'
}

// ------------------------------------------
// Index Terms
// ------------------------------------------
ConceleadIndexTerm <- "(((" term1:Alphanums term2:(WS* "," WS* content:Alphanums {
        return content, nil
    })? term3:(WS* "," WS* content:Alphanums {
        return content, nil
    })? ")))" {
        return types.NewConceleadIndexTerm(term1, term2, term3)
    }

// ------------------------------------------
// BlankLine
// ------------------------------------------
BlankLine <- !EOF EOLS {
    return types.NewBlankLine()
}

// ------------------------------------------
// Base Types
// ------------------------------------------
Alphanum <- [\pL0-9]

Parenthesis <- "(" / ")" / "[" / "]" / "{" / "}" 

Alphanums <- [\pL0-9]+ {
    return string(c.text), nil
}

Dot <- "."

SimpleWord <- Alphanums &(WS / EOL) { // very straightforward content: alphanums followed by spaces but not the "+" signs because it needs a heading space to become a LineBreak element
    return types.NewStringElement(string(c.text))
}

// a word may end with a dot, but cannot have dots within
OtherWord <- (Alphanums / QuotedTextPrefix / ((!Newline !WS !Dot !QuotedTextPrefix !LabeledListItemSeparator !Parenthesis .) Dot? { // TODO: remove check on parenthesis and dot?
    return types.NewStringElement(string(c.text))
})+ / "."+){ // word cannot contain parenthesis. Dots and ellipsis are treated as independent words (but will be combined afterwards)
    return types.NewStringElement(string(c.text))
}

Spaces <- WS+ 

FileLocation <- elements:(FILENAME / DocumentAttributeSubstitution)+ {
    return types.NewLocation(elements.([]interface{}))
}

ResolvedFileLocation <- elements:(!EOL !WS !"[" .)+ {
    return types.NewLocation(elements.([]interface{}))
}

Location <- elements:(URL_SCHEME (FILENAME / DocumentAttributeSubstitution)+) {
    return types.NewLocation(elements.([]interface{}))
}

FILENAME <- ([ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~:/?#@!$&;=()*+,_%] / "-" / ".")+ // not supported for now: "[" "]". Excluded: "{" and "}" as they may be used for document attribute substitutions

ResolvedLocation <- elements:(URL_SCHEME RESOLVED_FILENAME) {
    return types.NewLocation(elements.([]interface{}))
}

RESOLVED_FILENAME <- ([ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~:/?#@!$&;=()*+_,%{}] / "-" / ".")+ // here, `{` and `}` are valid characters

URL <- (Alphanums / (!Newline !WS !"[" !"]"  .))+ {
    return string(c.text), nil
}

URL_SCHEME <- "http://" / "https://" / "ftp://" / "irc://" / "mailto:"

ID <- (Alphanums / (!Newline !WS !"[" !"]" !"<<" !">>" !","  .))+ {
    return string(c.text), nil
}

DIGIT <- [0-9] {
    return string(c.text), nil
}

NUMBER <- "-"? DIGIT+ {
    return strconv.Atoi(string(c.text))
}

WS <- " " / "\t" {
    return string(c.text), nil
}

Newline <- "\r\n" / "\r" / "\n"

EOF <- !.

EOL <- Newline / EOF

EOLS <- WS* EOL