{
package parser 

import (
    "io"
    "fmt"
    "strconv"
    "strings"
    "unicode"
    "github.com/bytesparadise/libasciidoc/pkg/types"

    log "github.com/sirupsen/logrus"
    "github.com/davecgh/go-spew/spew"
)

}

// -------------------------------------------------------------------------------------
//
//
// Document Preprocessing (for file inclusions)
//
//
// -------------------------------------------------------------------------------------
DocumentRawLine <- 
    element:(
        AttributeDeclaration
        / AttributeReset
        / FileInclusion
        / ConditionalInclusion
        / BlockDelimiter
        / RawSection
    ) EOF {
        // in case of parse error, we'll keep the rawline content as-is
        return element, nil
    }

// ----------------------------------------------------------
// Raw Sections
// ----------------------------------------------------------
RawSection <- 
    &{
        // should only be enabled when reading files to include, not the main (root) file
        return c.isSectionEnabled(), nil
    }
    &{  
        return !c.isWithinDelimitedBlock(), nil
    }
    level:(("=")+ {   
        // `=` is level 0, `==` is level 1, etc.
        return (len(c.text)-1), nil 
    })
    &{  
        // use a predicate to make sure that only `=` (level 0) to `======` (level 5) are allowed
        return level.(int) <= 5, nil 
    } 
    Spaces ManyChars EOF {
        return types.NewRawSection(level.(int), string(c.text)) // just retain the raw content
    }

// ----------------------------------------------------------
// Conditional inclusions
// ----------------------------------------------------------
ConditionalInclusion <- 
    Ifdef
    / Ifndef
    / Ifeval
    / EndIf 

Ifdef <- "ifdef::" name:(ConditionalVariableName) "[" attr:(ConditionalInclusionAttribute)? "]" Space* EOF {
        return types.NewIfdefCondition(name.(string), attr)
    }

Ifndef <- "ifndef::" name:(ConditionalVariableName) "[" attr:(ConditionalInclusionAttribute)? "]" Space* EOF {
        return types.NewIfndefCondition(name.(string), attr)
    }

ConditionalInclusionAttribute <- [^\r\n\]]+ {
        return string(c.text), nil
    }

Ifeval <- "ifeval::" 
    "[" 
    left:(IfevalExpressionMember) Space* 
    operand:(IfevalExpressionOperand) Space* 
    right:(IfevalExpressionMember) "]" 
    Space* EOF {
        return types.NewIfevalCondition(left, right, operand.(types.IfevalOperand))
    }

IfevalExpressionMember <- 
    ("\"" s:(AttributeReferenceValue) "\"" { return s, nil })
    / ("'" s:(AttributeReferenceValue) "'" { return s, nil })
    / (s:(AttributeReferenceValue) { return s, nil })
    / ("\"" w:([\pL\pN,?!;_-]+ { return string(c.text), nil}) "\"" { return w, nil })
    / ("'" w:([\pL\pN,?!;_-]+ { return string(c.text), nil}) "'" { return w, nil })
    / Integer

IfevalExpressionOperand <-
    ("==" {
        return types.NewEqualOperand()
    })
    / ("!=" {
        return types.NewNotEqualOperand()
    })
    / ("<" {
        return types.NewLessThanOperand()
    })
    / ("<=" {
        return types.NewLessOrEqualOperand()
    })
    / (">" {
        return types.NewGreaterThanOperand()
    })
    / (">=" {
        return types.NewGreaterOrEqualOperand()
    })

IfevalExpressionValue <- 
    Number
    / InlineWord

EndIf <- "endif::" name:(ConditionalVariableName)? "[" attr:(ConditionalInclusionAttribute)? "]" Space* EOF {
         return types.NewEndOfCondition() // name and attributes are parsed but ignored
    }

ConditionalVariableName <- [^\r\n []+ { 
        return string(c.text), nil 
    }

// ----------------------------------------------------------
// File inclusions
// ----------------------------------------------------------
FileInclusion <- 
    incl:(
        "include::" 
        path:(FileLocation) 
        attributes:(InlineAttributes) { 
            return types.NewFileInclusion(path.(*types.Location), attributes.(types.Attributes), string(c.text))
        }
    ) 
    Space* EOL {
        return incl.(*types.FileInclusion), nil
    }

FileIncludeAttributes <- LongHandAttributes

// extra entrypoint
LineRanges <- value:(MultipleLineRanges 
    / MultilineRange 
    / SinglelineRange 
    ) EOF { // must make sure that the whole content is parsed
        return value, nil
    }

MultipleLineRanges <- first:(MultilineRange / SinglelineRange) 
    others:(
        ("," / ";") // at this point, we already got rid of the surrounding quotes, so we can accept both `,` and `;`
        other:(MultilineRange / SinglelineRange) {
            return other, nil
    })+ {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

MultilineRange <- start:(Integer) ".." end:(Integer) { // eg: lines=12..14
        return types.NewLineRange(start.(int), end.(int))
    } 

SinglelineRange <- singleline:(Integer) { // eg: lines=12
        return types.NewLineRange(singleline.(int), singleline.(int))
    }

// extra entrypoint
TagRanges <- value:(MultipleTagRanges) EOF { // must make sure that the whole content is parsed
        return value, nil
    }

MultipleTagRanges <- first:(TagRange)
    others:(
        ("," / ";") // at this point, we already got rid of the surrounding quotes, so we can accept both `,` and `;`
        other:(TagRange) {
            return other, nil
    })* {
        return append([]interface{}{first}, others.([]interface{})...), nil
    }

TagRange <- tag:(Alphanums / TagWildcard) {
        return types.NewTagRange(tag.(string), true)
    } / "!" tag:(Alphanums / TagWildcard) {
        return types.NewTagRange(tag.(string), false)
    }

TagWildcard <- stars:(("*")+ {
        return string(c.text), nil
    })
    &{  
        // use a predicate to make sure that only `*` and `**` are allowed
        return len(stars.(string)) <= 2, nil 
    } {
        return stars, nil
    }

IncludedFileLine <- content:(IncludedFileStartTag / IncludedFileEndTag / . {return string(c.text), nil})* EOL {
        return types.NewIncludedFileLine(content.([]interface{}))
    }

IncludedFileStartTag <- "tag::" tag:(Alphanums {return string(c.text), nil}) "[]" {
        return types.NewIncludedFileStartTag(tag.(string))
    }

IncludedFileEndTag <- "end::" tag:(Alphanums {return string(c.text), nil}) "[]" {
        return types.NewIncludedFileEndTag(tag.(string))
    }


// -------------------------------------------------------------------------------------
//
//
// Document Processing
//
//
// -------------------------------------------------------------------------------------

// -------------------------------------------------------------------------------------
// Document Fragments
// -------------------------------------------------------------------------------------
DocumentFragment <-
    !EOF
    attributes:(BlockAttributes)? 
    #{
        if attributes, ok := attributes.(types.Attributes); ok {
            c.storeBlockAttributes(attributes)
        }
        return nil
    }
    element:(
        ImageBlock // must appear before ShortcutParagraph
        / UserMacroBlock // must appear before ShortcutParagraph
        / ShortcutParagraph
        / AttributeDeclaration
        / AttributeReset
        / BlankLine
        / DocumentHeader 
        / Section 
        / DelimitedBlock
        / ThematicBreak // must appear before ListElement :/
        / ListElements
        / Table
        / SinglelineComment
        / FrontMatter
        / Paragraph // must be the last one... 
    )? // allow attribute on empty/no element
    &{
        // there must be at least `attributes` or `element`
        return attributes != nil || element != nil, nil
    }
    {
        c.disableFrontMatterRule() // not allowed as soon as a single element is found
        c.disableDocumentHeaderRule(element) // not allowed anymore, based on element that was found
    
        if element, ok := element.(types.WithAttributes); ok && attributes != nil {
            element.AddAttributes(attributes.(types.Attributes))
        }
        return element, nil
    }

RawLine <- 
    !EOF
    content:(AnyChars)
    EOL {
        return types.NewRawLine(content.(string))
    }


// reads all elements at once (for example, within a delimited block)
DelimitedBlockElements <- 
    #{
    	c.globalStore[withinDelimitedBlockKey]=true
        return nil
    }
    elements:(
        ElementPlaceHolder // if there was a fileinclusion 
        / DocumentFragment
    )* 
    EOF {
        return elements, nil
    }
    
// -------------------------------------------------------------------------------------
// Document Raw Line (main rule)
// Identify the delimiters for raw blocks
// -------------------------------------------------------------------------------------

FrontMatterFragmentElement <-
    FrontMatterDelimiter
    / BlankLine
    // if no match, parser will return an error and content will be store in a RawLine

// -------------------------------------------------------------------------------------
// Attribute Declarations and Resets
// -------------------------------------------------------------------------------------
AttributeDeclaration <- 
    ":" name:(AttributeName) ":" 
    value:(
        Spaces // value is optional, but there must be a space between `:` and value itself
        value:(AttributeDeclarationValue) {
            return value, nil
        }
    )? 
    EOL
    {
        return types.NewAttributeDeclaration(name.(string), value, string(c.text))
    }

// AttributeName must be at least one character long, 
// must begin with a word character (A-Z, a-z, 0-9) or an underscore ("_") 
// and must only contain word characters (A-Z, a-z, 0-9) and hyphens ("-").
AttributeName <- [\pL\pN_] ([\pL\pN-])* {
        return string(c.text), nil
    }

AttributeDeclarationValue <- 
    elements:(AttributeDeclarationValueElements) 
    otherElements:(
        "\\" Newline 
        Space*
        elements:(AttributeDeclarationValueElements) { 
           return elements, nil
        }
    )*
    {
        if otherElements, ok := otherElements.([]interface{}); ok {
            elements = append(elements.([]interface{}), otherElements...)
        }
        return types.Reduce(elements.([]interface{}), strings.TrimSpace), nil
    }

AttributeDeclarationValueElements <- 
    elements:(AttributeDeclarationValueElement)* {
        return elements.([]interface{}), nil
    }

AttributeDeclarationValueElement <- 
    !("\\"? Space* EOL)
    element:(
        InlinePassthrough
        / ([^\r\n<>&{ ]+ {
                return types.NewStringElement(string(c.text))
        })
        / SpecialCharacter
        / Space
        / AttributeReference
    ) { 
        if log.IsLevelEnabled(log.DebugLevel) {
            log.Debugf("new AttributeDeclarationValueElement: %s", spew.Sdump(element))
        }
        return element, nil
    }

AttributeReset <- ":!" name:(AttributeName) ":" Space* EOL {
        return types.NewAttributeReset(name.(string), string(c.text))
    } / ":" name:(AttributeName) "!:" Space* EOL {
        return types.NewAttributeReset(name.(string), string(c.text))
    }

// -------------------------------------------------------------------------------------
// Block and Inline Attributes
// -------------------------------------------------------------------------------------
BlockAttributes <-
    attributes:(
        // shorthand syntax for anchors. Eg: `[[an_id]]`
        (anchor:(LegacyElementID) Space* EOL BlankLine* {
            return anchor, nil
        })
        // shorthand syntax for titles. Eg: `.a title`
        / (title:(ShortHandTitle) Space* EOL BlankLine*{
            return title, nil
        })
        // default syntax
        / (attributes:(LongHandAttributes) Space* EOL BlankLine*{
            return attributes, nil
        })
    )+ {
        // c.unsetCurrentSubstitution()
        return types.MergeAttributes(attributes.([]interface{})...)
    }  

InlineAttributes <-
    "["
    attributes:(
        (
            !"]" // quick escape
            attribute:(PositionalAttribute / NamedAttribute)
        ) {
            return attribute, nil
        }
    )*
    "]" {
        return types.NewAttributes(attributes.([]interface{})...)
    }

// shorthand syntax for anchors. Eg: `[[An ID]]`
LegacyElementID <-
    "[[" 
    id:(
        elements:(
            ([^=\r\n\uFFFD{\]]+ { // spaces, commas and dots are allowed in this syntax
                return types.NewStringElement(string(c.text))
            })
            / ElementPlaceHolder
            / AttributeReference
            / ("{" { 
                return types.NewStringElement(string(c.text))
            }))+ {
                return types.Reduce(elements, strings.TrimSpace), nil
            }
        )
    "]]" {
        return types.NewIDAttribute(id)
    }

// shorthand syntax for titles. Eg: `.a title`
ShortHandTitle <- `.` 
    ![. ] // may not start with a dot or a space, to avoid confusion with list items or literal block delimiters
    elements:(
        InlineWord
        / Space
        / AttributeReferenceValue
        / AnyChar
    )+ {
        return types.NewTitleAttribute(types.Reduce(elements, strings.TrimSpace))
    }

// LongHandAttributes. Eg: `[positional1,positional2,...,named1,named2,...]
// positional attributes are optional, and `positional1` can be combined with options and roles ("extras")
LongHandAttributes <-
    !`\` "[" !"[" // prevent processing nested attributes at this point (parser will need to move forward by 1 char first)
    firstPositionalAttributes:(FirstPositionalAttributes)?
    otherAttributes:(PositionalAttribute / NamedAttribute)*
    "]" {
        attributes:=[]interface{}{}
        if firstPositionalAttributes != nil {
            attributes=append(attributes, firstPositionalAttributes.([]interface{})...)
        }
        if len(otherAttributes.([]interface{})) > 0 {
            attributes=append(attributes, otherAttributes.([]interface{})...)
        }
        return types.NewAttributes(attributes...)
    }

// First positional attributes may be an ID or a style, with extra roles and options.
// Or sometimes, it's just 1 or more roles or options...
FirstPositionalAttributes <- 
    main:(
        ShortHandAttribute
    )?
    extras:( 
        !"," !"]"
        extra:(
            ShortHandIDAttribute 
            / ShortHandOptionAttribute
            / ShortHandDotRoleAttribute) {
            return extra, nil
        }
    )* ("," Space*)? 
    &{
        // make sure there was a match
        return main != nil || len(extras.([]interface{})) > 0, nil
    }
    {
        attrs:=[]interface{}{}
        if main != nil {
            attrs = append(attrs, main)
        }
        if len(extras.([]interface{})) > 0 {
            attrs = append(attrs, extras.([]interface{})...)
        }
        return attrs, nil
    }

// an `id` must be prefixed with a `#` 
ShortHandIDAttribute <- "#" id:(ShortHandAttributeValue) {
        return types.NewIDAttribute(id)
    }

ShortHandAttribute <- value:(ShortHandAttributeValue) {
        return types.NewPositionalAttribute(value)
    }

// a `role` must be prefixed with a `.` 
ShortHandDotRoleAttribute <- "." role:(ShortHandAttributeValue) {
        return types.NewRoleAttribute(role)
    }

// an `option` must be prefixed with a `%` 
ShortHandOptionAttribute <- "%" option:(ShortHandAttributeValue) {
        return types.NewOptionAttribute(option)
    }

// Shorthand Attribute Value. 
ShortHandAttributeValue <- 
    SingleQuotedAttributeValue 
    / DoubleQuotedAttributeValue 
    / elements:(
        // unquoted shorthand value may include placeholders and substitutions but NOT comma, space, equal sign and dots
        // also, cannot be followed by an `=` sign
        QuotationMark 
        / ([^,=.%# \r\n\uFFFD{\]]+ {
            return types.NewStringElement(string(c.text))
        }) 
        // / ElementPlaceHolder
        / AttributeReference
        / ("{" { 
            return types.NewStringElement(string(c.text))
        })
    )+ 
    &(!(Space* "=")) {
        return types.Reduce(elements, strings.TrimSpace), nil
    }


PositionalAttribute <- (
    value:(AttributeValue) (("," Space*)? / &"]") {
    	return types.NewPositionalAttribute(value)
    }) 
    / 
    // empty/edge-case values. Eg: `[ ]`, `[, a, b]`, `[a, ,b]`, etc.
    (value:(Space* (("," Space*) / &"]"))
    &{
        // here we can't rely on `c.text` if the content is empty 
        // (in such a case, `c.text` contains the char sequence of the previous 
        // rule that matched)
        return !types.AllNilEntries(value.([]interface{})), nil
    }
    { 
        return types.NewPositionalAttribute(nil)
    })

NamedAttribute <- 
    key:(NamedAttributeKey) 
    "=" Space* 
    value:(AttributeValue) ("," Space*)? 
    {
        return types.NewNamedAttribute(key.(string), value)
    }

// The spec says attributes have be alphanumeric but does not consider foreign letters.  We are more generous.
NamedAttributeKey <- !Space [^\r\n=,\]]+ {
        return string(c.text), nil
    }

AttributeValue <- 
    value:(
        SingleQuotedAttributeValue 
        / DoubleQuotedAttributeValue 
        / UnquotedAttributeValue
    ) 
    &(!(Space* "=")) {
        return value, nil
    }

SingleQuotedAttributeValue <- 
    "'" !"`" // prevent entering when the value is a quoted string (eg: '`cookie`')
    content:(SingleQuotedAttributeValueContent)
    "'" {
        return content, nil
    }

SingleQuotedAttributeValueContent <- 
    elements:(
        Alphanums
        / Space
        / QuotationMark
        / AttributeReference
        / (`\'` { 
            return types.NewStringElement(`'`) // escaped single quote
        })
        / ( "'`" / "`'" / `\` { // quoted string delimiters or standalone backslash
            return types.NewStringElement(string(c.text)) // keep as-is for now
        })
        / ([^\r\n\\'' ]+ { // = and , signs are allowed within '' quoted values
            return types.NewStringElement(string(c.text))
        })
    )+ {
        return types.Reduce(elements), nil
    }

DoubleQuotedAttributeValue <- 
    "\"" !"`" // prevent entering when the value is a quoted string (eg: "`cookie`")
    content:(DoubleQuotedAttributeValueContent)
    "\"" &(!(Space* "=")) {
        return content, nil
    }

DoubleQuotedAttributeValueContent <- 
    elements:(
        Alphanums
        / Space
        / QuotationMark
        / AttributeReference 
        / (`\"` { 
            return types.NewStringElement(`"`) // escaped double quote
        })
        / ( "\"`" / "`\"" / `\` / "`" { // quoted string delimiters or standalone backslash or standalone backtick
            return types.NewStringElement(string(c.text)) // keep as-is for now
        })
        / ([^\r\n\\"` ]+ { // = and , signs are allowed within " quoted values
            return types.NewStringElement(string(c.text))
        })
    )+ {
        return types.Reduce(elements), nil
    }

// Unquoted Attribute Value, may include spaces but not on the first position
UnquotedAttributeValue <-
    // need to support value like `[.myrole1]_a_` in `a link to https://example.com[[.myrole1]_a_]`
    // so we need to count the `[` and `]` to balance
    !Space // can't start with a space (eg: can't have `[ cookie ]`)
    elements:(
        ("[" UnquotedAttributeValue "]") // recursively within brackets (see comment above)
        / AttributeReference / "{" // standalone, if `AttributeReference` is not enabled
        / Space
        / ([^=,\]{ ]+ { // not within brackets and stop on space and quotation marks (`"')
            return string(c.text), nil
        })
    )+ {
        return types.Reduce(elements, strings.TrimSpace), nil
    }

// -------------------------------------------------------------------------------------
// Attribute Substitution
// -------------------------------------------------------------------------------------
AttributeReference <-
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(AttributeRefs), nil
    }
    element:(CounterReference / AttributeReferenceValue) {
        return element, nil
    }

AttributeReferenceValue <-  
    // escaped
    `\` "{" name:AttributeName "}" { 
        log.Debug("matching escaped attribute reference")
        // return types.NewStringElement("{"+name.(string)+"}")
        return types.NewStringElement(strings.TrimPrefix(string(c.text), `\`))
    }
    /
    // unescaped
    "{" name:AttributeName "}" { 
        return types.NewAttributeReference(name.(string), string(c.text))
    }
    
CounterReference <- CounterSubstitution1 / CounterSubstitution2

CounterSubstitution1 <- "{counter:" name:AttributeName start:(CounterStart)? "}" {
    return types.NewCounterSubstitution(name.(string), false, start, string(c.text))
}

CounterSubstitution2 <- "{counter2:" name:AttributeName start:(CounterStart)? "}" {
    return types.NewCounterSubstitution(name.(string), true, nil, string(c.text))
}

CounterStart <- ":" start:([A-Za-z] {
        return string(c.text), nil
    } / [0-9]+ { 
        return strconv.Atoi(string(c.text)) 
    }) {
        return start, nil
    }

// -------------------------------------------------------------------------------------
// BlankLine
// -------------------------------------------------------------------------------------
BlankLine <- !EOF Space* EOL {
        return types.NewBlankLine()
    }

// -------------------------------------------------------------------------------------
// Cross References
// -------------------------------------------------------------------------------------
CrossReference <- InternalCrossReference / ExternalCrossReference 

InternalCrossReference <- "<<" id:(Id) Space* "," label:(CrossReferenceLabel) ">>" {
        return types.NewInternalCrossReference(id, label)
    } / "<<" id:(Id) ">>" {
        return types.NewInternalCrossReference(id, nil)
    } 

ExternalCrossReference <- "xref:" url:(FileLocation) attributes:(InlineAttributes) {
        return types.NewExternalCrossReference(url.(*types.Location), attributes.(types.Attributes))
    }

CrossReferenceLabel <- (
    ([\pL\pN][^\r\n{<>]+ { // `{`, `>` and `>` characters are not allowed as they are used for attribute substitutions and cross-references 
        return types.NewStringElement(string(c.text))
    })
    / AttributeReferenceValue
    / ("{" { 
        return types.NewStringElement(string(c.text))
    })
    )+


// -------------------------------------------------------------------------------------
// Delimited Blocks
// -------------------------------------------------------------------------------------
DelimitedBlock <-
    CommentBlock
    / ExampleBlock
    / MarkdownCodeBlock
    / FencedBlock
    / ListingBlock
    / LiteralBlock
    / MarkdownQuoteBlock
    / OpenBlock
    / PassthroughBlock
    / QuoteBlock
    / SidebarBlock

BlockDelimiter <-
    !Alphanum // quick escape
    delimiter:(
        CommentBlockDelimiter
        / ExampleBlockDelimiter
        / MarkdownCodeDelimiter // TODO: could be merged with FencedBlockDelimiter since the `language` attribute is not relevant where `BlockDelimiter` rule is used
        / FencedBlockDelimiter
        / ListingBlockDelimiter
        / LiteralBlockDelimiter
        / PassthroughBlockDelimiter
        / QuoteBlockDelimiter
        / SidebarBlockDelimiter) {
            return delimiter, nil
        }


CommentBlockDelimiter <- 
    delimiter:("////" "/"* { // sequence of 4 "/" chars or more
        return string(c.text), nil
    }) Space* EOL { 
        return types.NewBlockDelimiter(types.Comment, len(delimiter.(string)), string(c.text))
    }

ExampleBlockDelimiter <- 
    delimiter:("====" "="* { // sequence of 4 "=" chars or more
        return string(c.text), nil
    }) Space* EOL { 
        return types.NewBlockDelimiter(types.Example, len(delimiter.(string)), string(c.text))
    }

FencedBlockDelimiter <- 
    delimiter:("```" "`"* { // sequence of 3 "`" chars or more
        return string(c.text), nil
    }) Space* EOL { 
        return types.NewBlockDelimiter(types.Fenced, len(delimiter.(string)), string(c.text))
    }

MarkdownCodeDelimiter <- "```" language:(Language) Space* EOL {
    return types.NewMarkdownCodeBlockDelimiter(language.(string), string(c.text))
}

Language <- ([^\r\n` ]+) { // exclude ` to avoid matching fenced blocks with more than 3 "`" delimter chars
    return string(c.text), nil
}

ListingBlockDelimiter <- 
    delimiter:("----" "-"* { // sequence of 4 "-" chars or more
        return string(c.text), nil
    }) Space* EOL { 
        return types.NewBlockDelimiter(types.Listing, len(delimiter.(string)), string(c.text))
    }

OpenBlockDelimiter <- 
    delimiter:("--" { // sequence of exactly "--"
        return string(c.text), nil
    }) Space* EOL { 
        return types.NewBlockDelimiter(types.Open, len(delimiter.(string)), string(c.text))
    }

LiteralBlockDelimiter <- 
    delimiter:("...." "."* { // sequence of 4 "." chars or more
        return string(c.text), nil
    }) Space* EOL { 
        return types.NewBlockDelimiter(types.Listing, len(delimiter.(string)), string(c.text))
    }

PassthroughBlockDelimiter <- 
    delimiter:("++++" "+"* { // sequence of 4 "+" chars or more
        return string(c.text), nil
    }) Space* EOL { 
        return types.NewBlockDelimiter(types.Passthrough, len(delimiter.(string)), string(c.text))
    }

QuoteBlockDelimiter <- 
    delimiter:("____" "_"* { // sequence of 4 "_" chars or more
        return string(c.text), nil
    }) Space* EOL { 
        return types.NewBlockDelimiter(types.Quote, len(delimiter.(string)), string(c.text))
    }

SidebarBlockDelimiter <- 
    delimiter:("****" "*"* { // sequence of 4 "*" chars or more
        return string(c.text), nil
    }) Space* EOL { 
        return types.NewBlockDelimiter(types.Sidebar, len(delimiter.(string)), string(c.text))
    }

DelimitedBlockRawLine <- 
    !EOF // in case the block is unclosed and at the end of the document
    content:(AnyChars) EOL { 
        return types.NewRawLine(content.(string))
    }

// ----------------
// Comment Blocks
// ----------------
CommentBlock <-
    CommentBlockStartDelimiter
    content:(CommentBlockContent)
    CommentBlockEndDelimiter? {
        return types.NewDelimitedBlock(types.Comment, content.([]interface{}))
    }

CommentBlockStartDelimiter <- CommentBlockDelimiter

CommentBlockEndDelimiter <- CommentBlockDelimiter / EOF

CommentBlockContent <- 
    (!CommentBlockEndDelimiter
    line:DelimitedBlockRawLine {
        return line, nil
    })*

// ----------------------
// Example Blocks
// ----------------------
ExampleBlock <-
    start:(ExampleBlockStartDelimiter)
    &{
        return c.setBlockDelimiterLength(start.(*types.BlockDelimiter).Length)
    }
    content:(ExampleBlockContent)
    end:(ExampleBlockEndDelimiter)? {
        return types.NewDelimitedBlock(types.Example, content.([]interface{}))
    }

ExampleBlockStartDelimiter <- ExampleBlockDelimiter

ExampleBlockEndDelimiter <- 
    end:ExampleBlockDelimiter 
    &{
        return c.matchBlockDelimiterLength(end.(*types.BlockDelimiter).Length)
    }
    / EOF

ExampleBlockContent <- 
   (!ExampleBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Fenced Blocks
// ----------------------
FencedBlock <-
    start:(FencedBlockStartDelimiter)
    &{
        return c.setBlockDelimiterLength(start.(*types.BlockDelimiter).Length)
    }
    content:(FencedBlockContent)
    end:(FencedBlockEndDelimiter)? {
        return types.NewDelimitedBlock(types.Fenced, content.([]interface{}))
    }

FencedBlockStartDelimiter <- FencedBlockDelimiter

FencedBlockEndDelimiter <- 
    end:FencedBlockDelimiter 
    &{
        return c.matchBlockDelimiterLength(end.(*types.BlockDelimiter).Length)
    }
    / EOF

FencedBlockContent <- 
    (!FencedBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Listing Blocks
// ----------------------
ListingBlock <-
    start:(ListingBlockStartDelimiter)
    &{
        return c.setBlockDelimiterLength(start.(*types.BlockDelimiter).Length)
    }
    content:(ListingBlockContent)
    end:(ListingBlockEndDelimiter)? {
        return types.NewDelimitedBlock(types.Listing, content.([]interface{}))
    }

ListingBlockStartDelimiter <- ListingBlockDelimiter

ListingBlockEndDelimiter <- 
    end:ListingBlockDelimiter 
    &{
        return c.matchBlockDelimiterLength(end.(*types.BlockDelimiter).Length)
    }
    / EOF

ListingBlockContent <- 
    (!ListingBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Literal Blocks
// ----------------------
LiteralBlock <-
    start:(LiteralBlockStartDelimiter)
    &{
        return c.setBlockDelimiterLength(start.(*types.BlockDelimiter).Length)
    }
    content:(LiteralBlockContent)
    end:(LiteralBlockEndDelimiter)? {
        return types.NewDelimitedBlock(types.Literal, content.([]interface{}))
    }

LiteralBlockStartDelimiter <- LiteralBlockDelimiter

LiteralBlockEndDelimiter <- 
    end:LiteralBlockDelimiter 
    &{
        return c.matchBlockDelimiterLength(end.(*types.BlockDelimiter).Length)
    }
    / EOF

LiteralBlockContent <- 
    (!LiteralBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// -------------------
// Markdown Code Block
// -------------------
MarkdownCodeBlock <-
    delimiter:MarkdownCodeBlockStartDelimiter
    content:(MarkdownCodeBlockContent)
    MarkdownCodeBlockEndDelimiter? {
        // Markdown code with fences is a "listing/source" block in Asciidoc
        b, err := types.NewDelimitedBlock(types.Listing, content.([]interface{}))
        b.AddAttributes(delimiter.(*types.BlockDelimiter).Attributes)
        return b, err
    }

MarkdownCodeBlockStartDelimiter <- MarkdownCodeDelimiter

MarkdownCodeBlockEndDelimiter <- "```" Space* EOL 

MarkdownCodeBlockContent <- 
    (!MarkdownCodeBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Markdown Quote Blocks
// ----------------------
MarkdownQuoteBlock <- 
    firstLine:(MarkdownQuoteRawLine)
    otherLines:(MarkdownQuoteRawLine / ParagraphRawLine)* 
    {
        return types.NewDelimitedBlock(types.MarkdownQuote, append([]interface{}{firstLine}, otherLines.([]interface{})...))
    }

MarkdownQuoteRawLine <- 
    !BlankLine
    "> " 
    content:(ManyChars) EOL {
        return types.NewRawLine(content.(string))
    }

MarkdownQuoteAttribution <- 
    "-- " author:(ManyChars) EOL {
        return author, nil
    }

// ----------------------
// Open Blocks
// ----------------------
OpenBlock <-
    start:(OpenBlockStartDelimiter)
    content:(OpenBlockContent)
    end:(OpenBlockEndDelimiter)? {
        return types.NewDelimitedBlock(types.Open, content.([]interface{}))
    }

OpenBlockStartDelimiter <- OpenBlockDelimiter

OpenBlockEndDelimiter <- OpenBlockDelimiter / EOF

OpenBlockContent <- 
    (!OpenBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Passthrough Blocks
// ----------------------
PassthroughBlock <-
    start:(PassthroughBlockStartDelimiter)
    &{
        return c.setBlockDelimiterLength(start.(*types.BlockDelimiter).Length)
    }
    content:(PassthroughBlockContent)
    end:(PassthroughBlockEndDelimiter)? {
        return types.NewDelimitedBlock(types.Passthrough, content.([]interface{}))
    }

PassthroughBlockStartDelimiter <- PassthroughBlockDelimiter

PassthroughBlockEndDelimiter <- 
    end:PassthroughBlockDelimiter 
    &{
        return c.matchBlockDelimiterLength(end.(*types.BlockDelimiter).Length)
    }
    / EOF

PassthroughBlockContent <- 
    (!PassthroughBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Quote Blocks
// ----------------------
QuoteBlock <-
    start:(QuoteBlockStartDelimiter)
    &{
        return c.setBlockDelimiterLength(start.(*types.BlockDelimiter).Length)
    }
    content:(QuoteBlockContent)
    end:(QuoteBlockEndDelimiter)? {
        return types.NewDelimitedBlock(types.Quote, content.([]interface{}))
    }

QuoteBlockStartDelimiter <- QuoteBlockDelimiter

QuoteBlockEndDelimiter <- 
    end:QuoteBlockDelimiter 
    &{
        return c.matchBlockDelimiterLength(end.(*types.BlockDelimiter).Length)
    }
    / EOF

QuoteBlockContent <- 
   (!QuoteBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// ----------------------
// Sidebar Blocks
// ----------------------
SidebarBlock <-
    start:(SidebarBlockStartDelimiter)
    &{
        return c.setBlockDelimiterLength(start.(*types.BlockDelimiter).Length)
    }
    content:(SidebarBlockContent)
    end:(SidebarBlockEndDelimiter)? {
        return types.NewDelimitedBlock(types.Sidebar, content.([]interface{}))
    }

SidebarBlockStartDelimiter <- SidebarBlockDelimiter

SidebarBlockEndDelimiter <- 
    end:SidebarBlockDelimiter 
    &{
        return c.matchBlockDelimiterLength(end.(*types.BlockDelimiter).Length)
    }
    / EOF

SidebarBlockContent <- 
   (!SidebarBlockEndDelimiter
    line:(DelimitedBlockRawLine) {
        return line, nil
    })*

// -------------------------------------------------------------------------------------
// Document Header and Metadata
// -------------------------------------------------------------------------------------
DocumentHeader <- 
    &{
        return c.isDocumentHeaderAllowed(), nil
    }
    (SinglelineComment / CommentBlock)* // ignored in the returned `DocumentInformation` element
    title:(DocumentTitle)
    (SinglelineComment / CommentBlock)* // ignored in the returned `DocumentInformation` element
    authorsAndRevision:(DocumentAuthorsAndRevision)? 
    extraElements:(AttributeDeclaration / AttributeReset / SinglelineComment / CommentBlock)* {
        return types.NewDocumentHeader(title.([]interface{}), authorsAndRevision, extraElements.([]interface{}))
    }

DocumentTitle <- 
    "=" Spaces title:(SectionTitle) EOL {
        return title, nil
    }

DocumentAuthorsAndRevision <- 
    !":"
    authors:(DocumentAuthors)
    (SinglelineComment / CommentBlock)* // ignored in the returned element
    revision:(DocumentRevision)? {
        return types.NewDocumentAuthorsAndRevision(authors.(types.DocumentAuthors), revision)
    }

DocumentAuthors <- Space* authors:(DocumentAuthor+) EOL {
    return types.NewDocumentAuthors(authors.([]interface{})...)
}

DocumentAuthor <- 
    fullName:(DocumentAuthorFullName)? email:(DocumentAuthorEmail)? Space* ";"? Space* 
    &{
        // at least 1 of [fullName, email] must be defined
        return fullName != nil || email != nil, nil
    }
    {
        return types.NewDocumentAuthor(fullName, email)
    }

// "<" marks the beginning of the author email, and ";" is the authors separator
DocumentAuthorFullName <- 
    part1:([^<;\r\n ]+ { // no space allowed
        return string(c.text), nil
    })
    Space*
    part2:([^<;\r\n ]+ { // no space allowed
        return string(c.text), nil
    })?
    Space*
    part3:([^<;\r\n]+ { // spaces allowed
        return string(c.text), nil
    })? 
    Space* {
        return types.NewDocumentAuthorFullName(part1.(string), part2, part3)
    }


DocumentAuthorEmail <- 
    !EOF 
    "<" 
    email:(([^>\r\n]+) {
        return string(c.text), nil
    }) 
    ">" {
        return email, nil
    }

// see http://asciidoctor.org/docs/user-manual/#revision-number-date-and-remark
// Eg: "v1.0, October 2, 2013: First incarnation"
DocumentRevision <- Space* !":" revision:(
        (revnumber:(DocumentRevisionNumber) ","? revdate:(DocumentRevisionDate)? ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(revnumber, revdate, revremark)
        }) / (revdate:(DocumentRevisionDate) ":"? revremark:(DocumentRevisionRemark)? {
            return types.NewDocumentRevision(nil, revdate, revremark)
        })) EOL {
    return revision, nil
}

// DocumentRevisionNumber MUST start with a `v` or MAY start with a `v` but MUST end with a `,`
DocumentRevisionNumber <- "v"i [0-9] [^:,\r\n]+ {
    return string(c.text), nil
} / "v"i? [0-9] [^:,\r\n]+ Space* &"," {
    return string(c.text), nil
}

DocumentRevisionDate <- [^:\r\n]+ {
    return string(c.text), nil
}

DocumentRevisionRemark <- [^\r\r\n]+ {
    return string(c.text), nil
}

// -------------------------------------------------------------------------------------
// ElementPlaceHolder
// -------------------------------------------------------------------------------------
ElementPlaceHolderDelimiter <- "\uFFFD"

ElementPlaceHolder <- ElementPlaceHolderDelimiter ref:([0-9]+ { return string(c.text), nil }) ElementPlaceHolderDelimiter {
    return types.NewElementPlaceHolder(ref.(string))
}

// -----------------------------------------------------------------------------------------------------------------------
// Explicit line breaks
// -----------------------------------------------------------------------------------------------------------------------
LineBreak <- 
    &{ 
        return c.isSubstitutionEnabled(PostReplacements), nil
    }
    "+"
    &{ 
        log.Debug("LineBreak")
        return c.isPrecededBySpace(), nil
    }
    Space* &(EOL) {
        return types.NewLineBreak()    
    }

// -------------------------------------------------------------------------------------
// Front Matter
// -------------------------------------------------------------------------------------
FrontMatter <- 
    &{
        return c.isFrontMatterAllowed(), nil
    }
    frontmatter:(YamlFrontMatter) 
    {
        return frontmatter, nil
    }

YamlFrontMatter <- YamlFrontMatterDelimiter content:(YamlFrontMatterContent)? YamlFrontMatterDelimiter {
    return types.NewYamlFrontMatter(content.(string))
}

YamlFrontMatterDelimiter  <- "---" Space* EOL

YamlFrontMatterContent <- ((!YamlFrontMatterDelimiter .)+)* {
        return string(c.text), nil
}

FrontMatterFragment <- FrontMatterDelimiter / BlankLine / FrontMatterLine

FrontMatterDelimiter  <- "---" Space* EOF

FrontMatterLine <- (.)* {
    return types.NewRawLine(string(c.text))
}

// -------------------------------------------------------------------------------------
// Inline Elements
// -------------------------------------------------------------------------------------

// TODO: group as below and enable based on substitution context.
// Also, add Callouts

// "specialcharacters",
// "quotes",
// "attributes",
// "replacements",
// "macros",
// "post_replacements",
InlineElement <-  
    element:(
        Spaces 
        / InlineWord 
        / InlineMacro
        / LineBreak
        / Symbol // TODO: use `Replacement`?
        / Quote
        / AttributeReference 
        / SpecialCharacter // must be after InlineMacro (because of BareURL)
        // if anything above did not match...
        / AnyChar) {
    c.trackElement(element)
    return element, nil
}

// -------------------------------------------------------------------------------------
// Inline Anchor 
// -------------------------------------------------------------------------------------
InlineAnchor <- 
    // escaped
    `\` "[[" id:(Id) "]]" {
        //return types.NewStringElement("[[" + id.(string) + "]]")
        return types.NewStringElement(strings.TrimPrefix(string(c.text), `\`))
    }
    // unescaped
    /
    "[[" id:(Id) "]]" { // no EOL here since there can be multiple InlineElementID on the same line
        return types.NewInlineAnchor(id.(string))
    }

// -------------------------------------------------------------------------------------
// Inline Button
// -------------------------------------------------------------------------------------
InlineButton <- 
    &{
        return c.isExperimentalEnabled(), nil
    }
    "btn:" attributes:(InlineAttributes) {
        return types.NewInlineButton(attributes.(types.Attributes))
    }

// -------------------------------------------------------------------------------------
// Inline Menu
// -------------------------------------------------------------------------------------
InlineMenu <- 
    &{
        return c.isExperimentalEnabled(), nil
    }
    "menu:" id:(Id) attributes:(InlineAttributes) {
        return types.NewInlineMenu(id.(string), attributes.(types.Attributes))
    }

// -------------------------------------------------------------------------------------
// Index Terms
// -------------------------------------------------------------------------------------
IndexTerm <- "((" term:(IndexTermContent) "))" {
       return types.NewIndexTerm(term.([]interface{}))
    }

IndexTermContent <- elements:(InlineWord / QuotedText / Space / SpecialCharacter / ElementPlaceHolder / (!"))" .) {
    return string(c.text), nil
})+ {
    return types.NewInlineElements(elements.([]interface{}))
}

ConcealedIndexTerm <- "(((" term1:(ConcealedIndexTermContent) 
    term2:(Space* "," Space* content:(ConcealedIndexTermContent) { return content, nil })? 
    term3:(Space* "," Space* content:(ConcealedIndexTermContent) { return content, nil })? 
    ")))" {
        return types.NewConcealedIndexTerm(term1, term2, term3)
    }

ConcealedIndexTermContent <- (Alphanum / Space)+ {
    return string(c.text), nil
}

// -------------------------------------------------------------------------------------
// Images
// -------------------------------------------------------------------------------------
ImageBlock <- 
    "image::" path:(Location) attributes:(InlineAttributes) Space* EOL {
        // 'imagesdir' attribute is added after applying the attribute substitutions on the image location
        return types.NewImageBlock(path.(*types.Location), attributes.(types.Attributes))
    }

InlineImage <- "image:" !":" path:(Location) attributes:(InlineAttributes) {
        return types.NewInlineImage(path.(*types.Location), attributes.(types.Attributes))
    }

// -------------------------------------------------------------------------------------------------------------------------------
// Inline Icons
// -------------------------------------------------------------------------------------------------------------------------------
InlineIcon <- "icon:" icon:([\pL\pN_-]+ { return string(c.text), nil }) attributes:(InlineAttributes) {
        return types.NewIcon(icon.(string), attributes)
    }

// -------------------------------------------------------------------------------------------------------------------------------
// Inline Foot Notes
// -------------------------------------------------------------------------------------------------------------------------------
InlineFootnote <- "footnote:" ref:(FootnoteRef)? "[" elements:(FootnoteElements) "]" { // TODO: use only this rule with `ref:(FootnoteRef)?`
        return types.NewFootnote(ref, elements.([]interface{}))
    }

FootnoteRef <- Alphanums

FootnoteElements <- elements:(FootnoteElement)* {
        return types.NewInlineElements(elements.([]interface{}))
    }

FootnoteElement <- 
    !"]" 
    element:(
        InlineElement
        / Newline) {
        return element, nil
    }

// -------------------------------------------------------------------------------------
// Passthrough
// -------------------------------------------------------------------------------------

SinglePlusPassthroughPrefix <- "+"

SinglePlusPassthrough <- SinglePlusPassthroughPrefix content:(SinglePlusPassthroughContent) SinglePlusPassthroughPrefix !Alphanum {
        return types.NewInlinePassthrough(types.SinglePlusPassthrough, []interface{}{content})
    }

SinglePlusPassthroughContent <- ((!SinglePlusPassthroughPrefix !Space !Newline .) (!(Spaces SinglePlusPassthroughPrefix) !SinglePlusPassthroughPrefix !Newline .)* { // no space in the first or last position of the content, but allowed elsewhere
        return types.NewStringElement(string(c.text))
    }) / ((!Space !Newline !SinglePlusPassthroughPrefix .)  { // a single character
        return types.NewStringElement(string(c.text))
    })

TriplePlusPassthroughPrefix <- "+++"

TriplePlusPassthrough <- TriplePlusPassthroughPrefix content:(TriplePlusPassthroughContent) TriplePlusPassthroughPrefix !Alphanum {
        return types.NewInlinePassthrough(types.TriplePlusPassthrough, []interface{}{content})
    }

TriplePlusPassthroughContent <- ((!TriplePlusPassthroughPrefix .)* { // spaces and newlines are also allowed in the first or last position of the content and elsewhere too
        return types.NewStringElement(string(c.text))
    }) / ((!Space !Newline !TriplePlusPassthroughPrefix .)?  { // a single character
        return types.NewStringElement(string(c.text))
    })

PassthroughMacro <- "pass:[" content:(PassthroughMacroCharacter)* "]" {
        return types.NewInlinePassthrough(types.PassthroughMacro, []interface{}{content})
    } / "pass:q[" content:(QuotedText / PassthroughMacroCharacter)* "]" {
        return types.NewInlinePassthrough(types.PassthroughMacro, content.([]interface{}))
    }

PassthroughMacroCharacter <- [^\]] {
        return types.NewStringElement(string(c.text))
    }

// -------------------------------------------------------------------------------------
// Links
// -------------------------------------------------------------------------------------
Link <- BareURL / RelativeLink / ExternalLink / EmailAddress

BareURL <-
    "<" 
    url:(LocationWithScheme) // scheme is required for this syntax
    &{
        // expect `>` to be part of `url` and trimmed afterwards
        return url.(*types.Location).TrimAngleBracketSuffix()
    }
    { 
        return types.NewInlineLink(url.(*types.Location), nil)
    }

// url preceeding with `link:` MUST be followed by square brackets
RelativeLink <- 
    // escaped
    `\` "link:" url:(Location) attributes:(InlineAttributes) {
        return types.NewStringElement(strings.TrimPrefix(string(c.text), `\`))
    }
    /
    // unescaped
    "link:" url:(Location) attributes:(InlineAttributes) {
        return types.NewInlineLink(url.(*types.Location), attributes.(types.Attributes))
    }

ExternalLink <- 
    // escaped
    // TODO: do not attempt to parse url and attributes here, and support escaped element once for all at a higher level     
    `\` url:(LocationWithScheme) attributes:(InlineAttributes)? {
        return types.NewStringElement(strings.TrimPrefix(string(c.text), `\`))
    }
    /
    // unescaped
    url:(LocationWithScheme) attributes:(InlineAttributes)? {
        return types.NewInlineLink(url.(*types.Location), attributes)
    }

EmailAddress <- local:(EmailAddressLocal) "@" domain:(EmailAddressDomain) {
    return types.NewEmailAddressLink(local.(string) +"@" + domain.(string))
}

EmailAddressLocal <- [a-zA-Z0-9!#$%&'*+-/=?^_`{|}~.]+ // `'
    &{
        // must not start or end with dot (`.`), not contain two consecutive dots (`..`)
        local := string(c.text)
        return !strings.HasPrefix(local, ".") &&
            !strings.HasSuffix(local, ".") &&
            !strings.Contains(local, ".."), nil
    }
    { 
        return string(c.text), nil
    }

EmailAddressDomain <- [a-zA-Z0-9-]+ ("." [a-zA-Z0-9-]+)* {
        return string(c.text), nil
    }

// -----------------------------------------------------------------------------------------------------------------------
// List 
// -----------------------------------------------------------------------------------------------------------------------
ListElements <- 
    firstElement:(ListElement)
    extraElements:(ExtraListElements) {
        return types.NewListElements(append([]interface{}{firstElement}, extraElements.([]interface{})...))
    }

ListElement <- 
    OrderedListElement 
    / UnorderedListElement
    / CalloutListElement
    / LabeledListElement 

ExtraListElements <- elements:(ExtraListElement)* {
    return types.Flatten(elements.([]interface{})), nil
}

ExtraListElement <- // other elements can be separated by blankline WITHOUT attributes, or can have attributes but NO blankline before
    !EOF 
    element:(
        (   BlankLine* 
            element:(OrderedListElement / UnorderedListElement / CalloutListElement / LabeledListElement) { 
                return element, nil
            })
        / ( attributes:(BlockAttributes)+ 
            element:(OrderedListElement / UnorderedListElement / CalloutListElement / LabeledListElement) { 
                return append(attributes.([]interface{}), element), nil
            })
        / ListContinuation
        / SinglelineComment // must be attached, i.e., no intermediate blankline allowed
        / ListElementParagraphLine // must be attached, i.e., no intermediate blankline allowed
    ) {
        return element, nil
    }

ListElementParagraphLine <- 
    !BlankLine
    !ListContinuationMarker
    !OrderedListElementPrefix
    !UnorderedListElementPrefix
    !CalloutListElementPrefix
    !(LabeledListElementTerm LabeledListElementSeparator)
    !BlockDelimiter
    content:(ManyChars)
    EOL { // do not retain the EOL chars
        return types.NewRawLine(content.(string))
    }

ListElementContent <- 
    rawLines:([^\r\n]+ {
        return types.NewRawLine(string(c.text))
    })+
    EOL {
        return types.NewParagraph(nil, rawLines.([]interface{})...)
    }

// ---------------------------
// List Continuations
// ---------------------------
ListContinuation <- 
    offset:(Space* Newline)* 
    ListContinuationMarker
    element:ListContinuationElement?
    {
        return types.NewListContinuation(len(offset.([]interface{})), element)    
    }

ListContinuationMarker <- "+" Space* Newline

ListContinuationElement <- // TODO: same as DelimitedBlockElement?
    !EOF // quick escapes
    !ListElement
    attributes:(BlockAttributes)?
    element:(
        BlankLine
        / AttributeDeclaration
        / AttributeReset
        / DelimitedBlock
        / ThematicBreak // must appear before ListElement :/
        / ImageBlock
        / Table
        / SinglelineComment
        / ListContinuationParagraph // must be the last one... 
    ) {
        if element,ok := element.(types.WithAttributes); ok && attributes != nil {
            element.AddAttributes(attributes.(types.Attributes))
        }
        return element, nil
    }

// new paragraph with single line (other lines will be appended afterwards)
ListContinuationParagraph <- 
    style:(ParagraphStyle)? 
    content:(ListElementParagraphLine) {
        return types.NewParagraph(style, content)
    }

// ------------------------
// Ordered List Elements
// ------------------------
OrderedListElement <- 
    prefix:(OrderedListElementPrefix) 
    content:(ListElementContent) 
    {
        return types.NewOrderedListElement(prefix.(types.OrderedListElementPrefix), content)
    }

OrderedListElementPrefix <- 
    Space* prefix:(
        // implicit numbering: "." to "....."
        depth:((".")+ {   
            // `.` is 1, etc.
            return (len(c.text)), nil 
        }) 
        &{  
            // use a predicate to make sure that only `.` to `.....` are allowed
            return depth.(int) <= 5, nil 
        } 
        {
            switch depth.(int){
            case 1:
                return types.NewOrderedListElementPrefix(types.Arabic)
            case 2:
                return types.NewOrderedListElementPrefix(types.LowerAlpha)
            case 3:
                return types.NewOrderedListElementPrefix(types.LowerRoman)
            case 4:
                return types.NewOrderedListElementPrefix(types.UpperAlpha)
            default:
                return types.NewOrderedListElementPrefix(types.UpperRoman)
            }
        }
        // explicit numbering
        / ([0-9])+ "." {  // numbering style: "1.", etc.
            return types.NewOrderedListElementPrefix(types.Arabic)
        } / ([a-z]) "." { // numbering style: "a.", etc.
            return types.NewOrderedListElementPrefix(types.LowerAlpha)
        } / ([A-Z]) "." { // numbering style: "A.", etc.
            return types.NewOrderedListElementPrefix(types.UpperAlpha)
        } / ([ivxdlcm])+ ")" { // numbering style: "i)", etc.
            return types.NewOrderedListElementPrefix(types.LowerRoman)
        } / ([IVXDLCM])+ ")" { // numbering style: "I)", etc.
            return types.NewOrderedListElementPrefix(types.UpperRoman)
        }) Spaces {
    return prefix, nil
}

// ------------------------
// Unordered list Elements
// ------------------------
UnorderedListElement <- 
    prefix:(UnorderedListElementPrefix) 
    checkstyle:(UnorderedListElementCheckStyle)? 
    content:(ListElementContent) {
        return types.NewUnorderedListElement(prefix.(types.UnorderedListElementPrefix), checkstyle, content)
    }

UnorderedListElementPrefix <- 
    Space* 
    style:(
        (("-") / ("*")+) { // `-` or `*` to `*****`
            return string(c.text), nil 
        }
    ) &{  
        // use a predicate to make sure that only `*` to `*****` are allowed
        return len(style.(string)) <= 5, nil 
    } 
    Spaces
    {
        return types.NewUnorderedListElementPrefix(style.(string))
    }

UnorderedListElementCheckStyle <- 
    &"[" style:(
      "[ ]" { return types.Unchecked, nil } 
    / "[*]" { return types.Checked, nil } 
    / "[x]" { return types.Checked, nil }
    ) Spaces {
        return style, nil
    }

// ------------------------
// Labelled list elements
// ------------------------
LabeledListElement <- 
    term:(LabeledListElementTerm) 
    separator:(LabeledListElementSeparator) 
    description:(LabeledListElementDescription) // `description` is not necessarily on the same line as the `term`
    {
        return types.NewLabeledListElement(len(separator.(string)) - 1, term, description)
    }

LabeledListElementTerm <- 
    (!LabeledListElementSeparator !EOL .)+ {
        return types.NewRawLine(strings.TrimSpace(string(c.text)))
    }

LabeledListElementSeparator <- 
    separator:((":")+ {   
        return string(c.text), nil
    })
    &{  
        // use a predicate to make sure that separator is `::`, `:::` or `::::`
        return len(separator.(string)) >= 2 && len(separator.(string)) <= 4, nil 
    } {
        return separator, nil
    }

LabeledListElementDescription <-
    (
        // description NOT on the same line as the term
        Space* EOL
        BlankLine*
        {
            return nil, nil
        }
    ) / (
        // description on the same line as the term
        Spaces // required spaces after delimiter (trimmed from content)
        content:([^\r\n]+ {
            return types.NewRawLine(string(c.text))
        })
        EOL 
        {
            return types.NewParagraph(nil, content)
        }
    )

// ------------------------
// Callout list elements
// ------------------------
Callout <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Callouts), nil
    }
    "<" ref:([0-9]+ { return strconv.Atoi(string(c.text)) }) ">" Space* &(EOL / Callout) {
        return types.NewCallout(ref.(int))
    }

CalloutListElement <- 
    ref:(CalloutListElementPrefix) 
    description:(ListElementContent) {
        return types.NewCalloutListElement(ref.(int), description.(*types.Paragraph))
    }

CalloutListElementPrefix <- 
    "<" ref:([0-9]+ { return strconv.Atoi(string(c.text)) }) ">" Spaces {
        return ref, nil
    }

// -----------------------------------------------------------------------------------------------------------------------
// Paragraphs
// -----------------------------------------------------------------------------------------------------------------------

ParagraphStyle <- 
    &{
        return !c.isWithinLiteralParagraph(), nil
    }
    style:("TIP: " {
            return types.Tip, nil
        } / "NOTE: " {
            return types.Note, nil
        } / "IMPORTANT: " {
            return types.Important, nil
        } / "WARNING: " {
            return types.Warning, nil
        } / "CAUTION: " {
            return types.Caution, nil
        } / &(Spaces) { // check 
            return types.LiteralParagraph, nil
        }) {
            return style, nil
        }

ShortcutParagraph <- 
    // TODO: also allow quoted text delimiters?
    &(Alphanum !(("." / ")") Spaces)) // make sure that the line starts with an alphanum and it's not an ordered list element prefix (eg: `1. ` or `a) `)
    style:(ParagraphStyle)?
    firstLine:(ParagraphRawLine) 
    &{
        // also, make sure that there is no LabeledListElement delimiter (`::` - `::::`) 
        //   in the middle of the line (with space afterwards)
        //   or at the end of the line 
        return !strings.Contains(string(firstLine.(types.RawLine)), ":: ") && 
            !strings.HasSuffix(string(firstLine.(types.RawLine)), "::"), nil
    }
    otherLines:(
        !EOF 
        !BlankLine
        !BlockAttributes
        !BlockDelimiter
        !ListContinuationMarker
        line:(SinglelineComment / ParagraphRawLine) {
            return line, nil
        })* 
    {
        return types.NewParagraph(style, append([]interface{}{firstLine}, otherLines.([]interface{})...)...)
    }

Paragraph <- 
    style:(ParagraphStyle)? 
    firstLine:(ParagraphRawLine) 
    otherLines:(
        !EOF
        !BlankLine
        !BlockAttributes
        line:(SinglelineComment / ParagraphRawLine) {
            return line, nil
        })* 
    {
        return types.NewParagraph(style, append([]interface{}{firstLine}, otherLines.([]interface{})...)...)
    }

ParagraphRawLine <- 
    content:(ManyChars)
    &{
        return len(strings.TrimSpace(content.(string))) > 0, nil // stop if blank line
    }
    EOL {
        return types.NewRawLine(content.(string))
    }

// -----------------------------------------------------------------------------------------------------------------------
// Quoted Texts (bold, italic, monospace, marked, superscript and subscript)
// -----------------------------------------------------------------------------------------------------------------------
QuotedText <- EscapedQuotedText / UnescapedQuotedText

EscapedQuotedText <-
    attributes:(LongHandAttributes {
        return string(c.text), nil
    })?
    &(`\`)
    element:(
        EscapedBoldText 
        / EscapedItalicText
        / EscapedMonospaceText
        / EscapedMarkedText
        / EscapedSubscriptText
        / EscapedSuperscriptText
    ) {
        return append([]interface{}{attributes}, element.([]interface{})...), nil
    }

UnescapedQuotedText <-  // unescaped 
    attributes:(LongHandAttributes)?
    element:(DoubleQuotedText / SingleQuotedText) {
        return element.(*types.QuotedText).WithAttributes(attributes)
    }

SingleQuotedTextMarker <- "*" !"*" / "_" !"_" / "#" !"#" / "`" !"`"

DoubleQuotedTextPrefix <- "**" / "__" / "``" / "##" / "^" / "~"

SingleQuotedText <- 
    SingleQuoteBoldText 
    / SingleQuoteItalicText
    / SingleQuoteMonospaceText 
    / SingleQuoteMarkedText
    / SubscriptText 
    / SuperscriptText 

DoubleQuotedText <- 
    DoubleQuoteBoldText
    / DoubleQuoteItalicText
    / DoubleQuoteMonospaceText
    / DoubleQuoteMarkedText

SubscriptOrSuperscriptPrefix <- "^" / "~" { // rule used within `words` to detect superscript or subscript portions, eg in math formulae.
        return string(c.text), nil
    }

OneOrMoreBackslashes <- `\`+ {
        return string(c.text), nil
    }

TwoOrMoreBackslashes <- `\\` `\`* {
        return string(c.text), nil
    }

// ---------------------------------------------------
// Quoted Bold Text
// ---------------------------------------------------

BoldTextDelimiter <- "*"

BoldTextWord <- 
    ([\pL\pN]) // start with letter or number
    ([\pL\pN,;?!])*
    &(Space / BoldTextDelimiter) {
        return types.NewStringElement(string(c.text))
    }

// -------------------------------
// Bold text within double quotes
// -------------------------------
DoubleQuoteBoldTextStartDelimiter <- "**"

DoubleQuoteBoldTextEndDelimiter <- "**"

DoubleQuoteBoldText <- 
    DoubleQuoteBoldTextStartDelimiter 
    elements:(DoubleQuoteBoldTextElements) 
    DoubleQuoteBoldTextEndDelimiter {
        return types.NewQuotedText(types.DoubleQuoteBold, elements.([]interface{}))
    } 

DoubleQuoteBoldTextElements <- DoubleQuoteBoldTextElement+  

DoubleQuoteBoldTextElement <- 
    !EOF
    !DoubleQuoteBoldTextEndDelimiter
    element:(
        BoldTextWord
        / Spaces // may start and end with spaces
        / SingleNewline // 2 newlines split the paragraph
        / AttributeReference
        / InlineMacro
        / Replacement
        / SpecialCharacter // must be after InlineMacro (because of BareURL)
        / QuotedText
        / ElementPlaceHolder
        / AnyChar
    ) {
        c.trackElement(element)
        return element, nil
    }

// -------------------------------
// Bold text within single quotes
// -------------------------------
SingleQuoteBoldTextStartDelimiter <- 
    "*" 
    &{
        log.Debug("SingleQuoteBoldTextStartDelimiter")
        return c.isSingleQuotedTextAllowed(), nil
    }
    &(!"*") // not to be confused with double quoted start delimiter

SingleQuoteBoldTextEndDelimiter <- 
    "*" 
    !"*" // do not collide with nested double quoted bold text
    &{
        log.Debug("SingleQuoteBoldTextEndDelimiter")
        return !c.isPrecededBySpace(), nil
    }
    &(!Alphanum)

SingleQuoteBoldText <- 
    SingleQuoteBoldTextStartDelimiter
    elements:(SingleQuoteBoldTextElements) 
    SingleQuoteBoldTextEndDelimiter {
        return types.NewQuotedText(types.SingleQuoteBold, elements.([]interface{}))
    } 

SingleQuoteBoldTextElements <-  
    !Space // cannot start with spaces
    elements:(SingleQuoteBoldTextElement)+ 
    &{
        return validateSingleQuoteElements(elements.([]interface{})) // cannot end with spaces
    }{
        return elements, nil
    }

SingleQuoteBoldTextElement <- 
    !EOF // TODO: needed?
    !SingleQuoteBoldTextEndDelimiter
    element:( // TODO: same rule in other kinds of quoted text -> new rule to regroup
        BoldTextWord
        / Spaces
        / SingleNewline // 2 newlines split the paragraph
        / InlineMacro
        / AttributeReference
        / Replacement
        / SpecialCharacter // must be after InlineMacro (because of BareURL)
        / QuotedText
        / ElementPlaceHolder
        / AnyChar
    ) {
        c.trackElement(element)
        return element, nil
    }

EscapedBoldText <- 
    // double escape: \\**not bold**
    backslashes:(TwoOrMoreBackslashes) "**" elements:(DoubleQuoteBoldTextElements) "**" { 
        return types.NewEscapedQuotedText(backslashes.(string), "**", elements.([]interface{}))
    } 
    // unbalanced double escape: \\**not bold*
    / backslashes:(OneOrMoreBackslashes) "**" elements:(SingleQuoteBoldTextElements) "*" { 
        result := append([]interface{}{"*"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "*", result)
    } 
    // single escape: \*not bold*
    / backslashes:(OneOrMoreBackslashes) "*" elements:(SingleQuoteBoldTextElements) "*" { 
        return types.NewEscapedQuotedText(backslashes.(string), "*", elements.([]interface{}))
    }

// ---------------------------------------------------------
// Quoted Italic Text
// ---------------------------------------------------------

ItalicTextDelimiter <- "_"

ItalicTextWord <- 
    ([\pL\pN]) // start with letter or number
    ([\pL\pN,;?!])*
    &(Space / ItalicTextDelimiter) {
        return types.NewStringElement(string(c.text))
    }

// ---------------------------------
// Italic text within double quotes
// ---------------------------------
DoubleQuoteItalicTextStartDelimiter <- "__"

DoubleQuoteItalicTextEndDelimiter <- "__"

DoubleQuoteItalicText <- 
    DoubleQuoteItalicTextStartDelimiter 
    elements:(DoubleQuoteItalicTextElements) 
    DoubleQuoteItalicTextEndDelimiter {
        return types.NewQuotedText(types.DoubleQuoteItalic, elements.([]interface{}))
    }

DoubleQuoteItalicTextElements <- DoubleQuoteItalicTextElement+ 

DoubleQuoteItalicTextElement <- 
    !EOF
    !DoubleQuoteItalicTextEndDelimiter
    element:(
        ItalicTextWord
        / Spaces // may start and end with spaces
        / SingleNewline // 2 newlines split the paragraph
        / AttributeReference
        / InlineMacro
        / Replacement
        / SpecialCharacter // must be after InlineMacro (because of BareURL)
        / QuotedText
        / ElementPlaceHolder
        / AnyChar
    ) {
        c.trackElement(element)
        return element, nil
    }

// ---------------------------------
// Italic text within single quotes
// ---------------------------------
SingleQuoteItalicTextStartDelimiter <- 
    "_" 
    &{
        log.Debug("SingleQuoteItalicTextStartDelimiter")
        return c.isSingleQuotedTextAllowed(), nil
    }
    &(!"_") // not to be confused with double quoted start delimiter
    

SingleQuoteItalicTextEndDelimiter <- 
    "_" 
    !"_" // do not collide with nested double quoted italic text
    &{
        log.Debug("SingleQuoteItalicTextEndDelimiter")
        return !c.isPrecededBySpace(), nil
    }
    &(!Alphanum)

SingleQuoteItalicText <- 
    SingleQuoteItalicTextStartDelimiter
    elements:(SingleQuoteItalicTextElements) 
    SingleQuoteItalicTextEndDelimiter { 
        return types.NewQuotedText(types.SingleQuoteItalic, elements.([]interface{}))
    } 

SingleQuoteItalicTextElements <- 
    !Space // cannot start with spaces
    elements:(SingleQuoteItalicTextElement)+
    &{
        return validateSingleQuoteElements(elements.([]interface{})) // cannot end with spaces
    }{
        return elements, nil
    }

SingleQuoteItalicTextElement <- 
    !EOF
    !SingleQuoteItalicTextEndDelimiter
    element:(
        ItalicTextWord
        / Spaces
        / SingleNewline // 2 newlines split the paragraph // TODO: is `!NewLine` really needed??
        / AttributeReference
        / InlineMacro 
        / Replacement
        / SpecialCharacter // must be after InlineMacro (because of BareURL)
        / QuotedText
        / ElementPlaceHolder
        / AnyChar
    ) {
        c.trackElement(element)
        return element, nil
    }

EscapedItalicText <- 
    // double escape: \\__not italic__
    backslashes:(TwoOrMoreBackslashes) "__" elements:(DoubleQuoteItalicTextElements) "__" {
        return types.NewEscapedQuotedText(backslashes.(string), "__", elements.([]interface{}))
    } 
    // unbalanced double escape: \\__not italic_
    / backslashes:(OneOrMoreBackslashes) "__" elements:(SingleQuoteItalicTextElements) "_" { // unbalanced `__` vs `_` punctuation
        result := append([]interface{}{"_"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "_", result)
    } 
    // single escape: \_not italic_
    / backslashes:(OneOrMoreBackslashes) "_" elements:(SingleQuoteItalicTextElements) "_" { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "_", elements.([]interface{}))
    } 

// ------------------------------------------------------------------
// Quoted Monospace Text
// ------------------------------------------------------------------

MonospaceTextDelimiter <- "`"

MonospaceTextWord <- 
    ([\pL\pN]) // start with letter or number
    ([\pL\pN,;?!])*
    &(Space / MonospaceTextDelimiter) {
        return types.NewStringElement(string(c.text))
    }

// ------------------------------------
// Monospace text within double quotes
// ------------------------------------
DoubleQuoteMonospaceTextStartDelimiter <- "``"

DoubleQuoteMonospaceTextEndDelimiter <- "``"

DoubleQuoteMonospaceText <- 
    DoubleQuoteMonospaceTextStartDelimiter 
    elements:(DoubleQuoteMonospaceTextElements) 
    DoubleQuoteMonospaceTextEndDelimiter { 
        return types.NewQuotedText(types.DoubleQuoteMonospace, elements.([]interface{}))
    }

DoubleQuoteMonospaceTextElements <- DoubleQuoteMonospaceTextElement+ // may start and end with spaces

DoubleQuoteMonospaceTextElement <- 
    !EOF
    !DoubleQuoteMonospaceTextEndDelimiter
    element:(
        MonospaceTextWord
        / Spaces // may start and end with spaces
        / SingleNewline // 2 newlines split the paragraph
        / AttributeReference
        / InlineMacro
        / Replacement
        / SpecialCharacter // must be after InlineMacro (because of BareURL)
        / QuotedText
        / ElementPlaceHolder
        / AnyChar
    ) {
        c.trackElement(element)
        return element, nil
    }

// ------------------------------------
// Monospace text within single quotes
// ------------------------------------

// need to distinguish start vs end because of quoted string which also use the same "`"
SingleQuoteMonospaceTextStartDelimiter <- 
    "`" 
    &{
        log.Debug("SingleQuoteMonospaceTextStartDelimiter")
        return c.isSingleQuotedTextAllowed(), nil
    }
    &(!"`") // not to be confused with double quoted start delimiter

SingleQuoteMonospaceTextEndDelimiter <- 
    !QuotationMark 
    "`"
    // !"`" // do not collide with nested double quoted monospace text
    &{
        log.Debug("SingleQuoteMonospaceTextEndDelimiter")
        return !c.isPrecededBySpace(), nil
    }
    &(!Alphanum)
    

SingleQuoteMonospaceText <- 
    SingleQuoteMonospaceTextStartDelimiter 
    elements:(SingleQuoteMonospaceTextElements) 
    SingleQuoteMonospaceTextEndDelimiter { 
        return types.NewQuotedText(types.SingleQuoteMonospace, elements.([]interface{}))
    } 

SingleQuoteMonospaceTextElements <- 
    !Space // cannot start with spaces
    elements:(SingleQuoteMonospaceTextElement)+
    &{
        return validateSingleQuoteElements(elements.([]interface{})) // cannot end with spaces
    }{
        return elements, nil
    }

SingleQuoteMonospaceTextElement <- 
    !EOF
    !SingleQuoteMonospaceTextEndDelimiter
    element:(
        MonospaceTextWord
        / Spaces
        / SingleNewline // 2 newlines split the paragraph
        / AttributeReference
        / InlineMacro
        / Replacement
        / SpecialCharacter // must be after InlineMacro (because of BareURL)
        / QuotedText
        / ElementPlaceHolder
        / AnyChar
    ) {
        c.trackElement(element)
        return element, nil
    }

EscapedMonospaceText <- 
    // double escape: \\``not monospace``
    backslashes:(TwoOrMoreBackslashes) "``" elements:(DoubleQuoteMonospaceTextElements) "``" {
        return types.NewEscapedQuotedText(backslashes.(string), "``", elements.([]interface{}))
    } 
    // unbalanced double escape: \\``not monospace``
    / backslashes:(OneOrMoreBackslashes) "``" elements:(SingleQuoteMonospaceTextElements) "`" {
        result := append([]interface{}{"`"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "`", result)
    } 
    // single escape: \`not monospace`
    / backslashes:(OneOrMoreBackslashes) "`" elements:(SingleQuoteMonospaceTextElements) "`" {
        return types.NewEscapedQuotedText(backslashes.(string), "`", elements.([]interface{}))
    }

// ---------------------------------------------------------
// Quoted Marked Text
// ---------------------------------------------------------

MarkedTextDelimiter <- "#"

MarkedTextWord <- 
    ([\pL\pN]) // start with letter or number
    ([\pL\pN,;?!])*
    &(Space / MarkedTextDelimiter) {
        return types.NewStringElement(string(c.text))
    }

// ------------------------------------
// Marked text within double quotes
// ------------------------------------
DoubleQuoteMarkedTextStartDelimiter <- "##"

DoubleQuoteMarkedTextEndDelimiter <- "##"

DoubleQuoteMarkedText <- 
    DoubleQuoteMarkedTextStartDelimiter 
    elements:(DoubleQuoteMarkedTextElements) 
    DoubleQuoteMarkedTextEndDelimiter { 
        return types.NewQuotedText(types.DoubleQuoteMarked, elements.([]interface{}))
    }

DoubleQuoteMarkedTextElements <- DoubleQuoteMarkedTextElement*

DoubleQuoteMarkedTextElement <- // may start and end with spaces
    !EOF
    !DoubleQuoteMarkedTextEndDelimiter
    element:(
        MarkedTextWord
        / Spaces // may start and end with spaces
        / SingleNewline // 2 newlines split the paragraph
        / AttributeReference
        / InlineMacro
        / Replacement
        / SpecialCharacter // must be after InlineMacro (because of BareURL)
        / QuotedText
        / ElementPlaceHolder
        / AnyChar
    ) {
        c.trackElement(element)
        return element, nil
    }

// ------------------------------------
// Marked text within single quotes
// ------------------------------------
SingleQuoteMarkedTextStartDelimiter <- 
    "#" 
    &{
        log.Debug("SingleQuoteMarkedTextStartDelimiter")
        return c.isSingleQuotedTextAllowed(), nil
    }
    &(!"#") // not to be confused with double quoted start delimiter

SingleQuoteMarkedTextEndDelimiter <- 
    "#"
    !"#" // do not collide with nested double quoted bold text
    &{
        log.Debug("SingleQuoteMarkedTextEndDelimiter")
        return !c.isPrecededBySpace(), nil
    }
    &(!Alphanum)

SingleQuoteMarkedText <- 
    SingleQuoteMarkedTextStartDelimiter
    elements:(SingleQuoteMarkedTextElements) 
    SingleQuoteMarkedTextEndDelimiter { 
        return types.NewQuotedText(types.SingleQuoteMarked, elements.([]interface{}))
    } 

SingleQuoteMarkedTextElements <- 
    !Space // cannot start with spaces
    elements:(SingleQuoteMarkedTextElement)+ 
    &{
        return validateSingleQuoteElements(elements.([]interface{})) // cannot end with spaces
    }{
        return elements, nil
    }

SingleQuoteMarkedTextElement <- 
    !EOF
    !SingleQuoteMarkedTextEndDelimiter
    element:(
        MarkedTextWord
        / Spaces
        / SingleNewline // 2 newlines split the paragraph
        / AttributeReference
        / InlineMacro
        / Replacement
        / SpecialCharacter // must be after InlineMacro (because of BareURL)
        / QuotedText
        / ElementPlaceHolder
        / AnyChar
    ) {
        c.trackElement(element)
        return element, nil
    }

EscapedMarkedText <-
    // double escape: \\##not marked##
    backslashes:(TwoOrMoreBackslashes) "##" elements:(DoubleQuoteMarkedTextElements) "##" {
        return types.NewEscapedQuotedText(backslashes.(string), "##", elements.([]interface{}))
    } 
    // unbalanced double escape: \\##not marked#
    / backslashes:(OneOrMoreBackslashes) "##" elements:(SingleQuoteMarkedTextElements) "#" {
        result := append([]interface{}{"#"}, elements.([]interface{}))
        return types.NewEscapedQuotedText(backslashes.(string), "#", result)
    } 
    // single escape: \#not marked#
    / backslashes:(OneOrMoreBackslashes) "#" elements:(SingleQuoteMarkedTextElements) "#" {
        return types.NewEscapedQuotedText(backslashes.(string), "#", elements.([]interface{}))
    }

// ---------------------------------------------------------------
// Quoted Subscript Text
// ---------------------------------------------------------------
SubscriptText <- 
    SubscriptTextDelimiter
    element:(SubscriptTextElement)
    SubscriptTextDelimiter { // wraps a single word
        return types.NewQuotedText(types.SingleQuoteSubscript, element)
    }

SubscriptTextDelimiter <- "~"

SubscriptTextElement <- QuotedText / NonSubscriptText 

NonSubscriptText <- [^\r\n ~]+ { // anything except spaces, EOL or '~'
        return c.text, nil
    }

EscapedSubscriptText <-
    // single escape: \~not subscript~
    backslashes:(OneOrMoreBackslashes) 
    SubscriptTextDelimiter 
    element:(SubscriptTextElement)
    SubscriptTextDelimiter { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "~", element)
    } 

// -----------------------
// Quoted Superscript Text
// -----------------------
SuperscriptText <- 
    SuperscriptTextDelimiter 
    element:(SuperscriptTextElement) 
    SuperscriptTextDelimiter { // wraps a single word
        return types.NewQuotedText(types.SingleQuoteSuperscript, element)
    }

SuperscriptTextDelimiter <- "^"

SuperscriptTextElement <- QuotedText / NonSuperscriptText 

NonSuperscriptText <- [^\r\n ^]+ { // anything except spaces, EOL or '^'
        return c.text, nil
    }

EscapedSuperscriptText <- 
    // single escape: \^not superscript^
    backslashes:(OneOrMoreBackslashes) 
    SuperscriptTextDelimiter 
    element:(SuperscriptTextElement) 
    SuperscriptTextDelimiter { // simple punctuation must be evaluated last
        return types.NewEscapedQuotedText(backslashes.(string), "^", element)
    } 

// -------------------------------------------------------------------------------------
// Sections
// -------------------------------------------------------------------------------------
// we need to identify section titles to properly handle file inclusions with level offsets
Section <- 
    &{  
        return !c.isWithinDelimitedBlock(), nil
    }
    level:(("=")+ {   
        // `=` is level 0, `==` is level 1, etc.
        return (len(c.text)-1), nil 
    })
    &{  
        // use a predicate to make sure that only `=` (level 0) to `======` (level 5) are allowed
        return level.(int) <= 5, nil 
    } 
    Spaces title:(SectionTitle) EOL {
        return types.NewSection(level.(int), title.([]interface{})) 
    }

SectionTitle <- 
    #{
        // enable substitutions
        c.withSubstitutions(headerSubstitutions())
        return nil
    }
    elements:(SectionTitleElement)+ { 
        return types.NewInlineElements(elements)
    }

SectionTitleElement <-
    !EOL
    element:(
        InlineWord
        / (Space+ id:(LegacyElementID) Space* &EOL { return id, nil}) // (legacy) element ID
        / Space
        / InlinePassthrough
        / Quote
        / Link
        / Replacement
        / SpecialCharacter // must be after Link (because of BareURL)
        / InlineIcon
        / AttributeReference
        / ElementPlaceHolder // needed when parsing a second time, after first pass returned attribute substitutions
        / InlineAnchor // must be after LegacyElementID
        / InlineFootnote
        / AnyChar) {
            c.trackElement(element)
            return element, nil
        }


// -------------------------------------------------------------------------------------
// Substitutions
// -------------------------------------------------------------------------------------

// Substitution groups
NormalGroup <- // TODO: verify same order of rules as in AttributeStructuredValue?
    elements:(
        !EOF
        element:(
            InlineWord
            / Space
            / Newline
            / InlineMacro // must be before SpecialCharacter (because of CrossReference)
            / Quote // must be before Symbol // TODO: move before InlineMacro?
            / ElementPlaceHolder // TODO: needed when parsing a second time? after first pass returned attribute substitutions
            / Replacement
            / LineBreak 
            / InlinePassthrough
            / Callout // must be placed before SpecialCharacter
            / SpecialCharacter // must be after InlineMacro (because of BareURL)
            / AttributeReference
            / AnyChar) {
                c.trackElement(element)
                return element, nil
            }
        )+ EOF {
            return types.NewInlineElements(elements)
        }

// Substitutions for specific attributes whose value allows for quoted content and inline macros
AttributeStructuredValue <- 
    elements:(AttributeStructuredValueElement)+ EOF { 
        return types.NewInlineElements(elements)
    }

AttributeStructuredValueElement <- 
    !EOF
    element:(
        InlineWord
        / Space 
        / InlineMacro
        / Quote
        / SpecialCharacter
        / Symbol // TODO: use `Replacement`?
        / ElementPlaceHolder
        / AnyChar) {
            c.trackElement(element)
            return element, nil
        }
    
// Substitution types        

InlineMacro <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Macros), nil
    }
    element:(
        InlineIcon
        / InlineImage 
        / Link 
        / InlinePassthrough 
        / InlineFootnote 
        / CrossReference 
        / InlineUserMacro 
        / InlineAnchor
        / ConcealedIndexTerm
        / IndexTerm
        / InlineButton
        / InlineMenu) {
            return element, nil
        }

InlinePassthrough <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(InlinePassthroughs), nil
    }
    element:(
        TriplePlusPassthrough / SinglePlusPassthrough / PassthroughMacro
    ) {
        return element, nil
    }

Quote <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Quotes), nil
    }
    QuotedText 

Replacement <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(Replacements), nil
    }
    element:(
        Symbol
    ) {
        return element, nil
    }

SpecialCharacter <- 
    // check if enabled with the current substitution context
    &{
        return c.isSubstitutionEnabled(SpecialCharacters), nil
    }
    element:(
        // if we have a InternalCrossReference we just return a StringElement. 
        InternalCrossReference {
            return types.NewStringElement(string(c.text))
        } 
        / ("<" / ">" / "&" ) {
            return types.NewSpecialCharacter(string(c.text))
        }) {
            return element, nil
        }

// -------------------------------------------------------------------------------------
// Single Line Comment
// -------------------------------------------------------------------------------------
SinglelineComment <- SinglelineCommentDelimiter content:(SinglelineCommentContent) EOL {
        return types.NewSinglelineComment(content.(string))
    }

// can be `//` but not `////` (comment block delimiter)
SinglelineCommentDelimiter <- "//" !"//" 

SinglelineCommentContent <- AnyChars

// -------------------------------------------------------------------------------------
// Symbol // TODO: use `Replacement`?s
// -------------------------------------------------------------------------------------
Symbol <- 
    // escaped
    `\` (QuotationMark / Copyright / Trademark / Registered / Ellipsis / SingleRightArrow / Mdash / SingleLeftArrow / DoubleRightArrow / DoubleLeftArrow) {
        return types.NewStringElement(strings.TrimPrefix(string(c.text), `\`))
    }
    // unescaped
    / QuotationMark / Copyright / Trademark / Registered / Ellipsis / Mdash / SingleRightArrow / SingleLeftArrow / DoubleRightArrow / DoubleLeftArrow
    // 
    / TypographicQuote

QuotationMark <- 
    "\"`" {
        return types.NewSymbol("\"`")
    }
    / "`\"" {
        return types.NewSymbol("`\"")
    }
    / "'`" {
        return types.NewSymbol("'`")
    }
    / "`'" {
        return types.NewSymbol("`'")
    } 

Copyright <- "(C)" {
        return types.NewSymbol("(C)")
    }

Trademark <- "(TM)" {
        return types.NewSymbol("(TM)")
    }

Registered <- "(R)" {
        return types.NewSymbol("(R)")
    }

Ellipsis <- "..." {
        return types.NewSymbol("...")
    }

Mdash <- 
    // 2 flavours: 
    // a. preceded by a space character and followed by space or EOL
    "--" 
    &{
        log.Debug("Mdash (a)")
        return c.isPrecededBySpace(), nil
    }
    (Space / &EOL) {
        return types.NewSymbol(" -- ")
    }
    /
    // b. preceded and followed by an alphanum character
    "--" 
    &{
        log.Debug("Mdash (b)")
        return c.isPrecededByAlphanum(), nil
    }
    &(Alphanum / EOL) {
        return types.NewSymbol("--")
    }
    


SingleRightArrow <- "->" {
        return types.NewSymbol("->")
    }

SingleLeftArrow <- "<-" {
        return types.NewSymbol("<-")
    }

DoubleRightArrow <- "=>" {
        return types.NewSymbol("=>")
    }

DoubleLeftArrow <- "<=" {
        return types.NewSymbol("<=")
    }

// The implied apostrophe is used in interior words, and intended to help
// cases like "mother's day".  Asciidoctor requires that it be followed by
// a letter (not a digit) but it can have a digit just before it.
TypographicQuote <- 
    // escaped
    `\'` &[\pL] {
        log.Debug("matched escaped apostrophe")
        return types.NewStringElement(`'`) // retain the apostrophe, but discard the `\` escape char
    }
    /
    // unescaped
     &{
        log.Debugf("TypographicQuote at pos %s", c.pos.String())
        return c.isPrecededByAlphanum(), nil
    }
     `'` &[\pL] {
        return types.NewSymbol("'") 
    }

// -------------------------------------------------------------------------------------
// Tables
// -------------------------------------------------------------------------------------
Table <- 
    TableStartDelimiter
    lines:(BlankLine / TableLine)*
    TableEndDelimiter {
        return types.NewTable(lines.([]interface{}))
    }

TableDelimiter <- "|===" Space* EOL 

TableStartDelimiter <- TableDelimiter

TableEndDelimiter <- TableDelimiter / EOF

TableLine <-
    !TableEndDelimiter
    content:(
        (cells:(InlineTableCells / MultilineTableCells) {
            return types.NewTableRow(cells.([]interface{}))
        })
        / BlankLine
    ) {
        return content, nil
    }

InlineTableCells <- cells:(InlineTableCell)+ EOL { 
    return cells, nil
}

InlineTableCell <- 
    "|" Space* content:(InlineTableCellContent) // no format specifier supported when cells are "inline"
    {
        return types.NewInlineTableCell(content.(types.RawLine))
    }

InlineTableCellContent <- 
    content:([^|\r\n]* {
        return string(c.text), nil
    }) {
        return types.NewRawLine(content.(string))
    }

MultilineTableCells <- cells:(MultilineTableCell)+ {
    return cells, nil
}

MultilineTableCell <- 
    !TableEndDelimiter
    !BlankLine
    format:(TableCellFormat)? "|" Space* Newline? content:(MultilineTableCellContent)
    {
        return types.NewMultilineTableCell(content.([]interface{}), format)
    }

MultilineTableCellContent <- 
    (
        !TableEndDelimiter
        !BlankLine
        !(format:(TableCellFormat)? "|")
        content:([^|\r\n]* {
            return string(c.text), nil
        }) EOL? {
            return types.NewRawLine(content.(string))
        }
    )*

TableCellFormat <- [^ |\r\n]* {
    return string(c.text), nil
}

// rule for the optional `cols` attribute on a Table
TableColumnsAttribute <- cols:(Column)* EOF {
        return cols, nil
    }

Column <- 
    !EOF
    // TODO: `multiplier` and `weight` with multiple digits and max values
    // TODO: also support column styles
    multiplier:(n:Integer "*" { return n, nil })?
    halign:(
        "<" { return types.HAlignLeft, nil }
        / ">" { return types.HAlignRight, nil }
        / "^" { return types.HAlignCenter, nil }
    )?
    valign:(
        ".<" { return types.VAlignTop, nil }
        / ".>" { return types.VAlignBottom, nil }
        / ".^" { return types.VAlignMiddle, nil }
    )?
    weight:(Integer / ("~" { return string(c.text), nil }))?
    style:([adehlms] { return string(c.text), nil })?
    // style:(("a" / "e" / "h" / "l" / "m" / "s") { return string(c.text), nil })?
    comma:(",")?
    &{
        // make sure that at least something was set
        // (otherwise the parser will run indefinitely)
        return multiplier != nil ||
            halign != nil ||
            valign != nil ||
            weight != nil ||
            style != nil ||
            comma != nil, nil
    }
    {
        return types.NewTableColumn(multiplier, halign, valign, weight, style)
    }

// -------------------------------------------------------------------------------------
// Thematic break
// -------------------------------------------------------------------------------------
ThematicBreak <- (
        "'''" // Asciidoc flavour
        / "***" / "* * *" / "---" / "- - -" / "___" / "_ _ _" // Markdown flavours are supported, too
        ) Space* EOL EOL { 
        return types.NewThematicBreak()
    }

// -------------------------------------------------------------------------------------
// User Macro
// -------------------------------------------------------------------------------------
UserMacroBlock <- 
    name:(UserMacroName) 
    &{
        // skip if no macro was registered under the given name 
      return c.hasUserMacro(name.(string)), nil  
    }
    "::" 
    value:(UserMacroValue) 
    attributes:(InlineAttributes) EOL {
        return types.NewUserMacroBlock(name.(string), value.(string), attributes.(types.Attributes), string(c.text))
    }

InlineUserMacro <- 
    name:(UserMacroName) 
    &{
        // skip if no macro was registered under the given name 
      return c.hasUserMacro(name.(string)), nil  
    }
    ":" 
    value:(UserMacroValue) 
    attributes:(InlineAttributes) {
        return types.NewInlineUserMacro(name.(string), value.(string), attributes.(types.Attributes), string(c.text))
    }

UserMacroName <- ([\pL\pN_-]+) {
        return string(c.text), nil
    }

UserMacroValue <- [^:[ \r\n]* {
        return string(c.text), nil
    }

// -------------------------------------------------------------------------------------
// Base Types
// -------------------------------------------------------------------------------------
Alphanum <- [\pL\pN]

Parenthesis <- "(" / ")" / "[" / "]" / "{" / "}" 

Alphanums <- [\pL\pN]+ {
        return string(c.text), nil
    }

InlineWord <- 
    ([\pL\pN]) // start with letter or number
    ([\pL\pN,;?!])* // then other letter, number of punctuation
    &(Space / ElementPlaceHolderDelimiter / EOL)
    {
        return types.NewStringElement(string(c.text))
    }


PunctuationCharacter <- [.,;?!] {
    return string(c.text), nil
}

// this is a fall-back rule in case all preceeding rules failed to match the current content.
AnyChar <- [^\r\n] { 
        return string(c.text), nil
    }

AnyChars <- [^\r\n]* { 
        return string(c.text), nil
    }

ManyChars <- [^\r\n]+ { 
        return string(c.text), nil
    }

FileLocation <- path:(Filename / ElementPlaceHolder)+ {
        return types.NewLocation("", path.([]interface{}))
    }

Location <- scheme:(Scheme)? path:(Filename / ElementPlaceHolder)+ {
        return types.NewLocation(scheme, path.([]interface{}))
    }

LocationWithScheme <- !"[" scheme:(Scheme) path:(Filename)+ {
        return types.NewLocation(scheme, path.([]interface{}))
    }

Scheme <- ("http://" / "https://" / "ftp://" / "irc://" / "mailto:") {
    return string(c.text), nil
}

Filename <- 
    !"[" // quick escape
    elements:(
        ([^\r\n[\]\uFFFD{.,;?! ])+ { // not supported for now: EOL, space, "{", "[", "]". Also, punctuation chars and `<` and `>` special chars are treated separately below (but `&` is allowed)
            return types.NewStringElement(string(c.text))
        }
        / PunctuationCharacter &(!(EOF / Space))
        / AttributeReference 
        / "{" {
            return types.NewStringElement(string(c.text))
        })+ {
        return types.NewInlineElements(elements.([]interface{}))
    }

Id <- [^[\]<>,]+ { // previously: (Alphanums / (!Newline !Space !"[" !"]" !"<<" !">>" !","  .))+
        return string(c.text), nil
    }

Number <- Float
    / Integer

Integer <- ("-"? [0-9]+) {
        return strconv.Atoi(string(c.text))
    }

Float <- ("-"? [0-9]+ "." [0-9]+) {
        return strconv.ParseFloat(string(c.text), 64)
    }

Space <- (" " / "\t") {
        return string(c.text), nil
    }

Spaces <- (" " / "\t")+ {
        // log.Debug("matched multiple spaces")
        return string(c.text), nil
    }

Newline <- ("\n" / "\r\n" / "\r") { // TODO: just use "\n" 
    return string(c.text), nil
}

SingleNewline <- Newline !Newline {
    return string(c.text), nil
}

EOF <- !.

// TODO: remove and use `EOF` instead?
EOL <- Newline / EOF