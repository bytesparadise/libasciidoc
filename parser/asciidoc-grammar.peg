{
package parser 

import "github.com/bytesparadise/libasciidoc/types"

// *****************************************************************************************
// This file is generated after its sibling `asciidoc-grammar.peg` file. DO NOT MODIFY !
// *****************************************************************************************

}

// ------------------------------------------
// Document
// ------------------------------------------

Document <- frontMatter:(FrontMatter?) documentHeader:(DocumentHeader?) blocks:(DocumentBlocks) EOF {
	return types.NewDocument(frontMatter, documentHeader, blocks.([]interface{}))
}

DocumentBlocks <- content:(Preamble Section+) / content:(StandaloneBlock*) {
    return content, nil
}

StandaloneBlock <- DocumentAttributeDeclaration / DocumentAttributeReset / List / BlockImage / LiteralBlock / DelimitedBlock / Paragraph / (ElementAttribute EOL) / BlankLine //TODO: should Paragraph be the last type ?

Preamble <- elements:(StandaloneBlock*) {
    return types.NewPreamble(elements.([]interface{}))
}

// ------------------------------------------
// Front Matter
// ------------------------------------------
FrontMatter <- YamlFrontMatter 

FrontMatter <- YamlFrontMatterToken content:(!YamlFrontMatterToken .)* YamlFrontMatterToken {
    return types.NewYamlFrontMatter(content.([]interface{}))
}

YamlFrontMatterToken  <- "---" EOL

// ------------------------------------------
// Document Header
// ------------------------------------------
// TODO: include main title | subtitle with support for custom separator
DocumentHeader <- header:(DocumentTitle) authors:(DocumentAuthors?) revision:(DocumentRevision?) otherAttributes:(DocumentAttributeDeclaration*){ 
    return types.NewDocumentHeader(header, authors, revision, otherAttributes.([]interface{}))
}

DocumentTitle <- attributes:(ElementAttribute)* level:("=") WS+ content:InlineContent EOL { 
     return types.NewSectionTitle(content.(*types.InlineContent), attributes.([]interface{}))
}

DocumentAuthors <- DocumentAuthorsInlineForm / DocumentAuthorsAttributeForm

DocumentAuthorsInlineForm <- WS* !":" authors:(DocumentAuthor+) EOL {
    return types.NewDocumentAuthors(authors.([]interface{}))
}

DocumentAuthorsAttributeForm <- WS* ":author:" author:(DocumentAuthor) {
    return []*types.DocumentAuthor{author.(*types.DocumentAuthor)}, nil
}

DocumentAuthor <- WS* namePart1:(DocumentAuthorNamePart) namePart2:(DocumentAuthorNamePart)? namePart3:(DocumentAuthorNamePart)? email:(DocumentAuthorEmail)? WS* ";"? WS*{
    return types.NewDocumentAuthor(namePart1, namePart2, namePart3, email)
} 

// "<" marks the beginning of the author email, and ";" is the authors separator
DocumentAuthorNamePart <- !"<" !";" Word WS*

DocumentAuthorEmail <- "<" email:(!">" !EOL .)+ ">" 

// see http://asciidoctor.org/docs/user-manual/#revision-number-date-and-remark
// Eg: "v1.0, October 2, 2013: First incarnation"
DocumentRevision <- WS* !":" revnumber:(DocumentRevisionNumber)? ","? revdate:(DocumentRevisionDate)? ":"? revremark:(DocumentRevisionRemark)? EOL {
    return types.NewDocumentRevision(revnumber, revdate, revremark)
}

// DocumentRevisionNumber MUST start with a `v` or MAY start with a `v` but MUST end with a `,`
DocumentRevisionNumber <- "v"i DIGIT  (!EOL !"," !":" .)* / "v"i? DIGIT  (!EOL !"," !":" .)* WS* &","
DocumentRevisionDate <- (!EOL !":" .)* 
DocumentRevisionRemark <- (!EOL .)*

// ------------------------------------------
// Document Attributes
// ------------------------------------------
DocumentAttributeDeclaration <- DocumentAttributeDeclarationWithNameOnly / DocumentAttributeDeclarationWithNameAndValue 

DocumentAttributeDeclarationWithNameOnly <- ":" name:(AttributeName) ":" WS* EOL {
    return types.NewDocumentAttributeDeclaration(name.([]interface{}), nil)
}

DocumentAttributeDeclarationWithNameAndValue <- ":" name:(AttributeName) ":" WS+ value:(!NEWLINE .)* EOL {
    return types.NewDocumentAttributeDeclaration(name.([]interface{}), value.([]interface{}))
}

DocumentAttributeReset <- DocumentAttributeResetWithSectionTitleBangSymbol / DocumentAttributeResetWithTrailingBangSymbol

DocumentAttributeResetWithSectionTitleBangSymbol <- ":!" name:(AttributeName) ":" WS* EOL {
    return types.NewDocumentAttributeReset(name.([]interface{}))
}

DocumentAttributeResetWithTrailingBangSymbol <- ":" name:(AttributeName) "!:" WS* EOL {
    return types.NewDocumentAttributeReset(name.([]interface{}))
}


DocumentAttributeSubstitution <- "{" name:(AttributeName) "}" {
    return types.NewDocumentAttributeSubstitution(name.([]interface{}))
}

// AttributeName must be at least one character long, 
// must begin with a word character (A-Z, a-z, 0-9 or _) and 
// must only contain word characters and hyphens ('-').
AttributeName <- ([A-Z] / [a-z] / [0-9] / "_") ([A-Z] / [a-z] / [0-9] / "-")*

// ------------------------------------------
// Sections
// ------------------------------------------
Section <- Section1 / Section2 / Section3 / Section4 / Section5


Section1 <- header:(Section1Title) elements:(Section1Block*) {
    return types.NewSection(1, header.(*types.SectionTitle), elements.([]interface{}))
}

Section1Block <- !Section1 content:(Section2 / Section3 / Section4 / Section5 / StandaloneBlock) {
    return content.(types.DocElement), nil
}

Section2 <- header:(Section2Title) elements:(Section2Block*) &(Section2)* {
    return types.NewSection(2, header.(*types.SectionTitle), elements.([]interface{}))
}

Section2Block <- !Section1 !Section2 content:(Section3 / Section4 / Section5 / StandaloneBlock) {
    return content.(types.DocElement), nil
}

Section3 <- header:(Section3Title) elements:(Section3Block*) {
    return types.NewSection(3, header.(*types.SectionTitle), elements.([]interface{}))
}

Section3Block <- !Section1 !Section2 !Section3 content:(Section4 / Section5 / StandaloneBlock) {
    return content.(types.DocElement), nil
}

Section4 <- header:(Section4Title) elements:(Section4Block*) {
    return types.NewSection(4, header.(*types.SectionTitle), elements.([]interface{}))
}

Section4Block <- !Section1 !Section2 !Section3 !Section4 content:(Section5 / StandaloneBlock) {
    return content.(types.DocElement), nil
}

Section5 <- header:(Section5Title) elements:(Section5Block*) {
    return types.NewSection(5, header.(*types.SectionTitle), elements.([]interface{}))
}

Section5Block <- !Section1 !Section2 !Section3 !Section4 !Section5 content:(StandaloneBlock) {
    return content.(types.DocElement), nil
}

// ------------------------------------------
// Section Titles
// ------------------------------------------

SectionTitle <- Section1Title / Section2Title / Section3Title / Section4Title / Section5Title

Section1Title <- attributes:(ElementAttribute)* level:("==") WS+ content:InlineContent EOL (BlankLine? / EOF) { 
     return types.NewSectionTitle(content.(*types.InlineContent), attributes.([]interface{}))
}

Section2Title <- attributes:(ElementAttribute)* level:("===") WS+ content:InlineContent EOL (BlankLine? / EOF) {
     return types.NewSectionTitle(content.(*types.InlineContent), attributes.([]interface{}))
}

Section3Title <- attributes:(ElementAttribute)* level:("====") WS+ content:InlineContent EOL (BlankLine? / EOF) {
     return types.NewSectionTitle(content.(*types.InlineContent), attributes.([]interface{}))
}

Section4Title <- attributes:(ElementAttribute)* level:("=====") WS+ content:InlineContent EOL (BlankLine? / EOF) {
     return types.NewSectionTitle(content.(*types.InlineContent), attributes.([]interface{}))
}

Section5Title <- attributes:(ElementAttribute)* level:("======") WS+ content:InlineContent EOL (BlankLine? / EOF) {
     return types.NewSectionTitle(content.(*types.InlineContent), attributes.([]interface{}))
}

// ------------------------------------------
// List Items
// ------------------------------------------
List <- attributes:(ElementAttribute)* 
    // list items can be followed by an optional, single blank line
    elements:(ListItem BlankLine?)+ {
    return types.NewList(elements.([]interface{}), attributes.([]interface{}))
}

ListItem <- WS* level:('*'+ / '-') WS+ content:(ListItemContent) {
    return types.NewListItem(level, content.(*types.ListItemContent), nil)
}

ListItemContent <- lines:(!(WS* ('*'+ / '-') WS+) InlineContent EOL)+ { 
    return types.NewListItemContent(c.text, lines.([]interface{}))
} 
// ------------------------------------------
// Paragraphs
// ------------------------------------------
// a paragraph is a group of line ending with a blank line (or end of file)
// a paragraph cannot start with the `section` sequence (`= `, `== `, etc.)
Paragraph <- attributes:(ElementAttribute)* !("="+ WS+) lines:(InlineContent EOL)+ {
    return types.NewParagraph(c.text, lines.([]interface{}), attributes.([]interface{}))
} 

// an inline content element may start with and end with spaces, 
// but it must contain at least an inline element (image, quoted text, external link, document attribute substitution, word, etc.)
InlineContent <- !FencedBlockDelimiter elements:(WS* InlineElement WS*)+ &EOL { // needs an 'EOL' but does not consume it here.
    return types.NewInlineContent(c.text, elements.([]interface{}))
} 

InlineElement <- InlineImage / QuotedText / ExternalLink / DocumentAttributeSubstitution / Word

// ------------------------------------------
// Quoted Texts (bold, italic and monospace)
// ------------------------------------------
QuotedText <- BoldText / ItalicText / MonospaceText

BoldText <- '*' content:(QuotedTextContent) '*' {
    return types.NewQuotedText(types.Bold, content.([]interface{}))
}

ItalicText <- '_' content:(QuotedTextContent) '_' {
    return types.NewQuotedText(types.Italic, content.([]interface{}))
}

MonospaceText <- '`' content:(QuotedTextContent) '`' {
    return types.NewQuotedText(types.Monospace, content.([]interface{}))
}

QuotedTextContent <- QuotedTextContentElement (WS+ QuotedTextContentElement)*

QuotedTextContentElement <- QuotedText / QuotedTextContentWord / InvalidQuotedTextContentWord

QuotedTextContentWord <- (!NEWLINE !WS !'*' !'_' !'`' .)+ // cannot have '*', '_' or '`' within
InvalidQuotedTextContentWord <- (!NEWLINE !WS  .)+ // can have '*', '_' or '`' within, maybe because the user made an error (extra or missing space, for example)

// ------------------------------------------
// Links
// ------------------------------------------
ExternalLink <- url:(URL_SCHEME URL) text:('[' (URL_TEXT)* ']')? {
    if text != nil {
        return types.NewExternalLink(url.([]interface{}), text.([]interface{}))
    }
    return types.NewExternalLink(url.([]interface{}), nil)
}

// ------------------------------------------
// Images
// ------------------------------------------
BlockImage <- attributes:(ElementAttribute)* image:BlockImageMacro  WS* EOL {
    // here we can ignore the blank line in the returned element
    return types.NewBlockImage(c.text, *image.(*types.ImageMacro), attributes.([]interface{}))
}

BlockImageMacro <- "image::" path:(URL) '[' attributes:(URL_TEXT?) ']' {
    return types.NewImageMacro(c.text, path.(string), attributes)
}

InlineImage <- image:InlineImageMacro {
    // here we can ignore the blank line in the returned element
    return types.NewInlineImage(c.text, *image.(*types.ImageMacro))
}

InlineImageMacro <- "image:" !":" path:(URL) '[' attributes:(URL_TEXT?) ']' {
    return types.NewImageMacro(c.text, path.(string), attributes)
}

// ------------------------------------------------------------------------------------
// Delimited Blocks (http://asciidoctor.org/docs/user-manual/#built-in-blocks-summary)
// ------------------------------------------------------------------------------------
DelimitedBlock <- FencedBlock 

FencedBlock <- FencedBlockDelimiter WS* NEWLINE content:(FencedBlockContent) FencedBlockDelimiter WS* EOL {
    return types.NewDelimitedBlock(types.FencedBlock, content.([]interface{}))
}

FencedBlockDelimiter <- "```"

FencedBlockContent <- content:(!FencedBlockDelimiter .)* 

// -------------------------------------------------------------------------------------
// Literal Blocks (see http://asciidoctor.org/docs/user-manual/#literal-text-and-blocks)
// -------------------------------------------------------------------------------------
LiteralBlock <- ParagraphWithSpaces / ParagraphWithLiteralBlockDelimiter / ParagraphWithLiteralAttribute

// paragraph indented with one or more spaces on the first line
ParagraphWithSpaces <- spaces:(WS+) !NEWLINE content:(LiteralBlockContent) EndOfLiteralBlock {
    // fmt.Printf("matching LiteralBlock with raw content=`%v`\n", content)
    return types.NewLiteralBlock(spaces.([]interface{}), content.([]interface{}))
}

// no NEWLINE allowed between the first spaces and the content of the block
LiteralBlockContent <- content:(!(NEWLINE BlankLine) .)+ { 
    return content, nil
}

// a literal block ends with a blank line (or EOF)
EndOfLiteralBlock <- NEWLINE BlankLine / NEWLINE / EOF

// paragraph with the literal block delimiter (`....`)
ParagraphWithLiteralBlockDelimiter <- LiteralBlockDelimiter WS* NEWLINE content:(!LiteralBlockDelimiter .)* LiteralBlockDelimiter WS* EOL {
    return types.NewLiteralBlock([]interface{}{}, content.([]interface{}))
}

LiteralBlockDelimiter <- "...."

// paragraph with the literal attribute (`[literal]`)
ParagraphWithLiteralAttribute <- "[literal]" WS* NEWLINE content:(LiteralBlockContent) EndOfLiteralBlock {
    return types.NewLiteralBlock([]interface{}{}, content.([]interface{}))
}

// ------------------------------------------
// Element Attributes
// ------------------------------------------
ElementAttribute <- meta:(ElementLink / ElementID / ElementTitle) 

// a link attached to an element, such as a BlockImage
ElementLink <- "[" WS* "link" WS* "=" WS* path:URL WS* "]" EOL {
    return types.NewElementLink(path.(string))
}

// an id attached to an element, such as a BlockImage
ElementID <- "[" WS* '#' id:(ID) WS* "]" EOL {
    return types.NewElementID(id.(string))
}

// a title attached to an element, such as a BlockImage (
// a title starts with a single '.' followed by the value, without space in-between
ElementTitle <- "." !"." !WS title:(!NEWLINE .)+ EOL {
    return types.NewElementTitle(title.([]interface{}))
}

// ------------------------------------------
// Base Types
// ------------------------------------------
Word <- (!NEWLINE !WS .)+ {
    return string(c.text), nil
}

BlankLine <- !EOF WS* EOL {
    return types.NewBlankLine()
}

URL <- (!NEWLINE !WS !'[' !']' .)+ {
    return string(c.text), nil
}

ID <- (!NEWLINE !WS !'[' !']' .)+ {
    return string(c.text), nil
}

URL_TEXT <- (!NEWLINE !'[' !']' .)+ {
    return string(c.text), nil
}

URL_SCHEME <- "http://" / "https://" / "ftp://" / "irc://" / "mailto:"

DIGIT    <- [0-9]

NEWLINE  <- "\r\n" / "\r" / "\n"

WS       <- ' ' / '\t' {
        return string(c.text), nil
}

EOF      <- !.

EOL      <- NEWLINE / EOF