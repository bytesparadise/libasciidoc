{
package parser 

import "github.com/bytesparadise/libasciidoc/types"

// *****************************************************************************************
// This file is generated after its sibling `asciidoc-grammar.peg` file. DO NOT MOIDIFY !
// *****************************************************************************************

}

Document <- lines:Line* EOF {
	return types.NewDocument(lines.([]interface{}))
}

Line <- Heading / ListItem / BlockImage / DelimitedBlock / MetadataElement / Paragraph / BlankLine

// ------------------------------------------
// Headings
// ------------------------------------------
Heading <- metadata:(MetadataElement)* level:("="+) WS+ content:InlineContent {
     return types.NewHeading(level, content.(*types.InlineContent), metadata.([]interface{}))
}

// ------------------------------------------
// List Type
// ------------------------------------------
//TODO: Blank lines are required before and after a list
//TODO: Additionally, blank lines are permitted, but not required, between list items.
ListItem <- WS* ('*' / '-') WS+ content:(InlineContent) {
    return types.NewListItem(content.(*types.InlineContent))
}

// ------------------------------------------
// Paragraph Type
// ------------------------------------------
// a paragraph is a group of line ending with a blank line (or end of file)
Paragraph <- lines:(InlineContent)+ (BlankLine/EOF) {
    return types.NewParagraph(c.text, lines.([]interface{}))
} 

InlineContent <- !NEWLINE elements:(QuotedText / ExternalLink / Word / WS)+ EOL {
    return types.NewInlineContent(c.text, elements.([]interface{}))
} 

// ------------------------------------------
// Quote Types (bold, italic and monospace)
// ------------------------------------------
QuotedText <- BoldText / ItalicText / MonospaceText

BoldText <- '*' content:(QuotedTextContent) '*' {
    return types.NewQuotedText(types.Bold, content.([]interface{}))
}

ItalicText <- '_' content:(QuotedTextContent) '_' {
    return types.NewQuotedText(types.Italic, content.([]interface{}))
}

MonospaceText <- '`' content:(QuotedTextContent) '`' {
    return types.NewQuotedText(types.Monospace, content.([]interface{}))
}

QuotedTextContent <- QuotedTextContentElement (WS+ QuotedTextContentElement)*

QuotedTextContentElement <- QuotedText / QuotedTextContentWord / InvalidQuotedTextContentWord

QuotedTextContentWord <- (!NEWLINE !WS !'*' !'_' !'`' .)+ // cannot have '*', '_' or '`' within
InvalidQuotedTextContentWord <- (!NEWLINE !WS  .)+ // can have '*', '_' or '`' within, maybe because the user made an error (extra or missing space, for example)

// ------------------------------------------
// Link Type
// ------------------------------------------
ExternalLink <- url:(URL_SCHEME URL) text:('[' (URL_TEXT)* ']')? {
    if text != nil {
        return types.NewExternalLink(url.([]interface{}), text.([]interface{}))
    }
    return types.NewExternalLink(url.([]interface{}), nil)
}

// ------------------------------------------
// Image Type
// ------------------------------------------
BlockImage <- metadata:(MetadataElement)* image:BlockImageMacro {
    // here we can ignore the blank line in the returned element
    return types.NewBlockImage(c.text, *image.(*types.BlockImageMacro), metadata.([]interface{}))
}

BlockImageMacro <- "image::" path:(URL) '[' attributes:(URL_TEXT?) ']' EOL {
    if attributes != nil {
        attrs := attributes.(string)
        return types.NewBlockImageMacro(c.text, path.(string), &attrs)
    }
    return types.NewBlockImageMacro(c.text, path.(string), nil)
}

// ------------------------------------------
// Delimited Block Types
// ------------------------------------------

DelimitedBlock <- SourceBlock

SourceBlock <- SourceBlockDelimiter NEWLINE content:(SourceBlockLine)*  SourceBlockDelimiter {
    return types.NewDelimitedBlock(types.SourceBlock, content.([]interface{}))
}

SourceBlockDelimiter <- "```"

SourceBlockLine <- (!EOL .)* NEWLINE

// ------------------------------------------
// Meta Element Types
// ------------------------------------------
MetadataElement <- meta:(ElementLink / ElementID / ElementTitle) 

// a link attached to an element, such as a BlockImage
ElementLink <- "[" WS* "link" WS* "=" WS* path:URL WS* "]" EOL {
    return types.NewElementLink(path.(string))
}

// an id attached to an element, such as a BlockImage
ElementID <- "[" WS* '#' id:(ID) WS* "]" EOL {
    return types.NewElementID(id.(string))
}

// a title attached to an element, such as a BlockImage
ElementTitle <- "." !WS title:(!NEWLINE .)+ EOL {
    return types.NewElementTitle(title.([]interface{}))
}

// ------------------------------------------
// Base Types
// ------------------------------------------
Word <- (!NEWLINE !WS .)+ {
    return string(c.text), nil
}

URL <- (!NEWLINE !WS !'[' !']' .)+ {
    return string(c.text), nil
}

ID <- (!NEWLINE !WS !'[' !']' .)+ {
    return string(c.text), nil
}

URL_TEXT <- (!NEWLINE !'[' !']' .)+ {
    return string(c.text), nil
}


BlankLine <- NEWLINE {
    return types.NewBlankLine()
}

URL_SCHEME <- "http://" / "https://" / "ftp://" / "irc://" / "mailto:"
DIGIT    <- [0-9]
NEWLINE  <- "\r\n" / '\r' / '\n'
WS       <- ' ' / '\t' {
        return string(c.text), nil
}
EOF      <- !.
EOL      <- NEWLINE / EOF