{
package parser 

import "github.com/bytesparadise/libasciidoc/types"

// *****************************************************************************************
// This file is generated after its sibling `asciidoc-grammar.peg` file. DO NOT MOIDIFY !
// *****************************************************************************************

}

Document <- lines:Line* EOF {
	return types.NewDocument(lines.([]interface{}))
}

Line <- line:(Heading / ListItem / BlockImage / MetaElement / Inline / EmptyLine) {
    return line, nil
}

Heading <- level:("="+) WS+ content:Inline {
     return types.NewHeading(level, content.(*types.InlineContent))
}

// ---------------------
// Lists
// ---------------------
//TODO: Blank lines are required before and after a list
//TODO: Additionally, blank lines are permitted, but not required, between list items.
ListItem <- WS* ('*' / '-') WS+ content:(Inline) {
    return types.NewListItem(content.(*types.InlineContent))
}

// ---------------------
// Quotes
// ---------------------
BoldQuote <- '*' content:(BoldContent) '*' {
    return types.NewBoldQuote(content)
}

BoldContent <- (BoldContentWord WS+)* BoldContentWord {
    return string(c.text), nil
}

BoldContentWord <- (!NEWLINE !WS !'*' .)+ {
    return string(c.text), nil
}

// ---------------------
// Links
// ---------------------
ExternalLink <- url:(URL_SCHEME URL) text:('[' (URL_TEXT)* ']')? {
    if text != nil {
        return types.NewExternalLink(url.([]interface{}), text.([]interface{}))
    }
    return types.NewExternalLink(url.([]interface{}), nil)
}

// ---------------------
// Images
// ---------------------
BlockImage <- "image::" path:(URL) altText:('[' (URL_TEXT)* ']') (NEWLINE/EOF) {
    return types.NewBlockImage(path.(string), altText.([]interface{}))
}

// ---------------------
// Inline content
// ---------------------
Inline <- !NEWLINE elements:(BoldQuote / ExternalLink / Word / WS)+ (NEWLINE/EOF) {
    return types.NewInlineContent(elements.([]interface{}))
} 

// ---------------------
// meta-element types
// ---------------------
MetaElement <- meta:(ElementLink / ElementID / ElementTitle) {
    return meta, nil
}

// a link attached to an element, such as a BlockImage
ElementLink <- "[" WS* "link" WS* "=" WS* path:URL WS* "]" (NEWLINE/EOF) {
    return types.NewElementLink(path.(string))
}

// an id attached to an element, such as a BlockImage
ElementID <- "[" WS* id:(ID) WS* "]" (NEWLINE/EOF) {
    return types.NewElementID(id.(string))
}

// a title attached to an element, such as a BlockImage
ElementTitle <- "." !WS title:(!NEWLINE .)+ (NEWLINE/EOF) {
    return types.NewElementTitle(title.([]interface{}))
}

// ---------------------
// Base types
// ---------------------
Word <- (!NEWLINE !WS .)+ {
    return string(c.text), nil
}

URL <- (!NEWLINE !WS !'[' !']' .)+ {
    return string(c.text), nil
}

ID <- '#' (!NEWLINE !WS !'[' !']' .)+ {
    return string(c.text), nil
}

URL_TEXT <- (!NEWLINE !'[' !']' .)+ {
    return string(c.text), nil
}


EmptyLine <- NEWLINE {
    return types.NewEmptyLine()
}

URL_SCHEME <- "http://" / "https://" / "ftp://" / "irc://" / "mailto:"
DIGIT    <- [0-9]
NEWLINE  <- "\r\n" / '\r' / '\n'
WS       <- ' ' / '\t' {
        return string(c.text), nil
}
EOF      <- !.